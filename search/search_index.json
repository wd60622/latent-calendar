{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Latent Calendar","text":"<p>Analyze and model data on a weekly calendar</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install latent-calendar\n</code></pre>"},{"location":"#features","title":"Features","text":"<ul> <li>Integrated automatically into <code>pandas</code> with <code>cal</code> attribute on DataFrames and Series </li> <li>Compatibility with <code>scikit-learn</code> pipelines</li> <li>Transform and visualize data on a weekly calendar</li> <li>Model weekly calendar data with a mixture of calendars</li> </ul>"},{"location":"draft/","title":"Draft","text":""},{"location":"draft/#1-transform-and-visualize","title":"1. Transform and visualize","text":"<p>Transform and visualize data on a weekly calendar with the <code>cal</code> attribute of DataFrames.</p> <pre><code>import matplotlib.pyplot as plt\nfrom latent_calendar.datasets import load_chicago_bikes\ndf = load_chicago_bikes()\ndf_member_casual = df.cal.aggregate_events(\"member_casual\", timestamp_col=\"started_at\")\n(\ndf_member_casual\n.cal.normalize(\"max\")\n.cal.plot_by_row()\n)\nfig = plt.gcf()\nfig.suptitle(\"Bike Rentals by Member Type\")\nplt.show()\n</code></pre> <p></p>"},{"location":"draft/#2-find-latent-structure","title":"2. Find latent structure","text":"<p>The <code>LatentCalendar</code> models calendar data by breaking down each calendar into a mixture of <code>n_components</code> calendars. Read more on the methodology here.</p> <pre><code>from latent_calendar import LatentCalendar\nfrom latent_calendar.plot import plot_model_components\ndf_stations = df.cal.aggregate_events(\"start_station_name\", timestamp_col=\"started_at\")\nmodel = LatentCalendar(n_components=3, random_state=42)\nmodel.fit(df_wide)\nplot_model_components(model)\nfig = plt.gcf()\nfig.suptitle(\"Chicago Bike Rental Model Components\")\nplt.show()\n</code></pre> <p></p>"},{"location":"draft/#3-recover-components-and-distributions","title":"3. Recover components and distributions","text":"<p>The <code>LatentCalendar</code> provides soft clusters for each row which can be recovered with the <code>transform</code> method.</p> <pre><code>df_component_probs = df_stations.cal.transform(model=model)\nhist_kwargs = dict(bins=10, edgecolor=\"black\", grid=False, layout=(1, 3))\naxes = df_component_probs.hist(**hist_kwargs)\naxes = axes.ravel()\nfor ax in axes: \nax.set_xlabel(\"Probability\")\ntitle = ax.get_title()\nax.set_title(f\"Component {title}\")\naxes[0].set_ylabel(\"# Stations\")\nfig = plt.gcf()\nfig.suptitle(\"Station Component Distributions\")\nplt.show()\n</code></pre> <p></p> <p>The <code>predict</code> method recovers the joint distribution of the calendar data using the latent calendar components. </p> <pre><code>stations = [\"Wood St &amp; Milwaukee Ave\", \"Theater on the Lake\", \"Wabash Ave &amp; Grand Ave\"]\ndf_stations.loc[stations].cal.plot_profile()\nplt.show()\n</code></pre> <p></p>"},{"location":"methodology/","title":"Methodology","text":"<p>The methodology comes from the generation process of the data and realization that discretized times of day can be modeled with a multinomial distribution. More details to come.</p>"},{"location":"examples/cal-attribute/","title":"Cal attribute","text":"<p>Transform and visualize data on a weekly calendar with the <code>cal</code> attribute of DataFrames.</p> <pre><code>import matplotlib.pyplot as plt\nfrom latent_calendar.datasets import load_chicago_bikes\ndf = load_chicago_bikes()\ndf_member_casual = df.cal.to_vocab(\"member_casual\", \"started_at\")\n</code></pre> <pre><code>\n</code></pre> <pre><code>(\ndf_member_casual\n.cal.normalize(\"max\")\n.cal.plot_by_row()\n)\nfig = plt.gcf()\nfig.suptitle(\"Bike Rentals by Member Type\")\nplt.show()\n</code></pre>"},{"location":"examples/create-segments/","title":"Create segments","text":"<pre><code>from latent_calendar.segments import create_box\n</code></pre>"},{"location":"examples/plotting-dataframes/","title":"Plotting dataframes","text":"<p>DataFrames can be plotted in various ways with the <code>cal</code> attribute. </p> <p>Event level data with the <code>cal.plot_calendar</code> or <code>cal.plot_calendar_across_column</code></p> <p>``````</p>"},{"location":"examples/store-transactions/","title":"Store transactions","text":"<p>Creating transforming data into a calendar format</p> <pre><code>from latent_calendar.datasets import load_online_transactions\ndf = load_online_transactions()\ndf.head()\n</code></pre> <pre><code>        StockCode                          Description  Quantity         InvoiceDate  Price  Customer ID         Country\nInvoice                                                                                                                 \n489434      85048  15CM CHRISTMAS GLASS BALL 20 LIGHTS        12 2009-12-01 07:45:00   6.95      13085.0  United Kingdom\n489434     79323P                   PINK CHERRY LIGHTS        12 2009-12-01 07:45:00   6.75      13085.0  United Kingdom\n489434     79323W                  WHITE CHERRY LIGHTS        12 2009-12-01 07:45:00   6.75      13085.0  United Kingdom\n489434      22041         RECORD FRAME 7\" SINGLE SIZE         48 2009-12-01 07:45:00   2.10      13085.0  United Kingdom\n489434      21232       STRAWBERRY CERAMIC TRINKET BOX        24 2009-12-01 07:45:00   1.25      13085.0  United Kingdom\n</code></pre> <p>By default, a new <code>cal</code> attribute will be added to DataFrames given access to module functionality.</p> <pre><code>df_wide = df.cal.to_vocab(\"Country\", \"InvoiceDate\")\ndf_wide.head()\n</code></pre> <pre><code>vocab      00 00  00 01  00 02  00 03  00 04  00 05  00 06  00 07  00 08  ...  06 15  06 16  06 17  06 18  06 19  06 20  06 21  06 22  06 23\nCountry                                                                   ...                                                               \nAustralia      0      0      0      0      0      0      0      0      0  ...      0      0      0      0      0      0      0      0      0\nAustria        0      0      0      0      0      0      0      0      9  ...      0      0      0      0      0      0      0      0      0\nBahrain        0      0      0      0      0      0      0      0      0  ...      0      0      0      0      0      0      0      0      0\nBelgium        0      0      0      0      0      0      0      0     15  ...    131      0      0      0      0      0      0      0      0\nBermuda        0      0      0      0      0      0      0      0      0  ...      0      0      0      0      0      0      0      0      0\n\n[5 rows x 168 columns]\n</code></pre> <pre><code>countries = [\"United Kingdom\", \"Germany\", \"France\"]\nimport matplotlib.pyplot as plt\n(\ndf_wide\n.loc[countries]\n.cal.normalize(\"max\")\n.cal.plot_by_row()\n)\nfig = plt.gcf()\nfig.suptitle(\"Store Transactions by Country\")\nplt.show()\n</code></pre> <p></p>"},{"location":"modules/datasets/","title":"Datasets","text":"<p>Example datasets for latent_calendar.</p>"},{"location":"modules/datasets/#latent_calendar.datasets.load_chicago_bikes","title":"<code>load_chicago_bikes()</code>","text":"<p>Bikesharing trip level data from Chicago's Divvy system.</p> <p>Read more about the data source here.</p> <p>Pulled</p> <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>Trips data from Chicago's Divvy system.</p> Source code in <code>latent_calendar/datasets/__init__.py</code> <pre><code>def load_chicago_bikes() -&gt; pd.DataFrame:\n\"\"\"Bikesharing trip level data from Chicago's Divvy system.\n    Read more about the data source [here](https://data.cityofchicago.org/Transportation/Divvy-Trips/fg6s-gzvg).\n    Pulled\n    Returns:\n        Trips data from Chicago's Divvy system.\n    \"\"\"\nfile = HERE / \"chicago-bikes.csv\"\nreturn pd.read_csv(\nfile, parse_dates=[\"started_at\", \"ended_at\"], index_col=[\"ride_id\"]\n)\n</code></pre>"},{"location":"modules/datasets/#latent_calendar.datasets.load_online_transactions","title":"<code>load_online_transactions()</code>","text":"<p>Kaggle Data for an non-store online retailer in UK. More information here.</p> Source code in <code>latent_calendar/datasets/__init__.py</code> <pre><code>def load_online_transactions() -&gt; pd.DataFrame:\n\"\"\"Kaggle Data for an non-store online retailer in UK. More information [here](https://www.kaggle.com/datasets/mashlyn/online-retail-ii-uci).\"\"\"\nfile = HERE / \"online_retail_II.csv\"\nreturn pd.read_csv(file, parse_dates=[\"InvoiceDate\"], index_col=[\"Invoice\"])\n</code></pre>"},{"location":"modules/extensions/","title":"Extensions","text":"<p>Pandas extensions for <code>latent-calendar</code>.</p> <p>Provides a <code>cal</code> accessor to <code>DataFrame</code> and <code>Series</code> instances for easy transformation and plotting after import of <code>latent_calendar</code>.</p> <p>Functionality includes: </p> <ul> <li>aggregation of events to wide format</li> <li>convolutions of wide formats</li> <li>making transformations and predictions with models</li> <li>plotting of events, predictions, and comparisons as calendars</li> </ul> <p>Examples:</p> <p>Plotting a Series as a calendar </p> <pre><code>import pandas as pd\nimport latent_calendar\ndates = pd.date_range(\"2023-01-01\", \"2023-01-14\", freq=\"H\")\nser = (\npd.Series(dates)\n.sample(10, random_state=42)\n)\nser.cal.plot()\n</code></pre> <p></p> <p>Transform event level DataFrame to wide format and plot</p> <pre><code>from latent_calendar.datasets import load_online_transactions\ndf = load_online_transactions()\n# (n_customer, n_timeslots)\ndf_wide = (\ndf\n.cal.aggregate_events(\"Customer ID\", timestamp_col=\"InvoiceDate\")\n)\n(\ndf_wide\n.sample(n=12, random_state=42)\n.cal.plot_by_row(max_cols=4)\n)\n</code></pre> <p></p> <p>Train a model and plot predictions </p> <pre><code>from latent_calendar import LatentCalendar\nmodel = LatentCalendar(n_components=5, random_state=42)\nmodel.fit(df_wide.to_numpy())\n(\ndf_wide\n.head(2)\n.cal.plot_profile_by_row(model=model)\n)\n</code></pre> <p></p>"},{"location":"modules/extensions/#latent_calendar.extensions.DataFrameAccessor","title":"<code>DataFrameAccessor</code>","text":"<p>DataFrame accessor for latent_calendar accessed through <code>cal</code> attribute of DataFrames.</p> Source code in <code>latent_calendar/extensions.py</code> <pre><code>@pd.api.extensions.register_dataframe_accessor(\"cal\")\nclass DataFrameAccessor:\n\"\"\"DataFrame accessor for latent_calendar accessed through `cal` attribute of DataFrames.\"\"\"\ndef __init__(self, pandas_obj: pd.DataFrame):\nself._obj = pandas_obj\ndef normalize(self, kind: str) -&gt; pd.DataFrame:\n\"\"\"Row-wise operations on DataFrame.\"\"\"\nif kind == \"max\":\nreturn self._obj.div(self._obj.max(axis=1), axis=0)\nelif kind == \"probs\":\nreturn self._obj.div(self._obj.sum(axis=1), axis=0)\nelif kind == \"even_rate\":\nvalue = self._obj.shape[1]\nreturn self._obj.div(value)\nraise ValueError(f\"kind must be one of ['max', 'probs'], got {kind}\")\ndef aggregate_events(\nself,\nby: Union[str, List[str]],\ntimestamp_col: str,\n) -&gt; pd.DataFrame:\n\"\"\"Transform DataFrame to wide format with groups as index.\n        Wrapper around `create_raw_to_vocab_transformer` to transform to wide format.\n        Args:\n            by: column(s) to use as index\n            timestamp_col: column to use as timestamp\n        Returns:\n            DataFrame in wide format\n        \"\"\"\nif not isinstance(by, list):\nid_col = by\nadditional_groups = None\nelse:\nid_col, *additional_groups = by\ntransformer = create_raw_to_vocab_transformer(\nid_col=id_col,\ntimestamp_col=timestamp_col,\nadditional_groups=additional_groups,\n)\nreturn transformer.fit_transform(self._obj)\ndef sum_over_vocab(self, aggregation: str = \"dow\") -&gt; pd.DataFrame:\n\"\"\"Sum the wide format to day of week or hour of day.\"\"\"\nreturn sum_over_vocab(self._obj, aggregation=aggregation)\ndef sum_next_hours(self, hours: int) -&gt; pd.DataFrame:\n\"\"\"Sum the wide format over next hours.\"\"\"\nreturn sum_next_hours(self._obj, hours=hours)\ndef sum_over_segments(self, df_segments: pd.DataFrame) -&gt; pd.DataFrame:\n\"\"\"Sum the wide format over user defined segments.\"\"\"\nreturn sum_over_segments(self._obj, df_segments=df_segments)\ndef transform(self, *, model) -&gt; pd.DataFrame:\n\"\"\"Transform DataFrame with model.\"\"\"\nreturn transform_on_dataframe(self._obj, model=model)\ndef predict(self, *, model) -&gt; pd.DataFrame:\n\"\"\"Predict DataFrame with model.\"\"\"\nreturn predict_on_dataframe(self._obj, model=model)\ndef plot(\nself,\nstart_col: str,\n*,\nend_col: Optional[str] = None,\nlength: Optional[int] = None,\nalpha: float = None,\ncmap=None,\nmonday_start: bool = True,\nax: Optional[plt.Axes] = None,\n) -&gt; plt.Axes:\n\"\"\"Plot DataFrame of timestamps as a calendar.\n        Args:\n            start_col: column with start timestamp\n            end_col: column with end timestamp\n            length: length of event in minutes. Alternative to end_col\n            alpha: alpha value for the color\n            cmap: function that maps floats to string colors\n            monday_start: whether to start the week on Monday or Sunday\n            ax: optional matplotlib axis to plot on\n        Returns:\n            Modified matplotlib axis\n        \"\"\"\nconfig = StartEndConfig(start=start_col, end=end_col, minutes=length)\nreturn plot_dataframe_as_calendar(\nself._obj,\nconfig=config,\nalpha=alpha,\ncmap=cmap,\nmonday_start=monday_start,\nax=ax,\n)\ndef plot_across_column(\nself,\nstart_col: str,\ngrid_col: str,\n*,\nend_col: Optional[str] = None,\nlength: Optional[int] = None,\nmax_cols: int = 3,\nalpha: float = None,\n) -&gt; None:\n\"\"\"Plot DataFrame of timestamps as a calendar as grid across column values.\n        NA values are excluded\n        Args:\n            start_col: column with start timestamp\n            grid_col: column of values to use as grid\n            end_col: column with end timestamp\n            length: length of event in minutes. Alternative to end_col\n            max_cols: max number of columns per row\n            alpha: alpha value for the color\n        Returns:\n            None\n        \"\"\"\nconfig = StartEndConfig(start=start_col, end=end_col, minutes=length)\nplot_dataframe_grid_across_column(\nself._obj, grid_col=grid_col, config=config, max_cols=max_cols, alpha=alpha\n)\ndef plot_by_row(\nself,\n*,\nmax_cols: int = 3,\ntitle_func: Optional[TITLE_FUNC] = None,\nday_labeler: Optional[DayLabeler] = None,\ntime_labeler: Optional[TimeLabeler] = None,\ncmaps: Optional[Union[CMAP, ColorMap, CMAP_GENERATOR]] = None,\n) -&gt; None:\n\"\"\"Plot each row of the DataFrame as a calendar plot. Data must have been transformed to wide format first.\n        Wrapper around `latent_calendar.plot.plot_calendar_by_row`.\n        Args:\n            max_cols: max number of columns per row of grid\n            title_func: function to generate title for each row\n            day_labeler: function to generate day labels\n            time_labeler: function to generate time labels\n            cmaps: optional generator of colormaps\n        Returns:\n            None\n        \"\"\"\nreturn plot_calendar_by_row(\nself._obj,\nmax_cols=max_cols,\ntitle_func=title_func,\nday_labeler=day_labeler,\ntime_labeler=time_labeler,\ncmaps=cmaps,\n)\ndef plot_profile_by_row(\nself,\n*,\nmodel: LatentCalendar,\nindex_func=lambda idx: idx,\ninclude_components: bool = True,\n) -&gt; np.ndarray:\n\"\"\"Plot each row of the DataFrame as a profile plot. Data must have been transformed to wide format first.\n        Args:\n            model: model to use for prediction and transform\n            index_func: function to generate title for each row\n            include_components: whether to include components in the plot\n        Returns:\n            grid of axes\n        \"\"\"\nreturn plot_profile_by_row(\nself._obj,\nmodel=model,\nindex_func=index_func,\ninclude_components=include_components,\n)\ndef plot_raw_and_predicted_by_row(\nself, *, model: LatentCalendar, index_func=lambda idx: idx\n) -&gt; np.ndarray:\n\"\"\"Plot raw and predicted values for a model. Data must have been transformed to wide format first.\n        Args:\n            model: model to use for prediction\n            index_func: function to generate title for each row\n        Returns:\n            grid of axes\n        \"\"\"\nreturn plot_profile_by_row(\nself._obj, model=model, index_func=index_func, include_components=False\n)\ndef plot_model_predictions_by_row(\nself,\ndf_holdout: pd.DataFrame,\n*,\nmodel: LatentCalendar,\nindex_func=lambda idx: idx,\ndivergent: bool = True,\n) -&gt; np.ndarray:\n\"\"\"Plot model predictions for each row of the DataFrame. Data must have been transformed to wide format first.\n        Args:\n            df_holdout: holdout DataFrame for comparison\n            model: model to use for prediction\n            index_func: function to generate title for each row\n            divergent: whether to use divergent colormap\n        Returns:\n            grid of axes\n        \"\"\"\nreturn plot_model_predictions_by_row(\nself._obj,\ndf_holdout=df_holdout,\nmodel=model,\nindex_func=index_func,\ndivergent=divergent,\n)\n</code></pre>"},{"location":"modules/extensions/#latent_calendar.extensions.DataFrameAccessor.aggregate_events","title":"<code>aggregate_events(by, timestamp_col)</code>","text":"<p>Transform DataFrame to wide format with groups as index.</p> <p>Wrapper around <code>create_raw_to_vocab_transformer</code> to transform to wide format.</p> <p>Parameters:</p> Name Type Description Default <code>by</code> <code>Union[str, List[str]]</code> <p>column(s) to use as index</p> required <code>timestamp_col</code> <code>str</code> <p>column to use as timestamp</p> required <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>DataFrame in wide format</p> Source code in <code>latent_calendar/extensions.py</code> <pre><code>def aggregate_events(\nself,\nby: Union[str, List[str]],\ntimestamp_col: str,\n) -&gt; pd.DataFrame:\n\"\"\"Transform DataFrame to wide format with groups as index.\n    Wrapper around `create_raw_to_vocab_transformer` to transform to wide format.\n    Args:\n        by: column(s) to use as index\n        timestamp_col: column to use as timestamp\n    Returns:\n        DataFrame in wide format\n    \"\"\"\nif not isinstance(by, list):\nid_col = by\nadditional_groups = None\nelse:\nid_col, *additional_groups = by\ntransformer = create_raw_to_vocab_transformer(\nid_col=id_col,\ntimestamp_col=timestamp_col,\nadditional_groups=additional_groups,\n)\nreturn transformer.fit_transform(self._obj)\n</code></pre>"},{"location":"modules/extensions/#latent_calendar.extensions.DataFrameAccessor.normalize","title":"<code>normalize(kind)</code>","text":"<p>Row-wise operations on DataFrame.</p> Source code in <code>latent_calendar/extensions.py</code> <pre><code>def normalize(self, kind: str) -&gt; pd.DataFrame:\n\"\"\"Row-wise operations on DataFrame.\"\"\"\nif kind == \"max\":\nreturn self._obj.div(self._obj.max(axis=1), axis=0)\nelif kind == \"probs\":\nreturn self._obj.div(self._obj.sum(axis=1), axis=0)\nelif kind == \"even_rate\":\nvalue = self._obj.shape[1]\nreturn self._obj.div(value)\nraise ValueError(f\"kind must be one of ['max', 'probs'], got {kind}\")\n</code></pre>"},{"location":"modules/extensions/#latent_calendar.extensions.DataFrameAccessor.plot","title":"<code>plot(start_col, *, end_col=None, length=None, alpha=None, cmap=None, monday_start=True, ax=None)</code>","text":"<p>Plot DataFrame of timestamps as a calendar.</p> <p>Parameters:</p> Name Type Description Default <code>start_col</code> <code>str</code> <p>column with start timestamp</p> required <code>end_col</code> <code>Optional[str]</code> <p>column with end timestamp</p> <code>None</code> <code>length</code> <code>Optional[int]</code> <p>length of event in minutes. Alternative to end_col</p> <code>None</code> <code>alpha</code> <code>float</code> <p>alpha value for the color</p> <code>None</code> <code>cmap</code> <p>function that maps floats to string colors</p> <code>None</code> <code>monday_start</code> <code>bool</code> <p>whether to start the week on Monday or Sunday</p> <code>True</code> <code>ax</code> <code>Optional[plt.Axes]</code> <p>optional matplotlib axis to plot on</p> <code>None</code> <p>Returns:</p> Type Description <code>plt.Axes</code> <p>Modified matplotlib axis</p> Source code in <code>latent_calendar/extensions.py</code> <pre><code>def plot(\nself,\nstart_col: str,\n*,\nend_col: Optional[str] = None,\nlength: Optional[int] = None,\nalpha: float = None,\ncmap=None,\nmonday_start: bool = True,\nax: Optional[plt.Axes] = None,\n) -&gt; plt.Axes:\n\"\"\"Plot DataFrame of timestamps as a calendar.\n    Args:\n        start_col: column with start timestamp\n        end_col: column with end timestamp\n        length: length of event in minutes. Alternative to end_col\n        alpha: alpha value for the color\n        cmap: function that maps floats to string colors\n        monday_start: whether to start the week on Monday or Sunday\n        ax: optional matplotlib axis to plot on\n    Returns:\n        Modified matplotlib axis\n    \"\"\"\nconfig = StartEndConfig(start=start_col, end=end_col, minutes=length)\nreturn plot_dataframe_as_calendar(\nself._obj,\nconfig=config,\nalpha=alpha,\ncmap=cmap,\nmonday_start=monday_start,\nax=ax,\n)\n</code></pre>"},{"location":"modules/extensions/#latent_calendar.extensions.DataFrameAccessor.plot_across_column","title":"<code>plot_across_column(start_col, grid_col, *, end_col=None, length=None, max_cols=3, alpha=None)</code>","text":"<p>Plot DataFrame of timestamps as a calendar as grid across column values.</p> <p>NA values are excluded</p> <p>Parameters:</p> Name Type Description Default <code>start_col</code> <code>str</code> <p>column with start timestamp</p> required <code>grid_col</code> <code>str</code> <p>column of values to use as grid</p> required <code>end_col</code> <code>Optional[str]</code> <p>column with end timestamp</p> <code>None</code> <code>length</code> <code>Optional[int]</code> <p>length of event in minutes. Alternative to end_col</p> <code>None</code> <code>max_cols</code> <code>int</code> <p>max number of columns per row</p> <code>3</code> <code>alpha</code> <code>float</code> <p>alpha value for the color</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>latent_calendar/extensions.py</code> <pre><code>def plot_across_column(\nself,\nstart_col: str,\ngrid_col: str,\n*,\nend_col: Optional[str] = None,\nlength: Optional[int] = None,\nmax_cols: int = 3,\nalpha: float = None,\n) -&gt; None:\n\"\"\"Plot DataFrame of timestamps as a calendar as grid across column values.\n    NA values are excluded\n    Args:\n        start_col: column with start timestamp\n        grid_col: column of values to use as grid\n        end_col: column with end timestamp\n        length: length of event in minutes. Alternative to end_col\n        max_cols: max number of columns per row\n        alpha: alpha value for the color\n    Returns:\n        None\n    \"\"\"\nconfig = StartEndConfig(start=start_col, end=end_col, minutes=length)\nplot_dataframe_grid_across_column(\nself._obj, grid_col=grid_col, config=config, max_cols=max_cols, alpha=alpha\n)\n</code></pre>"},{"location":"modules/extensions/#latent_calendar.extensions.DataFrameAccessor.plot_by_row","title":"<code>plot_by_row(*, max_cols=3, title_func=None, day_labeler=None, time_labeler=None, cmaps=None)</code>","text":"<p>Plot each row of the DataFrame as a calendar plot. Data must have been transformed to wide format first.</p> <p>Wrapper around <code>latent_calendar.plot.plot_calendar_by_row</code>.</p> <p>Parameters:</p> Name Type Description Default <code>max_cols</code> <code>int</code> <p>max number of columns per row of grid</p> <code>3</code> <code>title_func</code> <code>Optional[TITLE_FUNC]</code> <p>function to generate title for each row</p> <code>None</code> <code>day_labeler</code> <code>Optional[DayLabeler]</code> <p>function to generate day labels</p> <code>None</code> <code>time_labeler</code> <code>Optional[TimeLabeler]</code> <p>function to generate time labels</p> <code>None</code> <code>cmaps</code> <code>Optional[Union[CMAP, ColorMap, CMAP_GENERATOR]]</code> <p>optional generator of colormaps</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>latent_calendar/extensions.py</code> <pre><code>def plot_by_row(\nself,\n*,\nmax_cols: int = 3,\ntitle_func: Optional[TITLE_FUNC] = None,\nday_labeler: Optional[DayLabeler] = None,\ntime_labeler: Optional[TimeLabeler] = None,\ncmaps: Optional[Union[CMAP, ColorMap, CMAP_GENERATOR]] = None,\n) -&gt; None:\n\"\"\"Plot each row of the DataFrame as a calendar plot. Data must have been transformed to wide format first.\n    Wrapper around `latent_calendar.plot.plot_calendar_by_row`.\n    Args:\n        max_cols: max number of columns per row of grid\n        title_func: function to generate title for each row\n        day_labeler: function to generate day labels\n        time_labeler: function to generate time labels\n        cmaps: optional generator of colormaps\n    Returns:\n        None\n    \"\"\"\nreturn plot_calendar_by_row(\nself._obj,\nmax_cols=max_cols,\ntitle_func=title_func,\nday_labeler=day_labeler,\ntime_labeler=time_labeler,\ncmaps=cmaps,\n)\n</code></pre>"},{"location":"modules/extensions/#latent_calendar.extensions.DataFrameAccessor.plot_model_predictions_by_row","title":"<code>plot_model_predictions_by_row(df_holdout, *, model, index_func=lambda idx: idx, divergent=True)</code>","text":"<p>Plot model predictions for each row of the DataFrame. Data must have been transformed to wide format first.</p> <p>Parameters:</p> Name Type Description Default <code>df_holdout</code> <code>pd.DataFrame</code> <p>holdout DataFrame for comparison</p> required <code>model</code> <code>LatentCalendar</code> <p>model to use for prediction</p> required <code>index_func</code> <p>function to generate title for each row</p> <code>lambda idx: idx</code> <code>divergent</code> <code>bool</code> <p>whether to use divergent colormap</p> <code>True</code> <p>Returns:</p> Type Description <code>np.ndarray</code> <p>grid of axes</p> Source code in <code>latent_calendar/extensions.py</code> <pre><code>def plot_model_predictions_by_row(\nself,\ndf_holdout: pd.DataFrame,\n*,\nmodel: LatentCalendar,\nindex_func=lambda idx: idx,\ndivergent: bool = True,\n) -&gt; np.ndarray:\n\"\"\"Plot model predictions for each row of the DataFrame. Data must have been transformed to wide format first.\n    Args:\n        df_holdout: holdout DataFrame for comparison\n        model: model to use for prediction\n        index_func: function to generate title for each row\n        divergent: whether to use divergent colormap\n    Returns:\n        grid of axes\n    \"\"\"\nreturn plot_model_predictions_by_row(\nself._obj,\ndf_holdout=df_holdout,\nmodel=model,\nindex_func=index_func,\ndivergent=divergent,\n)\n</code></pre>"},{"location":"modules/extensions/#latent_calendar.extensions.DataFrameAccessor.plot_profile_by_row","title":"<code>plot_profile_by_row(*, model, index_func=lambda idx: idx, include_components=True)</code>","text":"<p>Plot each row of the DataFrame as a profile plot. Data must have been transformed to wide format first.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>LatentCalendar</code> <p>model to use for prediction and transform</p> required <code>index_func</code> <p>function to generate title for each row</p> <code>lambda idx: idx</code> <code>include_components</code> <code>bool</code> <p>whether to include components in the plot</p> <code>True</code> <p>Returns:</p> Type Description <code>np.ndarray</code> <p>grid of axes</p> Source code in <code>latent_calendar/extensions.py</code> <pre><code>def plot_profile_by_row(\nself,\n*,\nmodel: LatentCalendar,\nindex_func=lambda idx: idx,\ninclude_components: bool = True,\n) -&gt; np.ndarray:\n\"\"\"Plot each row of the DataFrame as a profile plot. Data must have been transformed to wide format first.\n    Args:\n        model: model to use for prediction and transform\n        index_func: function to generate title for each row\n        include_components: whether to include components in the plot\n    Returns:\n        grid of axes\n    \"\"\"\nreturn plot_profile_by_row(\nself._obj,\nmodel=model,\nindex_func=index_func,\ninclude_components=include_components,\n)\n</code></pre>"},{"location":"modules/extensions/#latent_calendar.extensions.DataFrameAccessor.plot_raw_and_predicted_by_row","title":"<code>plot_raw_and_predicted_by_row(*, model, index_func=lambda idx: idx)</code>","text":"<p>Plot raw and predicted values for a model. Data must have been transformed to wide format first.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>LatentCalendar</code> <p>model to use for prediction</p> required <code>index_func</code> <p>function to generate title for each row</p> <code>lambda idx: idx</code> <p>Returns:</p> Type Description <code>np.ndarray</code> <p>grid of axes</p> Source code in <code>latent_calendar/extensions.py</code> <pre><code>def plot_raw_and_predicted_by_row(\nself, *, model: LatentCalendar, index_func=lambda idx: idx\n) -&gt; np.ndarray:\n\"\"\"Plot raw and predicted values for a model. Data must have been transformed to wide format first.\n    Args:\n        model: model to use for prediction\n        index_func: function to generate title for each row\n    Returns:\n        grid of axes\n    \"\"\"\nreturn plot_profile_by_row(\nself._obj, model=model, index_func=index_func, include_components=False\n)\n</code></pre>"},{"location":"modules/extensions/#latent_calendar.extensions.DataFrameAccessor.predict","title":"<code>predict(*, model)</code>","text":"<p>Predict DataFrame with model.</p> Source code in <code>latent_calendar/extensions.py</code> <pre><code>def predict(self, *, model) -&gt; pd.DataFrame:\n\"\"\"Predict DataFrame with model.\"\"\"\nreturn predict_on_dataframe(self._obj, model=model)\n</code></pre>"},{"location":"modules/extensions/#latent_calendar.extensions.DataFrameAccessor.sum_next_hours","title":"<code>sum_next_hours(hours)</code>","text":"<p>Sum the wide format over next hours.</p> Source code in <code>latent_calendar/extensions.py</code> <pre><code>def sum_next_hours(self, hours: int) -&gt; pd.DataFrame:\n\"\"\"Sum the wide format over next hours.\"\"\"\nreturn sum_next_hours(self._obj, hours=hours)\n</code></pre>"},{"location":"modules/extensions/#latent_calendar.extensions.DataFrameAccessor.sum_over_segments","title":"<code>sum_over_segments(df_segments)</code>","text":"<p>Sum the wide format over user defined segments.</p> Source code in <code>latent_calendar/extensions.py</code> <pre><code>def sum_over_segments(self, df_segments: pd.DataFrame) -&gt; pd.DataFrame:\n\"\"\"Sum the wide format over user defined segments.\"\"\"\nreturn sum_over_segments(self._obj, df_segments=df_segments)\n</code></pre>"},{"location":"modules/extensions/#latent_calendar.extensions.DataFrameAccessor.sum_over_vocab","title":"<code>sum_over_vocab(aggregation='dow')</code>","text":"<p>Sum the wide format to day of week or hour of day.</p> Source code in <code>latent_calendar/extensions.py</code> <pre><code>def sum_over_vocab(self, aggregation: str = \"dow\") -&gt; pd.DataFrame:\n\"\"\"Sum the wide format to day of week or hour of day.\"\"\"\nreturn sum_over_vocab(self._obj, aggregation=aggregation)\n</code></pre>"},{"location":"modules/extensions/#latent_calendar.extensions.DataFrameAccessor.transform","title":"<code>transform(*, model)</code>","text":"<p>Transform DataFrame with model.</p> Source code in <code>latent_calendar/extensions.py</code> <pre><code>def transform(self, *, model) -&gt; pd.DataFrame:\n\"\"\"Transform DataFrame with model.\"\"\"\nreturn transform_on_dataframe(self._obj, model=model)\n</code></pre>"},{"location":"modules/extensions/#latent_calendar.extensions.SeriesAccessor","title":"<code>SeriesAccessor</code>","text":"<p>Series accessor for latent_calendar accessed through <code>cal</code> attribute of Series.</p> Source code in <code>latent_calendar/extensions.py</code> <pre><code>@pd.api.extensions.register_series_accessor(\"cal\")\nclass SeriesAccessor:\n\"\"\"Series accessor for latent_calendar accessed through `cal` attribute of Series.\"\"\"\ndef __init__(self, pandas_obj: pd.Series):\nself._obj = pandas_obj\ndef plot(\nself,\n*,\nlength: int = 5,\nalpha: float = None,\ncmap=None,\nmonday_start: bool = True,\nax: Optional[plt.Axes] = None,\n) -&gt; plt.Axes:\n\"\"\"Plot Series of timestamps as a calendar.\n        Args:\n            length: length of event in minutes\n            alpha: alpha value for the color\n            cmap: function that maps floats to string colors\n            monday_start: whether to start the week on Monday or Sunday\n            ax: matplotlib axis to plot on\n        Returns:\n            Modified matplotlib axis\n        \"\"\"\ntmp_name = \"tmp_name\"\nconfig = StartEndConfig(start=tmp_name, end=None, minutes=length)\nreturn plot_dataframe_as_calendar(\nself._obj.rename(tmp_name).to_frame(),\nconfig=config,\nalpha=alpha,\ncmap=cmap,\nmonday_start=monday_start,\nax=ax,\n)\n</code></pre>"},{"location":"modules/extensions/#latent_calendar.extensions.SeriesAccessor.plot","title":"<code>plot(*, length=5, alpha=None, cmap=None, monday_start=True, ax=None)</code>","text":"<p>Plot Series of timestamps as a calendar.</p> <p>Parameters:</p> Name Type Description Default <code>length</code> <code>int</code> <p>length of event in minutes</p> <code>5</code> <code>alpha</code> <code>float</code> <p>alpha value for the color</p> <code>None</code> <code>cmap</code> <p>function that maps floats to string colors</p> <code>None</code> <code>monday_start</code> <code>bool</code> <p>whether to start the week on Monday or Sunday</p> <code>True</code> <code>ax</code> <code>Optional[plt.Axes]</code> <p>matplotlib axis to plot on</p> <code>None</code> <p>Returns:</p> Type Description <code>plt.Axes</code> <p>Modified matplotlib axis</p> Source code in <code>latent_calendar/extensions.py</code> <pre><code>def plot(\nself,\n*,\nlength: int = 5,\nalpha: float = None,\ncmap=None,\nmonday_start: bool = True,\nax: Optional[plt.Axes] = None,\n) -&gt; plt.Axes:\n\"\"\"Plot Series of timestamps as a calendar.\n    Args:\n        length: length of event in minutes\n        alpha: alpha value for the color\n        cmap: function that maps floats to string colors\n        monday_start: whether to start the week on Monday or Sunday\n        ax: matplotlib axis to plot on\n    Returns:\n        Modified matplotlib axis\n    \"\"\"\ntmp_name = \"tmp_name\"\nconfig = StartEndConfig(start=tmp_name, end=None, minutes=length)\nreturn plot_dataframe_as_calendar(\nself._obj.rename(tmp_name).to_frame(),\nconfig=config,\nalpha=alpha,\ncmap=cmap,\nmonday_start=monday_start,\nax=ax,\n)\n</code></pre>"},{"location":"modules/model/","title":"Model","text":"<p>Model to learn latent calendar meanings.</p> <p>Based on scikit-learn LDA.</p>"},{"location":"modules/model/#latent_calendar.model.latent_calendar.ConjugateModel","title":"<code>ConjugateModel</code>","text":"<p>             Bases: <code>BaseEstimator</code>, <code>TransformerMixin</code></p> Source code in <code>latent_calendar/model/latent_calendar.py</code> <pre><code>class ConjugateModel(BaseEstimator, TransformerMixin):\ndef __init__(self, a: Optional[np.ndarray] = None) -&gt; None:\nself.a = a\ndef fit(self, X, y=None) -&gt; \"ConjugateModel\":\n\"\"\"Fit the conjugate model.\"\"\"\nif self.a is None:\nself.a = hourly_prior(X)\nself.prior = Dirichlet(alpha=self.a)\nreturn self\ndef transform(self, X, y=None) -&gt; np.ndarray:\nreturn multinomial_dirichlet(X, self.prior).dist.mean()\ndef predict(self, X, y=None) -&gt; np.ndarray:\nreturn self.transform(X, y=y)\n</code></pre>"},{"location":"modules/model/#latent_calendar.model.latent_calendar.ConjugateModel.fit","title":"<code>fit(X, y=None)</code>","text":"<p>Fit the conjugate model.</p> Source code in <code>latent_calendar/model/latent_calendar.py</code> <pre><code>def fit(self, X, y=None) -&gt; \"ConjugateModel\":\n\"\"\"Fit the conjugate model.\"\"\"\nif self.a is None:\nself.a = hourly_prior(X)\nself.prior = Dirichlet(alpha=self.a)\nreturn self\n</code></pre>"},{"location":"modules/model/#latent_calendar.model.latent_calendar.DummyModel","title":"<code>DummyModel</code>","text":"<p>             Bases: <code>LatentCalendar</code></p> <p>Return even probability of a latent.</p> <p>This can be used as the worse possible baseline.</p> Source code in <code>latent_calendar/model/latent_calendar.py</code> <pre><code>class DummyModel(LatentCalendar):\n\"\"\"Return even probability of a latent.\n    This can be used as the worse possible baseline.\n    \"\"\"\ndef fit(self, X, y=None) -&gt; \"DummyModel\":\n\"\"\"All components are equal probabilty of every hour.\"\"\"\n# Even probabilty for every thing\nself.n_components = 1\nself.components_ = np.ones((self.n_components, TIME_SLOTS)) * EVEN_PROBABILITY\nreturn self\ndef transform(self, X, y=None) -&gt; np.ndarray:\n\"\"\"Everyone has equal probability of being in each group.\"\"\"\nnrows = len(X)\nreturn np.ones((nrows, self.n_components)) / self.n_components\n@classmethod\ndef create(cls) -&gt; \"DummyModel\":\n\"\"\"Return a dummy model ready for transforming and predicting.\"\"\"\nmodel = cls()\nmodel.fit(X=None)\nreturn model\n@classmethod\ndef from_prior(cls, prior: np.ndarray) -&gt; \"DummyModel\":\n\"\"\"Return a dummy model from a prior.\"\"\"\nmodel = cls()\nmodel.components_ = prior[np.newaxis, :]\nmodel.n_components = 1\nreturn model\n</code></pre>"},{"location":"modules/model/#latent_calendar.model.latent_calendar.DummyModel.create","title":"<code>create()</code>  <code>classmethod</code>","text":"<p>Return a dummy model ready for transforming and predicting.</p> Source code in <code>latent_calendar/model/latent_calendar.py</code> <pre><code>@classmethod\ndef create(cls) -&gt; \"DummyModel\":\n\"\"\"Return a dummy model ready for transforming and predicting.\"\"\"\nmodel = cls()\nmodel.fit(X=None)\nreturn model\n</code></pre>"},{"location":"modules/model/#latent_calendar.model.latent_calendar.DummyModel.fit","title":"<code>fit(X, y=None)</code>","text":"<p>All components are equal probabilty of every hour.</p> Source code in <code>latent_calendar/model/latent_calendar.py</code> <pre><code>def fit(self, X, y=None) -&gt; \"DummyModel\":\n\"\"\"All components are equal probabilty of every hour.\"\"\"\n# Even probabilty for every thing\nself.n_components = 1\nself.components_ = np.ones((self.n_components, TIME_SLOTS)) * EVEN_PROBABILITY\nreturn self\n</code></pre>"},{"location":"modules/model/#latent_calendar.model.latent_calendar.DummyModel.from_prior","title":"<code>from_prior(prior)</code>  <code>classmethod</code>","text":"<p>Return a dummy model from a prior.</p> Source code in <code>latent_calendar/model/latent_calendar.py</code> <pre><code>@classmethod\ndef from_prior(cls, prior: np.ndarray) -&gt; \"DummyModel\":\n\"\"\"Return a dummy model from a prior.\"\"\"\nmodel = cls()\nmodel.components_ = prior[np.newaxis, :]\nmodel.n_components = 1\nreturn model\n</code></pre>"},{"location":"modules/model/#latent_calendar.model.latent_calendar.DummyModel.transform","title":"<code>transform(X, y=None)</code>","text":"<p>Everyone has equal probability of being in each group.</p> Source code in <code>latent_calendar/model/latent_calendar.py</code> <pre><code>def transform(self, X, y=None) -&gt; np.ndarray:\n\"\"\"Everyone has equal probability of being in each group.\"\"\"\nnrows = len(X)\nreturn np.ones((nrows, self.n_components)) / self.n_components\n</code></pre>"},{"location":"modules/model/#latent_calendar.model.latent_calendar.LatentCalendar","title":"<code>LatentCalendar</code>","text":"<p>             Bases: <code>BaseLDA</code></p> <p>Main latent calendar model.</p> <p>Make use of Latent Dirichlet Allocation model from sklearn</p> Source code in <code>latent_calendar/model/latent_calendar.py</code> <pre><code>class LatentCalendar(BaseLDA):\n\"\"\"Main latent calendar model.\n    Make use of Latent Dirichlet Allocation model from sklearn\n    \"\"\"\n@property\ndef normalized_components_(self) -&gt; np.ndarray:\nreturn self.components_ / self.components_.sum(axis=1)[:, np.newaxis]\ndef joint_distribution(self, X_latent: np.ndarray) -&gt; np.ndarray:\n\"\"\"Marginalize out the components.\"\"\"\nreturn joint_distribution(\nX_latent=X_latent, components=self.normalized_components_\n)\ndef predict(self, X: np.ndarray, y=None) -&gt; np.ndarray:\n\"\"\"Return the marginal probabilities for a given row.\n        Marginalize out the loads via law of total probability\n        P[time=t | Row=r] = sum P[time=t | L=l, Row=r] * P[L=l | Row=r]\n        \"\"\"\n# (n, n_components)\nX_latent = self.transform(X)\nreturn self.joint_distribution(X_latent=X_latent)\n</code></pre>"},{"location":"modules/model/#latent_calendar.model.latent_calendar.LatentCalendar.joint_distribution","title":"<code>joint_distribution(X_latent)</code>","text":"<p>Marginalize out the components.</p> Source code in <code>latent_calendar/model/latent_calendar.py</code> <pre><code>def joint_distribution(self, X_latent: np.ndarray) -&gt; np.ndarray:\n\"\"\"Marginalize out the components.\"\"\"\nreturn joint_distribution(\nX_latent=X_latent, components=self.normalized_components_\n)\n</code></pre>"},{"location":"modules/model/#latent_calendar.model.latent_calendar.LatentCalendar.predict","title":"<code>predict(X, y=None)</code>","text":"<p>Return the marginal probabilities for a given row.</p> <p>Marginalize out the loads via law of total probability P[time=t | Row=r] = sum P[time=t | L=l, Row=r] * P[L=l | Row=r]</p> Source code in <code>latent_calendar/model/latent_calendar.py</code> <pre><code>def predict(self, X: np.ndarray, y=None) -&gt; np.ndarray:\n\"\"\"Return the marginal probabilities for a given row.\n    Marginalize out the loads via law of total probability\n    P[time=t | Row=r] = sum P[time=t | L=l, Row=r] * P[L=l | Row=r]\n    \"\"\"\n# (n, n_components)\nX_latent = self.transform(X)\nreturn self.joint_distribution(X_latent=X_latent)\n</code></pre>"},{"location":"modules/model/#latent_calendar.model.latent_calendar.MarginalModel","title":"<code>MarginalModel</code>","text":"<p>             Bases: <code>LatentCalendar</code></p> Source code in <code>latent_calendar/model/latent_calendar.py</code> <pre><code>class MarginalModel(LatentCalendar):\ndef fit(self, X, y=None) -&gt; \"MarginalModel\":\n\"\"\"Just sum over all the rows.\"\"\"\nself.n_components = 1\n# (1, n_times)\nself.components_ = X.sum(axis=0)[np.newaxis, :]\nreturn self\ndef transform(self, X, y=None) -&gt; np.ndarray:\n\"\"\"There is only one component to be a part of.\"\"\"\nnrows = len(X)\n# (nrows, 1)\nreturn np.repeat(1, nrows)[:, np.newaxis]\n</code></pre>"},{"location":"modules/model/#latent_calendar.model.latent_calendar.MarginalModel.fit","title":"<code>fit(X, y=None)</code>","text":"<p>Just sum over all the rows.</p> Source code in <code>latent_calendar/model/latent_calendar.py</code> <pre><code>def fit(self, X, y=None) -&gt; \"MarginalModel\":\n\"\"\"Just sum over all the rows.\"\"\"\nself.n_components = 1\n# (1, n_times)\nself.components_ = X.sum(axis=0)[np.newaxis, :]\nreturn self\n</code></pre>"},{"location":"modules/model/#latent_calendar.model.latent_calendar.MarginalModel.transform","title":"<code>transform(X, y=None)</code>","text":"<p>There is only one component to be a part of.</p> Source code in <code>latent_calendar/model/latent_calendar.py</code> <pre><code>def transform(self, X, y=None) -&gt; np.ndarray:\n\"\"\"There is only one component to be a part of.\"\"\"\nnrows = len(X)\n# (nrows, 1)\nreturn np.repeat(1, nrows)[:, np.newaxis]\n</code></pre>"},{"location":"modules/model/#latent_calendar.model.latent_calendar.constant_prior","title":"<code>constant_prior(X, value=1.0)</code>","text":"<p>Return the prior for each hour of the day.</p> <p>This is the average of all the rows.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>np.ndarray</code> <p>(nrows, n_times)</p> required Source code in <code>latent_calendar/model/latent_calendar.py</code> <pre><code>def constant_prior(X: np.ndarray, value: float = 1.0) -&gt; np.ndarray:\n\"\"\"Return the prior for each hour of the day.\n    This is the average of all the rows.\n    Args:\n        X: (nrows, n_times)\n    \"\"\"\nreturn np.repeat(value, TIME_SLOTS)\n</code></pre>"},{"location":"modules/model/#latent_calendar.model.latent_calendar.hourly_prior","title":"<code>hourly_prior(X)</code>","text":"<p>Return the prior for each hour of the day.</p> <p>This is the average of all the rows.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>np.ndarray</code> <p>(nrows, n_times)</p> required <p>Returns:</p> Type Description <code>np.ndarray</code> <p>(n_times,)</p> Source code in <code>latent_calendar/model/latent_calendar.py</code> <pre><code>def hourly_prior(X: np.ndarray) -&gt; np.ndarray:\n\"\"\"Return the prior for each hour of the day.\n    This is the average of all the rows.\n    Args:\n        X: (nrows, n_times)\n    Returns:\n        (n_times,)\n    \"\"\"\nreturn (X &gt; 0).sum(axis=0) / len(X)\n</code></pre>"},{"location":"modules/model/#latent_calendar.model.latent_calendar.joint_distribution","title":"<code>joint_distribution(X_latent, components)</code>","text":"<p>Marginalize out the components.</p> Source code in <code>latent_calendar/model/latent_calendar.py</code> <pre><code>def joint_distribution(X_latent: np.ndarray, components: np.ndarray) -&gt; np.ndarray:\n\"\"\"Marginalize out the components.\"\"\"\nreturn X_latent @ components\n</code></pre>"},{"location":"modules/plot/","title":"Plot","text":"<p>Plotting functions for latent calendar. </p> <p>These functions and classes build every calendar plot.</p> <p>Plots including a model.</p> <p>Handling the colors in the calendar plots.</p> <p>This module provides some helper function and some defaults. However, they might  not be the best of all purposes.</p> <p>TODO: Get a better pallet overall :D TODO: Be able to distinguish between counts, probability, and relative numbers</p> <p>Configuration file for plotting.</p> <p>The specific elements on the calendar plot. </p> <p>Includes x-axis, y-axis, and their settings, as well as the calendar events.</p> <p>Generalize the iteration to support different data formats.</p> <p>Currently supports iteration of a matrix grid (n, m), a long array (n * m, ), and DataFrame instances.</p>"},{"location":"modules/plot/#latent_calendar.plot.core.calendar.plot_calendar","title":"<code>plot_calendar(calendar_iter, *, plot_axes=None, display_settings=None, cmap=None, alpha=None, ax=None, grid_lines=GridLines(), monday_start=True)</code>","text":"<p>Plot a calendar from generator of values.</p> <p>This can plot both numpy matrix and DataFrame values as long as the iterable fits CALENDAR_ITERATION definition</p> <p>Parameters:</p> Name Type Description Default <code>calendar_iter</code> <code>CALENDAR_ITERATION</code> <p>CALENDAR_ITERATION</p> required <code>plot_axes</code> <code>Optional[PlotAxes]</code> <p>instance in order to configure the axes</p> <code>None</code> <code>display_settings</code> <code>Optional[DisplaySettings]</code> <p>override of the display settings in the calendar</p> <code>None</code> <code>cmap</code> <code>Optional[CMAP]</code> <p>function that maps floats to string colors</p> <code>None</code> <code>ax</code> <code>Optional[plt.Axes]</code> <p>Optional axes to plot on</p> <code>None</code> <code>grid_lines</code> <code>GridLines</code> <p>GridLines instance</p> <code>GridLines()</code> <code>monday_start</code> <code>bool</code> <p>whether to start the week on Monday or Sunday</p> <code>True</code> <p>Returns:</p> Type Description <code>plt.Axes</code> <p>Modified matplotlib axis</p> Source code in <code>latent_calendar/plot/core/calendar.py</code> <pre><code>def plot_calendar(\ncalendar_iter: CALENDAR_ITERATION,\n*,\nplot_axes: Optional[PlotAxes] = None,\ndisplay_settings: Optional[DisplaySettings] = None,\ncmap: Optional[CMAP] = None,\nalpha: Optional[float] = None,\nax: Optional[plt.Axes] = None,\ngrid_lines: GridLines = GridLines(),\nmonday_start: bool = True,\n) -&gt; plt.Axes:\n\"\"\"Plot a calendar from generator of values.\n    This can plot both numpy matrix and DataFrame values as long as the iterable fits CALENDAR_ITERATION definition\n    Args:\n        calendar_iter: CALENDAR_ITERATION\n        plot_axes: instance in order to configure the axes\n        display_settings: override of the display settings in the calendar\n        cmap: function that maps floats to string colors\n        ax: Optional axes to plot on\n        grid_lines: GridLines instance\n        monday_start: whether to start the week on Monday or Sunday\n    Returns:\n        Modified matplotlib axis\n    \"\"\"\nif plot_axes is None:\nplot_axes = PlotAxes()\nplot_axes.update_start(monday_start=monday_start)\nif display_settings is not None:\nplot_axes.update_display_settings(display_settings=display_settings)\ncmap = cmap if cmap is not None else lambda x: \"lightblue\"\nax = ax if ax is not None else plt.gca()\nfor calendar_data in calendar_iter:\nevent = CalendarEvent.from_calendar_data(\ncalendar_data=calendar_data, cmap=cmap, alpha=alpha\n)\nevent.plot_event(ax=ax, monday_start=monday_start)\nplot_axes.configure_axis(ax=ax)\ngrid_lines.configure_grid(ax=ax)\nreturn ax\n</code></pre>"},{"location":"modules/plot/#latent_calendar.plot.core.calendar.plot_calendar_by_row","title":"<code>plot_calendar_by_row(df, max_cols=3, title_func=None, day_labeler=None, time_labeler=None, cmaps=None, monday_start=True)</code>","text":"<p>Iterate a DataFrame by row and plot calendar events.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>pd.DataFrame</code> <p>wide DataFrame where each column is the vocabulary</p> required <code>max_cols</code> <code>int</code> <p>max number of columns in the created grid.</p> <code>3</code> <code>title_func</code> <code>Optional[TITLE_FUNC]</code> <p>function to make the title from DataFrame index and DataFrame row, default like '2020-01-01 n_trip(s) = 10'</p> <code>None</code> <code>day_labeler</code> <code>Optional[DayLabeler]</code> <p>base day_labeler</p> <code>None</code> <code>time_labeler</code> <code>Optional[TimeLabeler]</code> <p>base day_labeler</p> <code>None</code> <code>cmaps</code> <code>Optional[Union[CMAP, ColorMap, CMAP_GENERATOR]]</code> <p>Colormapping function(s) to use for each row</p> <code>None</code> <code>monday_start</code> <code>bool</code> <p>whether to start the week on Monday or Sunday</p> <code>True</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>latent_calendar/plot/core/calendar.py</code> <pre><code>def plot_calendar_by_row(\ndf: pd.DataFrame,\nmax_cols: int = 3,\ntitle_func: Optional[TITLE_FUNC] = None,\nday_labeler: Optional[DayLabeler] = None,\ntime_labeler: Optional[TimeLabeler] = None,\ncmaps: Optional[Union[CMAP, ColorMap, CMAP_GENERATOR]] = None,\nmonday_start: bool = True,\n) -&gt; None:\n\"\"\"Iterate a DataFrame by row and plot calendar events.\n    Args:\n        df: wide DataFrame where each column is the vocabulary\n        max_cols: max number of columns in the created grid.\n        title_func: function to make the title from DataFrame index and DataFrame row, default like '2020-01-01 n_trip(s) = 10'\n        day_labeler: base day_labeler\n        time_labeler: base day_labeler\n        cmaps: Colormapping function(s) to use for each row\n        monday_start: whether to start the week on Monday or Sunday\n    Returns:\n        None\n    \"\"\"\nn_cols = len(df.columns)\nif n_cols % 7 != 0:\nraise CalendarFormatError(\nf\"Number of columns must be a multiple of 7, got {n_cols} columns. Make sure DataFrame is in wide calendar format.\"\n)\ntitle_func = title_func if title_func is not None else default_title_func\nif isinstance(cmaps, ColorMap):\ncmaps = repeat(cmaps)\nif cmaps is None:\ncmaps = repeat(create_default_cmap(value=df.to_numpy().max()))\ntotal = len(df)\nfor (ax, plot_axes), (idx, row), cmap in zip(\ndefault_axes_and_grid_axes(\ntotal=total,\nmax_cols=max_cols,\nday_labeler=day_labeler,\ntime_labeler=time_labeler,\n),\ndf.iterrows(),\ncmaps,\n):\ncalendar_data = row.to_numpy()\nplot_calendar(\niterate_long_array(calendar_data),\nplot_axes=plot_axes,\nax=ax,\ncmap=cmap,\nmonday_start=monday_start,\n)\ntitle = title_func(idx, row)\nax.set_title(title)\n</code></pre>"},{"location":"modules/plot/#latent_calendar.plot.core.calendar.plot_dataframe_as_calendar","title":"<code>plot_dataframe_as_calendar(df, config, *, grid_lines=GridLines(), plot_axes=None, cmap=None, alpha=None, ax=None, monday_start=True)</code>","text":"<p>Simple Wrapper about plot_calendar in order to plot DataFrame in various formats</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>pd.DataFrame</code> <p>DataFrame in format with columns in config instance</p> required <code>config</code> <code>DataFrameConfig</code> <p>DataFrameConfig</p> required <code>grid_lines</code> <code>GridLines</code> <p>GridLines instance</p> <code>GridLines()</code> <code>plot_axes</code> <code>Optional[PlotAxes]</code> <p>instance in order to configure the axes</p> <code>None</code> <code>cmap</code> <code>Optional[CMAP]</code> <p>function that maps floats to string colors</p> <code>None</code> <code>alpha</code> <code>Optional[float]</code> <p>alpha level of each rectangle</p> <code>None</code> <code>ax</code> <code>Optional[plt.Axes]</code> <p>optional axis to plot on</p> <code>None</code> <code>monday_start</code> <code>bool</code> <p>whether to start the week on Monday or Sunday</p> <code>True</code> <p>Returns:</p> Type Description <code>plt.Axes</code> <p>new or modified axes</p> Source code in <code>latent_calendar/plot/core/calendar.py</code> <pre><code>def plot_dataframe_as_calendar(\ndf: pd.DataFrame,\nconfig: DataFrameConfig,\n*,\ngrid_lines: GridLines = GridLines(),\nplot_axes: Optional[PlotAxes] = None,\ncmap: Optional[CMAP] = None,\nalpha: Optional[float] = None,\nax: Optional[plt.Axes] = None,\nmonday_start: bool = True,\n) -&gt; plt.Axes:\n\"\"\"Simple Wrapper about plot_calendar in order to plot DataFrame in various formats\n    Args:\n        df: DataFrame in format with columns in config instance\n        config: DataFrameConfig\n        grid_lines: GridLines instance\n        plot_axes: instance in order to configure the axes\n        cmap: function that maps floats to string colors\n        alpha: alpha level of each rectangle\n        ax: optional axis to plot on\n        monday_start: whether to start the week on Monday or Sunday\n    Returns:\n        new or modified axes\n    \"\"\"\nreturn plot_calendar(\niterate_dataframe(df, config),\nplot_axes=plot_axes,\ncmap=cmap,\nalpha=alpha,\nax=ax,\nmonday_start=monday_start,\ngrid_lines=grid_lines,\n)\n</code></pre>"},{"location":"modules/plot/#latent_calendar.plot.core.calendar.plot_dataframe_grid_across_column","title":"<code>plot_dataframe_grid_across_column(df, grid_col, config=None, max_cols=3, *, alpha=None, monday_start=True)</code>","text":"<p>Plot the long DataFrame in a grid by some different column.</p> <p>Continuous version of the plot_calendar_by_row</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>pd.DataFrame</code> <p>DataFrame to plot. Requires all the columns in config</p> required <code>grid_col</code> <code>str</code> <p>column name of DataFrame to plot across</p> required <code>config</code> <code>Optional[DataFrameConfig]</code> <p>DataFrameConfig instance of the column mapping. Default IterConfig</p> <code>None</code> <code>max_cols</code> <code>int</code> <p>max number of columns in the grid</p> <code>3</code> <code>alpha</code> <code>Optional[float]</code> <p>alpha of each calendar event</p> <code>None</code> <code>monday_start</code> <code>bool</code> <p>whether to start the week on Monday or Sunday</p> <code>True</code> Source code in <code>latent_calendar/plot/core/calendar.py</code> <pre><code>def plot_dataframe_grid_across_column(\ndf: pd.DataFrame,\ngrid_col: str,\nconfig: Optional[DataFrameConfig] = None,\nmax_cols: int = 3,\n*,\nalpha: Optional[float] = None,\nmonday_start: bool = True,\n) -&gt; None:\n\"\"\"Plot the long DataFrame in a grid by some different column.\n    Continuous version of the plot_calendar_by_row\n    Args:\n        df: DataFrame to plot. Requires all the columns in config\n        grid_col: column name of DataFrame to plot across\n        config: DataFrameConfig instance of the column mapping. Default IterConfig\n        max_cols: max number of columns in the grid\n        alpha: alpha of each calendar event\n        monday_start: whether to start the week on Monday or Sunday\n    \"\"\"\nif grid_col not in df.columns:\nmsg = f\"{grid_col} is not in the DataFrame.\"\nraise KeyError(msg)\nvalues = df.loc[:, grid_col].dropna().unique()\nvalues.sort()\ntotal = len(values)\nfor (ax, plot_axes), value in zip(\ndefault_axes_and_grid_axes(total=total, max_cols=max_cols), values\n):\nidx = df[grid_col] == value\ndf_tmp = df.loc[idx, :]\nplot_dataframe_as_calendar(\ndf=df_tmp,\nconfig=config,\nax=ax,\nplot_axes=plot_axes,\nalpha=alpha,\nmonday_start=monday_start,\n)\nax.set_title(f\"{value}\")\n</code></pre>"},{"location":"modules/plot/#latent_calendar.plot.core.model.plot_component_distribution","title":"<code>plot_component_distribution(X_latent, model, ax)</code>","text":"<p>Third profile plot.</p> Source code in <code>latent_calendar/plot/core/model.py</code> <pre><code>def plot_component_distribution(\nX_latent: np.ndarray, model: LatentCalendar, ax: plt.Axes\n) -&gt; plt.Axes:\n\"\"\"Third profile plot.\"\"\"\nx = range(len(X_latent))\nax.bar(x, X_latent)\nstep = 1 if model.n_components &lt; 15 else 2\nax.set_xticks(np.arange(model.n_components, step=step))\nax.set_ylabel(\"P[L=l | Data]\")\nax.set_title(\"Latent Component Distribution\")\nreturn ax\n</code></pre>"},{"location":"modules/plot/#latent_calendar.plot.core.model.plot_distribution","title":"<code>plot_distribution(X_probs, ax, display_y_axis=True, divergent=True, plot_axes=PlotAxes())</code>","text":"<p>Second plot of the profile calendar probability distribution.</p> Source code in <code>latent_calendar/plot/core/model.py</code> <pre><code>def plot_distribution(\nX_probs: np.ndarray,\nax: plt.Axes,\ndisplay_y_axis: bool = True,\ndivergent: bool = True,\nplot_axes: PlotAxes = PlotAxes(),\n) -&gt; plt.Axes:\n\"\"\"Second plot of the profile calendar probability distribution.\"\"\"\nplot_axes.time_labeler.display = display_y_axis\ndata, cmap = settle_data_and_cmap(data=X_probs, divergent=divergent)\niter_data = iterate_long_array(data)\nsubtext = \"Comparison to random rate\" if divergent else \"Raw Probabilities\"\nplot_calendar(\niter_data,\nax=ax,\ncmap=cmap,\nplot_axes=plot_axes,\n)\ntitle = f\"Predicted Probability Distribution\\n{subtext}\"\nax.set_title(title)\nreturn ax\n</code></pre>"},{"location":"modules/plot/#latent_calendar.plot.core.model.plot_model_components","title":"<code>plot_model_components(model, max_cols=5, divergent=True, components=None)</code>","text":"<p>Helper function to create plot of all the components of the LatentCalendar instance.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>LatentCalendar</code> <p>LatentCalendar instance</p> required <code>max_cols</code> <code>int</code> <p>maximum number of columns in the grid of calendar components.</p> <code>5</code> <code>divergent</code> <code>bool</code> <p>what data to plot</p> <code>True</code> <code>components</code> <code>Optional[Iterable[int]]</code> <p>Specific subset of components to plot. Default is all</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>latent_calendar/plot/core/model.py</code> <pre><code>def plot_model_components(\nmodel: LatentCalendar,\nmax_cols: int = 5,\ndivergent: bool = True,\ncomponents: Optional[Iterable[int]] = None,\n) -&gt; None:\n\"\"\"Helper function to create plot of all the components of the LatentCalendar instance.\n    Args:\n        model: LatentCalendar instance\n        max_cols: maximum number of columns in the grid of calendar components.\n        divergent: what data to plot\n        components: Specific subset of components to plot. Default is all\n    Returns:\n        None\n    \"\"\"\nif components is None:\ncomponents = list(range(model.n_components))\nif any([component &gt; model.n_components - 1 for component in components]):\nmsg = f\"One of the listed components is greater than the total number {model.n_components}\"\nraise ValueError(msg)\ntotal = len(components)\nnormalized_components_to_plot = model.normalized_components_[components]\nget_title = lambda component_idx: f\"Component {component_idx}\"\nvalues = zip(\ncomponents,\ndefault_axes_and_grid_axes(total=total, max_cols=max_cols),\nnormalized_components_to_plot,\n)\nfor component_idx, (ax, plot_axes), latent in values:\ndata, cmap = settle_data_and_cmap(latent, divergent)\nplot_calendar(\niterate_long_array(data),\ncmap=cmap,\nax=ax,\nplot_axes=plot_axes,\n)\ntitle = get_title(component_idx=component_idx)\nax.set_title(title)\n</code></pre>"},{"location":"modules/plot/#latent_calendar.plot.core.model.plot_model_predictions","title":"<code>plot_model_predictions(X_to_predict, X_holdout, model, divergent=True, axes=None, plot_axes=PlotAxes())</code>","text":"<p>Plot the model predictions compared to the test data.</p> <p>Parameters:</p> Name Type Description Default <code>X_to_predict</code> <code>np.ndarray</code> <p>Training data for the model</p> required <code>X_test</code> <p>Testing data for the model</p> required <code>model</code> <code>LatentCalendar</code> <p>LatentCalendar model instance</p> required <code>divergent</code> <code>bool</code> <p>Option to change the data displayed</p> <code>True</code> <code>axes</code> <code>Iterable[plt.Axes]</code> <p>list of 3 axes to plot this data</p> <code>None</code> <p>Returns:</p> Type Description <code>Iterable[plt.Axes]</code> <p>The axes used for plotting</p> Source code in <code>latent_calendar/plot/core/model.py</code> <pre><code>def plot_model_predictions(\nX_to_predict: np.ndarray,\nX_holdout: np.ndarray,\nmodel: LatentCalendar,\ndivergent: bool = True,\naxes: Iterable[plt.Axes] = None,\nplot_axes: PlotAxes = PlotAxes(),\n) -&gt; Iterable[plt.Axes]:\n\"\"\"Plot the model predictions compared to the test data.\n    Args:\n        X_to_predict: Training data for the model\n        X_test: Testing data for the model\n        model: LatentCalendar model instance\n        divergent: Option to change the data displayed\n        axes: list of 3 axes to plot this data\n    Returns:\n        The axes used for plotting\n    \"\"\"\nX_to_predict = X_to_predict[np.newaxis, :]\nX_holdout = X_holdout[np.newaxis, :]\nif axes is None:\n_, axes = plt.subplots(nrows=1, ncols=3)\nX_to_predict_probs = model.predict(X_to_predict)[0]\nax = axes[0]\nplot_raw_data(array=X_to_predict, ax=ax, plot_axes=plot_axes)\nax.set_title(f\"Raw Data for Prediction\")\nax = axes[1]\nplot_distribution(\nX_probs=X_to_predict_probs,\nax=ax,\ndisplay_y_axis=False,\ndivergent=divergent,\nplot_axes=plot_axes,\n)\nax.set_title(\"Distribution from Prediction\")\nax = axes[2]\nplot_raw_data(array=X_holdout, ax=ax, display_y_axis=False, plot_axes=plot_axes)\nax.set_title(\"Raw Data in Future\")\nreturn axes\n</code></pre>"},{"location":"modules/plot/#latent_calendar.plot.core.model.plot_profile","title":"<code>plot_profile(array, model, divergent=True, axes=None, include_components=True, plot_axes=PlotAxes())</code>","text":"<p>Create a profile plot with 3 different plots.</p> <p>Displays the raw data, predicted probability distribution, and latent breakdown.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>np.ndarray</code> <p>long array (n_timeslots, )</p> required <code>model</code> <code>LatentCalendar</code> <p>LatentCalendar model instance</p> required <code>divergent</code> <code>bool</code> <p>Option to change the data displayed</p> <code>True</code> <code>axes</code> <code>Iterable[plt.Axes]</code> <p>list of 3 axes to plot this data</p> <code>None</code> <code>include_components</code> <code>bool</code> <p>If the last component plot should be included</p> <code>True</code> <code>plot_axes</code> <code>PlotAxes</code> <p>PlotAxes instance</p> <code>PlotAxes()</code> <p>Returns:</p> Type Description <code>np.ndarray</code> <p>None</p> Source code in <code>latent_calendar/plot/core/model.py</code> <pre><code>def plot_profile(\narray: np.ndarray,\nmodel: LatentCalendar,\ndivergent: bool = True,\naxes: Iterable[plt.Axes] = None,\ninclude_components: bool = True,\nplot_axes: PlotAxes = PlotAxes(),\n) -&gt; np.ndarray:\n\"\"\"Create a profile plot with 3 different plots.\n    Displays the raw data, predicted probability distribution, and latent breakdown.\n    Args:\n        array: long array (n_timeslots, )\n        model: LatentCalendar model instance\n        divergent: Option to change the data displayed\n        axes: list of 3 axes to plot this data\n        include_components: If the last component plot should be included\n        plot_axes: PlotAxes instance\n    Returns:\n        None\n    \"\"\"\nncols = 3 if include_components else 2\nif axes is None:\n_, axes = plt.subplots(nrows=1, ncols=ncols)\nif len(axes) != ncols:\nmsg = \"The axes do not equal the number of plots required.\"\nraise ValueError(msg)\n# Data under model\nX_new = array[np.newaxis, :]\nX_probs = model.predict(X_new)[0]\n# Raw Data\nax = axes[0]\nplot_raw_data(array=array, ax=ax, plot_axes=plot_axes)\n# Under Model\nax = axes[1]\nplot_distribution(\nX_probs=X_probs,\nax=ax,\ndisplay_y_axis=False,\ndivergent=divergent,\nplot_axes=plot_axes,\n)\n# Component distribution\nif include_components:\nax = axes[2]\nX_latent = model.transform(X_new)[0]\nplot_component_distribution(X_latent=X_latent, model=model, ax=ax)\nreturn axes\n</code></pre>"},{"location":"modules/plot/#latent_calendar.plot.core.model.plot_raw_data","title":"<code>plot_raw_data(array, ax, display_y_axis=True, plot_axes=PlotAxes())</code>","text":"<p>First plot of raw data.</p> Source code in <code>latent_calendar/plot/core/model.py</code> <pre><code>def plot_raw_data(\narray: np.ndarray,\nax: plt.Axes,\ndisplay_y_axis: bool = True,\nplot_axes: PlotAxes = PlotAxes(),\n) -&gt; plt.Axes:\n\"\"\"First plot of raw data.\"\"\"\ntry:\nmax_value = np.quantile(array[array &gt; 0], 0.95)\nexcept IndexError:\nmax_value = 1\nplot_axes.time_labeler.display = display_y_axis\ncmap = create_default_cmap(value=max_value)\nplot_calendar(\niterate_long_array(array),\nax=ax,\ncmap=cmap,\nplot_axes=plot_axes,\n)\nax.set_title(f\"Raw Data\")\nreturn ax\n</code></pre>"},{"location":"modules/plot/#latent_calendar.plot.colors.ColorMap","title":"<code>ColorMap</code>","text":"<p>             Bases: <code>ScalarMappable</code></p> <p>This supports colorbar for a figure from matplotlib.</p> <p>TODO: Add into the selective plots TODO: Consider having the label or even a binning of the colorbar</p> Source code in <code>latent_calendar/plot/colors.py</code> <pre><code>class ColorMap(ScalarMappable):\n\"\"\"This supports colorbar for a figure from matplotlib.\n    TODO: Add into the selective plots\n    TODO: Consider having the label or even a binning of the colorbar\n    \"\"\"\ndef __init__(self, norm, cmap, default_cm: CM) -&gt; None:\ncmap = cmap if cmap is not None else default_cm\nsuper().__init__(norm=norm, cmap=cmap)\ndef __call__(self, x: float) -&gt; str:\nreturn rgb2hex(self.cmap(self.norm(x)))\ndef add_colorbar(self, ax=None) -&gt; None:\n\"\"\"Add the colorbar to axis or axes.\n        Args:\n            ax: single or np.ndarray of Axes\n        \"\"\"\nfig = plt.gcf()\nfig.colorbar(self, ax=ax, ticks=self.norm.ticks)\n</code></pre>"},{"location":"modules/plot/#latent_calendar.plot.colors.ColorMap.add_colorbar","title":"<code>add_colorbar(ax=None)</code>","text":"<p>Add the colorbar to axis or axes.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <p>single or np.ndarray of Axes</p> <code>None</code> Source code in <code>latent_calendar/plot/colors.py</code> <pre><code>def add_colorbar(self, ax=None) -&gt; None:\n\"\"\"Add the colorbar to axis or axes.\n    Args:\n        ax: single or np.ndarray of Axes\n    \"\"\"\nfig = plt.gcf()\nfig.colorbar(self, ax=ax, ticks=self.norm.ticks)\n</code></pre>"},{"location":"modules/plot/#latent_calendar.plot.colors.create_cmap","title":"<code>create_cmap(max_value, min_value=0.0, cm=None)</code>","text":"<p>Create color map function</p> <p>Might be good for values from low to high.</p> Source code in <code>latent_calendar/plot/colors.py</code> <pre><code>def create_cmap(\nmax_value: float, min_value: float = 0.0, cm: Optional[CM] = None\n) -&gt; CMAP:\n\"\"\"Create color map function\n    Might be good for values from low to high.\n    \"\"\"\nnorm = Normalize(vmin=min_value, vmax=max_value)\nnorm.ticks = [norm.vmin, norm.vmax]\nreturn ColorMap(norm=norm, cmap=cm, default_cm=plt.cm.YlGn)\n</code></pre>"},{"location":"modules/plot/#latent_calendar.plot.colors.create_diverge_cmap","title":"<code>create_diverge_cmap(center_value, range, cm=None)</code>","text":"<p>Create color map function to emphasize a center value and deviation from that center.</p> <p>Might be good for values that are relative to some baseline</p> Source code in <code>latent_calendar/plot/colors.py</code> <pre><code>def create_diverge_cmap(\ncenter_value: float, range: float, cm: Optional[CM] = None\n) -&gt; CMAP:\n\"\"\"Create color map function to emphasize a center value and deviation from that center.\n    Might be good for values that are relative to some baseline\n    \"\"\"\nhalf_range = range / 2\nnorm = Normalize(vmin=center_value - half_range, vmax=center_value + half_range)\nnorm.ticks = [norm.vmin, 0, norm.vmax]\nreturn ColorMap(norm=norm, cmap=cm, default_cm=plt.cm.coolwarm)\n</code></pre>"},{"location":"modules/plot/#latent_calendar.plot.colors.create_relative_cmap","title":"<code>create_relative_cmap(range)</code>","text":"<p>Good for relative scales.</p> Source code in <code>latent_calendar/plot/colors.py</code> <pre><code>def create_relative_cmap(range: float) -&gt; CMAP:\n\"\"\"Good for relative scales.\"\"\"\nreturn create_diverge_cmap(center_value=1.0, range=range)\n</code></pre>"},{"location":"modules/plot/#latent_calendar.plot.colors.settle_data_and_cmap","title":"<code>settle_data_and_cmap(data, divergent)</code>","text":"<p>Return a tuple of transformed data and cmap for displaying that data.</p> Source code in <code>latent_calendar/plot/colors.py</code> <pre><code>def settle_data_and_cmap(data, divergent: bool) -&gt; Tuple[np.ndarray, CMAP]:\n\"\"\"Return a tuple of transformed data and cmap for displaying that data.\"\"\"\nif divergent:\n# Comparing the values to random rate\ndata = data / EVEN_PROBABILITY\nreturn data, create_default_divergent_cmap()\nreturn data, create_default_cmap(value=data.max())\n</code></pre>"},{"location":"modules/plot/#latent_calendar.plot.config.Config","title":"<code>Config</code>  <code>dataclass</code>","text":"<p>Default configuration used in some of the plots.</p> <p>Parameters:</p> Name Type Description Default <code>divergent</code> <code>bool</code> <p>whether to show divergent calendar by default.</p> <code>True</code> <code>range</code> <code>float</code> <p>Where to a divergent plot</p> <code>3.0</code> <code>max_value_ratio</code> <code>float</code> <p>Where to clip the default cmap in the calendar view</p> <code>0.75</code> Source code in <code>latent_calendar/plot/config.py</code> <pre><code>@dataclass\nclass Config:\n\"\"\"Default configuration used in some of the plots.\n    Args:\n        divergent: whether to show divergent calendar by default.\n        range: Where to a divergent plot\n        max_value_ratio: Where to clip the default cmap in the calendar view\n    \"\"\"\ndivergent: bool = True\nrange: float = 3.0\nmax_value_ratio: float = 0.75\n</code></pre>"},{"location":"modules/plot/#latent_calendar.plot.elements.CalendarEvent","title":"<code>CalendarEvent</code>  <code>dataclass</code>","text":"<p>Something on the calendar.</p> <p>Plots rectangles on axis</p> <p>Examples:</p> <p>Plot event from calendar data</p> <pre><code>&gt;&gt;&gt; calendar_data = CalendarData(day=0, start=0, end=2.5)\n&gt;&gt;&gt; event = CalendarEvent.from_calendar_data(calendar_data=calendar_data, cmap=...)\n&gt;&gt;&gt; event.plot_event(ax=ax)\n</code></pre> <p>Plot a single calendar event from vocab</p> <pre><code>&gt;&gt;&gt; event = CalendarEvent.from_vocab(\"00 01\")\n&gt;&gt;&gt; event.plot_event(ax=ax)\n</code></pre> Source code in <code>latent_calendar/plot/elements.py</code> <pre><code>@dataclass\nclass CalendarEvent:\n\"\"\"Something on the calendar.\n    Plots rectangles on axis\n    Examples:\n        Plot event from calendar data\n        &gt;&gt;&gt; calendar_data = CalendarData(day=0, start=0, end=2.5)\n        &gt;&gt;&gt; event = CalendarEvent.from_calendar_data(calendar_data=calendar_data, cmap=...)\n        &gt;&gt;&gt; event.plot_event(ax=ax)\n        Plot a single calendar event from vocab\n        &gt;&gt;&gt; event = CalendarEvent.from_vocab(\"00 01\")\n        &gt;&gt;&gt; event.plot_event(ax=ax)\n    \"\"\"\nday: int\nstart: float\nend: float\nfillcolor: Optional[str] = None\nfill: bool = True\nalpha: Optional[float] = None\nlw: Optional[float] = None\nlinestyle: Optional[str] = None\n@classmethod\ndef from_calendar_data(\ncls, calendar_data: CalendarData, cmap: CMAP, alpha: Optional[float] = None\n) -&gt; \"CalendarEvent\":\nreturn cls(\nday=calendar_data.day,\nstart=calendar_data.start,\nend=calendar_data.end,\nfillcolor=cmap(calendar_data.value),\nalpha=alpha,\nlw=calendar_data.lw,\n)\n@classmethod\ndef from_vocab(\ncls,\nvocab: str,\nhours: float = 1.0,\nfillcolor: Optional[str] = None,\nfill: bool = False,\nalpha: Optional[float] = None,\nlw: float = 1.5,\nlinestyle: Optional[str] = \"dashed\",\n) -&gt; \"CalendarEvent\":\n\"\"\"Constructor from vocab string in order to plot on an axis.\n        TODO: Ability to have the number of days\n        TODO: Ability for the number of days to have wrapping as well.\n        Example:\n            Plot on an axis\n            &gt;&gt;&gt; event = CalendarEvent.from_vocab(\"00 01\")\n            &gt;&gt;&gt; event.plot_event(ax=ax)\n            Plot a two and half hour window\n            &gt;&gt;&gt; event = CalendarEvent.from_vocab(\"00 01\", hours=2.5)\n            &gt;&gt;&gt; event.plot_event(ax=ax)\n        \"\"\"\nday, hour = get_day_hour(vocab=vocab)\nreturn cls(\nday=day,\nstart=hour,\nend=hour + hours,\nfillcolor=fillcolor,\nfill=fill,\nalpha=alpha,\nlw=lw,\nlinestyle=linestyle,\n)\n@property\ndef multiday_tour(self) -&gt; bool:\nif self.end == HOURS_IN_DAY:\nreturn False\nreturn self.end % HOURS_IN_DAY &lt; self.start\ndef _cap_event_at_midnight(self) -&gt; \"CalendarEvent\":\nself.end = min(HOURS_IN_DAY, self.end)\ndef _create_next_day_event(self) -&gt; \"CalendarEvent\":\n\"\"\"In the case of tour going into the next day, this is the next item.\"\"\"\nreturn CalendarEvent(\nday=(self.day + 1) % DAYS_IN_WEEK,\nstart=0,\nend=self.end % HOURS_IN_DAY,\nfillcolor=self.fillcolor,\nfill=self.fill,\nalpha=self.alpha,\nlw=self.lw,\nlinestyle=self.linestyle,\n)\ndef separate_events(self) -&gt; List[\"CalendarEvent\"]:\n\"\"\"Return list of events that represent the one event across different days.\"\"\"\nevents = [replace(self)]\nif self.multiday_tour:\nevents.append(self._create_next_day_event())\n# Cap the initial rectangle at 24 hours\nevents[0]._cap_event_at_midnight()\nreturn events\ndef _create_matplotlib_rectangle(\nself, monday_start: bool, **kwargs\n) -&gt; plt.Rectangle:\n\"\"\"Create a rectangle matplotlib instance from the event.\"\"\"\nheight = self.end - self.start\nassert (\nheight &gt; 0.0\n), f\"The rectangle doesn't have positive height. Hour start {self.start} &gt; Hour end {self.end}\"\nx = self.day if monday_start else (self.day + 1) % DAYS_IN_WEEK\nrect_kwargs = {\n\"xy\": [x, self.start],\n\"width\": 1,\n\"height\": height,\n\"edgecolor\": \"black\",\n\"lw\": self.lw or DEFAULT_LW,\n\"fill\": self.fill,\n\"linestyle\": self.linestyle,\n}\nif self.fillcolor is not None:\nrect_kwargs[\"facecolor\"] = self.fillcolor\nif self.alpha is not None:\nrect_kwargs[\"alpha\"] = self.alpha\nreturn plt.Rectangle(**rect_kwargs, **kwargs)\ndef plot_event(self, ax: plt.Axes, monday_start: bool = True, **kwargs) -&gt; None:\n\"\"\"Put the CalendarEvent instance onto an axis.\n        Options for kwargs here:\n            https://matplotlib.org/stable/api/_as_gen/matplotlib.patches.Rectangle.html\n        Args:\n            ax: Axis to plot on\n            monday_start: Whether to start the week on Monday or Sunday.\n            kwargs: Addtional kwargs for the Patch instances or to override.\n        \"\"\"\nseparated_events = self.separate_events()\nfor event in separated_events:\nrectangle = event._create_matplotlib_rectangle(\nmonday_start=monday_start, **kwargs\n)\nax.add_patch(rectangle)\n</code></pre>"},{"location":"modules/plot/#latent_calendar.plot.elements.CalendarEvent.from_vocab","title":"<code>from_vocab(vocab, hours=1.0, fillcolor=None, fill=False, alpha=None, lw=1.5, linestyle='dashed')</code>  <code>classmethod</code>","text":"<p>Constructor from vocab string in order to plot on an axis.</p> <p>TODO: Ability to have the number of days TODO: Ability for the number of days to have wrapping as well.</p> Example <p>Plot on an axis</p> <p>event = CalendarEvent.from_vocab(\"00 01\") event.plot_event(ax=ax)</p> <p>Plot a two and half hour window</p> <p>event = CalendarEvent.from_vocab(\"00 01\", hours=2.5) event.plot_event(ax=ax)</p> Source code in <code>latent_calendar/plot/elements.py</code> <pre><code>@classmethod\ndef from_vocab(\ncls,\nvocab: str,\nhours: float = 1.0,\nfillcolor: Optional[str] = None,\nfill: bool = False,\nalpha: Optional[float] = None,\nlw: float = 1.5,\nlinestyle: Optional[str] = \"dashed\",\n) -&gt; \"CalendarEvent\":\n\"\"\"Constructor from vocab string in order to plot on an axis.\n    TODO: Ability to have the number of days\n    TODO: Ability for the number of days to have wrapping as well.\n    Example:\n        Plot on an axis\n        &gt;&gt;&gt; event = CalendarEvent.from_vocab(\"00 01\")\n        &gt;&gt;&gt; event.plot_event(ax=ax)\n        Plot a two and half hour window\n        &gt;&gt;&gt; event = CalendarEvent.from_vocab(\"00 01\", hours=2.5)\n        &gt;&gt;&gt; event.plot_event(ax=ax)\n    \"\"\"\nday, hour = get_day_hour(vocab=vocab)\nreturn cls(\nday=day,\nstart=hour,\nend=hour + hours,\nfillcolor=fillcolor,\nfill=fill,\nalpha=alpha,\nlw=lw,\nlinestyle=linestyle,\n)\n</code></pre>"},{"location":"modules/plot/#latent_calendar.plot.elements.CalendarEvent.plot_event","title":"<code>plot_event(ax, monday_start=True, **kwargs)</code>","text":"<p>Put the CalendarEvent instance onto an axis.</p> Options for kwargs here <p>https://matplotlib.org/stable/api/_as_gen/matplotlib.patches.Rectangle.html</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>plt.Axes</code> <p>Axis to plot on</p> required <code>monday_start</code> <code>bool</code> <p>Whether to start the week on Monday or Sunday.</p> <code>True</code> <code>kwargs</code> <p>Addtional kwargs for the Patch instances or to override.</p> <code>{}</code> Source code in <code>latent_calendar/plot/elements.py</code> <pre><code>def plot_event(self, ax: plt.Axes, monday_start: bool = True, **kwargs) -&gt; None:\n\"\"\"Put the CalendarEvent instance onto an axis.\n    Options for kwargs here:\n        https://matplotlib.org/stable/api/_as_gen/matplotlib.patches.Rectangle.html\n    Args:\n        ax: Axis to plot on\n        monday_start: Whether to start the week on Monday or Sunday.\n        kwargs: Addtional kwargs for the Patch instances or to override.\n    \"\"\"\nseparated_events = self.separate_events()\nfor event in separated_events:\nrectangle = event._create_matplotlib_rectangle(\nmonday_start=monday_start, **kwargs\n)\nax.add_patch(rectangle)\n</code></pre>"},{"location":"modules/plot/#latent_calendar.plot.elements.CalendarEvent.separate_events","title":"<code>separate_events()</code>","text":"<p>Return list of events that represent the one event across different days.</p> Source code in <code>latent_calendar/plot/elements.py</code> <pre><code>def separate_events(self) -&gt; List[\"CalendarEvent\"]:\n\"\"\"Return list of events that represent the one event across different days.\"\"\"\nevents = [replace(self)]\nif self.multiday_tour:\nevents.append(self._create_next_day_event())\n# Cap the initial rectangle at 24 hours\nevents[0]._cap_event_at_midnight()\nreturn events\n</code></pre>"},{"location":"modules/plot/#latent_calendar.plot.elements.DayLabeler","title":"<code>DayLabeler</code>  <code>dataclass</code>","text":"<p>This is typically the x-axis and all its settings in the plot.</p> Source code in <code>latent_calendar/plot/elements.py</code> <pre><code>@dataclass\nclass DayLabeler:\n\"\"\"This is typically the x-axis and all its settings in the plot.\"\"\"\nday_start: int = 0\ndays_of_week: List[str] = field(default_factory=create_default_days)\nrotation: Optional[float] = 45\ndisplay: bool = True\nmonday_start: bool = True\ndef __post_init__(self) -&gt; None:\nif self.day_start not in range(DAYS_IN_WEEK):\nmsg = f\"'day_start' value must be 0: Monday or 6: Sunday\"\nraise ValueError(msg)\n@property\ndef day_labels(self) -&gt; List[str]:\n\"\"\"What is added to the plot. If this is display, empty ticks.\"\"\"\nif not self.display:\nreturn [\"\" for _ in range(DAYS_IN_WEEK)]\nreturn self.days_of_week[self.day_start :] + self.days_of_week[: self.day_start]\ndef create_labels(self, ax: plt.Axes, axis: str = \"x\") -&gt; None:\n\"\"\"Create the labels for the plot.\"\"\"\ngetattr(ax, f\"set_{axis}lim\")(0, DAYS_IN_WEEK)\ngetattr(ax, f\"set_{axis}ticks\")(\n[i + 0.5 for i in range(DAYS_IN_WEEK)],\nself.day_labels,\nrotation=self.rotation,\n)\nif axis == \"y\":\nax.invert_yaxis()\n</code></pre>"},{"location":"modules/plot/#latent_calendar.plot.elements.DayLabeler.day_labels","title":"<code>day_labels: List[str]</code>  <code>property</code>","text":"<p>What is added to the plot. If this is display, empty ticks.</p>"},{"location":"modules/plot/#latent_calendar.plot.elements.DayLabeler.create_labels","title":"<code>create_labels(ax, axis='x')</code>","text":"<p>Create the labels for the plot.</p> Source code in <code>latent_calendar/plot/elements.py</code> <pre><code>def create_labels(self, ax: plt.Axes, axis: str = \"x\") -&gt; None:\n\"\"\"Create the labels for the plot.\"\"\"\ngetattr(ax, f\"set_{axis}lim\")(0, DAYS_IN_WEEK)\ngetattr(ax, f\"set_{axis}ticks\")(\n[i + 0.5 for i in range(DAYS_IN_WEEK)],\nself.day_labels,\nrotation=self.rotation,\n)\nif axis == \"y\":\nax.invert_yaxis()\n</code></pre>"},{"location":"modules/plot/#latent_calendar.plot.elements.DisplaySettings","title":"<code>DisplaySettings</code>  <code>dataclass</code>","text":"<p>Small wrapper to hold the display settings in the plots.</p> Source code in <code>latent_calendar/plot/elements.py</code> <pre><code>@dataclass\nclass DisplaySettings:\n\"\"\"Small wrapper to hold the display settings in the plots.\"\"\"\nx: bool = True\ny: bool = True\n</code></pre>"},{"location":"modules/plot/#latent_calendar.plot.elements.GridLines","title":"<code>GridLines</code>  <code>dataclass</code>","text":"<p>Grid lines between the calendar for the plot.</p> Source code in <code>latent_calendar/plot/elements.py</code> <pre><code>@dataclass\nclass GridLines:\n\"\"\"Grid lines between the calendar for the plot.\"\"\"\ndow: bool = False\nhour: bool = False\ncolor: str = \"black\"\nlinestyle: str = \"--\"\nalpha: float = 0.2\ndef configure_grid(self, ax: plt.Axes) -&gt; None:\nif self.dow:\nfor dow in range(DAYS_IN_WEEK):\nax.axvline(\nx=dow + 1,\ncolor=self.color,\nlinestyle=self.linestyle,\nalpha=self.alpha,\n)\nif self.hour:\nfor hour in range(HOURS_IN_DAY):\nax.axhline(\ny=hour + 1,\ncolor=self.color,\nlinestyle=self.linestyle,\nalpha=self.alpha,\n)\n</code></pre>"},{"location":"modules/plot/#latent_calendar.plot.elements.PlotAxes","title":"<code>PlotAxes</code>  <code>dataclass</code>","text":"<p>This configures the x and y axis in the plots.</p> Source code in <code>latent_calendar/plot/elements.py</code> <pre><code>@dataclass\nclass PlotAxes:\n\"\"\"This configures the x and y axis in the plots.\"\"\"\nday_labeler: DayLabeler = field(default_factory=DayLabeler)\ntime_labeler: TimeLabeler = field(default_factory=TimeLabeler)\n@classmethod\ndef axes_to_display(cls, x: bool = True, y: bool = True) -&gt; \"PlotAxes\":\ndisplay_settings = DisplaySettings(x=x, y=y)\nplot_axes = cls()\nplot_axes.update_display_settings(display_settings=display_settings)\nreturn plot_axes\ndef configure_axis(self, ax: plt.Axes) -&gt; None:\nself.day_labeler.create_labels(ax=ax)\nself.time_labeler.create_labels(ax=ax)\ndef update_display_settings(self, display_settings: DisplaySettings) -&gt; None:\nself.day_labeler.display = display_settings.x\nself.time_labeler.display = display_settings.y\ndef update_start(self, monday_start: bool) -&gt; None:\nself.day_labeler.day_start = 0 if monday_start else 6\n</code></pre>"},{"location":"modules/plot/#latent_calendar.plot.elements.TimeLabeler","title":"<code>TimeLabeler</code>  <code>dataclass</code>","text":"<p>This is the y-axis and all its settings in the plot.</p> <p>Also possible to be an x-axis for other plots as well.</p> Source code in <code>latent_calendar/plot/elements.py</code> <pre><code>@dataclass\nclass TimeLabeler:\n\"\"\"This is the y-axis and all its settings in the plot.\n    Also possible to be an x-axis for other plots as well.\n    \"\"\"\nhour_formatter: HourFormatter = HourFormatter()\nstart: int = 0\nstride: int = 2\ndisplay: bool = True\nrotation: Optional[float] = 0\ndef get_hours(self) -&gt; Tuple[List[int], List[str]]:\nreturn range(HOURS_IN_DAY + 1)[:: self.stride]\ndef create_labels(self, ax: plt.Axes, axis: str = \"y\") -&gt; None:\n\"\"\"Create the hour labels on the plot ax.\"\"\"\nif axis not in {\"x\", \"y\"}:\nraise ValueError(\"Only supported for the x and y.\")\nhours = self.get_hours()\nhour_name_func = self.label if self.display else self.empty_label\nhour_names = hour_name_func(hours)\ngetattr(ax, f\"set_{axis}ticks\")(hours, hour_names, rotation=self.rotation)\ngetattr(ax, f\"set_{axis}lim\")(0, HOURS_IN_DAY)\nif axis == \"y\":\nax.invert_yaxis()\ndef label(self, hrs: List[int]) -&gt; List[str]:\nreturn [self.hour_formatter(hr) for hr in hrs]\ndef empty_label(self, hrs: List[int]) -&gt; List[str]:\nreturn [\"\" for _ in range(len(hrs))]\n</code></pre>"},{"location":"modules/plot/#latent_calendar.plot.elements.TimeLabeler.create_labels","title":"<code>create_labels(ax, axis='y')</code>","text":"<p>Create the hour labels on the plot ax.</p> Source code in <code>latent_calendar/plot/elements.py</code> <pre><code>def create_labels(self, ax: plt.Axes, axis: str = \"y\") -&gt; None:\n\"\"\"Create the hour labels on the plot ax.\"\"\"\nif axis not in {\"x\", \"y\"}:\nraise ValueError(\"Only supported for the x and y.\")\nhours = self.get_hours()\nhour_name_func = self.label if self.display else self.empty_label\nhour_names = hour_name_func(hours)\ngetattr(ax, f\"set_{axis}ticks\")(hours, hour_names, rotation=self.rotation)\ngetattr(ax, f\"set_{axis}lim\")(0, HOURS_IN_DAY)\nif axis == \"y\":\nax.invert_yaxis()\n</code></pre>"},{"location":"modules/plot/#latent_calendar.plot.grid_settings.default_plot_axes_in_grid","title":"<code>default_plot_axes_in_grid(nrows, ncols, total=None, day_labeler=None, time_labeler=None)</code>","text":"<p>Additional layer on the display_settings_in_grid in order to modify the settings.</p> <p>Yields:</p> Type Description <code>PlotAxes</code> <p>PlotAxes instance with appropriate display settings based on the position in the grid.</p> Source code in <code>latent_calendar/plot/grid_settings.py</code> <pre><code>def default_plot_axes_in_grid(\nnrows: int,\nncols: int,\ntotal: Optional[int] = None,\nday_labeler: Optional[DayLabeler] = None,\ntime_labeler: Optional[TimeLabeler] = None,\n) -&gt; Generator[PlotAxes, None, None]:\n\"\"\"Additional layer on the display_settings_in_grid in order to modify the settings.\n    Yields:\n        PlotAxes instance with appropriate display settings based on the position in the grid.\n    \"\"\"\nday_labeler = day_labeler if day_labeler is not None else DayLabeler()\ndefault_stride = 2 if nrows &lt;= 2 else 4\ntime_labeler = (\ntime_labeler if time_labeler is not None else TimeLabeler(stride=default_stride)\n)\nfor display_settings in display_settings_in_grid(\nnrows=nrows, ncols=ncols, total=total\n):\nday_labeler.display = display_settings.x\ntime_labeler.display = display_settings.y\nyield PlotAxes(\nday_labeler=day_labeler,\ntime_labeler=time_labeler,\n)\n</code></pre>"},{"location":"modules/plot/#latent_calendar.plot.grid_settings.display_settings_in_grid","title":"<code>display_settings_in_grid(nrows, ncols, total=None)</code>","text":"<p>Helper for display logic in a grid.</p> <p>Can be used with zip since zip function will stop at the shorts of the iterators</p> <p>Yields:</p> Type Description <code>DisplaySettings</code> <p>DisplaySettings instance with the appropriate settings based on position in the grid.</p> Source code in <code>latent_calendar/plot/grid_settings.py</code> <pre><code>def display_settings_in_grid(\nnrows: int, ncols: int, total: Optional[int] = None\n) -&gt; Generator[DisplaySettings, None, None]:\n\"\"\"Helper for display logic in a grid.\n    Can be used with zip since zip function will stop at the shorts of the iterators\n    Yields:\n        DisplaySettings instance with the appropriate settings based on position in the grid.\n    \"\"\"\ntotal = total if total is not None else nrows * ncols\nyield from (\nDisplaySettings(\nx=last_in_column(i, nrows, ncols, total), y=is_left_edge(i, ncols)\n)\nfor i in range(total)\n)\n</code></pre>"},{"location":"modules/plot/#latent_calendar.plot.grid_settings.get_rows_and_cols","title":"<code>get_rows_and_cols(n, max_cols)</code>","text":"<p>Return the number of rows and cols.</p> Source code in <code>latent_calendar/plot/grid_settings.py</code> <pre><code>def get_rows_and_cols(n: int, max_cols: int) -&gt; Tuple[int, int]:\n\"\"\"Return the number of rows and cols.\"\"\"\nnrows = max((n // max_cols) + 1, 1)\nncols = min(n, max_cols)\nif n % max_cols == 0:\nnrows -= 1\nreturn nrows, ncols\n</code></pre>"},{"location":"modules/plot/#latent_calendar.plot.grid_settings.grid_axes","title":"<code>grid_axes(nrows, ncols, total)</code>","text":"<p>Yields a grid of size nrow, ncols with total cap.</p> <p>Using this instead of plt.subplots(ncols, nrows) and deleting</p> Source code in <code>latent_calendar/plot/grid_settings.py</code> <pre><code>def grid_axes(nrows: int, ncols: int, total: int) -&gt; Generator[plt.Axes, None, None]:\n\"\"\"Yields a grid of size nrow, ncols with total cap.\n    Using this instead of plt.subplots(ncols, nrows) and deleting\n    \"\"\"\ngs = gridspec.GridSpec(nrows, ncols)\nfig = plt.figure()\nyield from (fig.add_subplot(gs[i]) for i in range(total))\n</code></pre>"},{"location":"modules/plot/#latent_calendar.plot.grid_settings.last_in_column","title":"<code>last_in_column(i, nrows, ncols, total)</code>","text":"<p>Return if the index i is last row in columns assuming a total number of elements.</p> Source code in <code>latent_calendar/plot/grid_settings.py</code> <pre><code>def last_in_column(i: int, nrows: int, ncols: int, total: int) -&gt; bool:\n\"\"\"Return if the index i is last row in columns assuming a total number of elements.\"\"\"\ngrid_size = nrows * ncols\ndifference = grid_size - total\nif difference &gt; ncols:\nmsg = f\"{nrows = } and {ncols = } with {total = }. This combination doesn't make sense. One whole row will be empty!\"\nraise ValueError(msg)\n# Past the last values requires the second to last row instead of last\noffset = 2 if col_idx(i, ncols) &gt;= ncols - difference else 1\nreturn row_idx(i, ncols) == (nrows - offset)\n</code></pre>"},{"location":"modules/plot/#latent_calendar.plot.iterate.CalendarData","title":"<code>CalendarData</code>  <code>dataclass</code>","text":"<p>All the data that goes into calendar plot.</p> Source code in <code>latent_calendar/plot/iterate.py</code> <pre><code>@dataclass\nclass CalendarData:\n\"\"\"All the data that goes into calendar plot.\"\"\"\nday: int\nstart: float\nend: float\nvalue: float\nlw: Optional[float] = None\n</code></pre>"},{"location":"modules/plot/#latent_calendar.plot.iterate.IterConfig","title":"<code>IterConfig</code>  <code>dataclass</code>","text":"<p>             Bases: <code>DataFrameConfig</code></p> <p>Small wrapper to hold the column mapping in DataFrame.</p> Source code in <code>latent_calendar/plot/iterate.py</code> <pre><code>@dataclass\nclass IterConfig(DataFrameConfig):\n\"\"\"Small wrapper to hold the column mapping in DataFrame.\"\"\"\nday: str = \"day_of_week\"\nstart: str = \"hour_start\"\nend: str = \"hour_end\"\nvalue: str = \"value\"\nlw: str = \"lw\"\n@property\ndef columns(self) -&gt; List[str]:\nreturn [self.day, self.start, self.end]\ndef extract_columns(self, df: pd.DataFrame) -&gt; FRAME_ITER:\nself._check_columns(df)\nreturn (\ndf[self.day],\ndf[self.start],\ndf[self.end],\nself._default_repeat(df, self.value, VALUE_DEFAULT),\nself._default_repeat(df, self.lw, LW_DEFAULT),\n)\n</code></pre>"},{"location":"modules/plot/#latent_calendar.plot.iterate.VocabIterConfig","title":"<code>VocabIterConfig</code>  <code>dataclass</code>","text":"<p>             Bases: <code>DataFrameConfig</code></p> <p>Small wrapper to hold the column mapping in the DataFrame.</p> Source code in <code>latent_calendar/plot/iterate.py</code> <pre><code>@dataclass\nclass VocabIterConfig(DataFrameConfig):\n\"\"\"Small wrapper to hold the column mapping in the DataFrame.\"\"\"\nvocab: str = \"vocab\"\nvalue: str = \"value\"\nlw: str = \"lw\"\n@property\ndef columns(self) -&gt; List[str]:\nreturn [self.vocab]\ndef extract_columns(self, df: pd.DataFrame) -&gt; FRAME_ITER:\nself._check_columns(df)\nday = df[self.vocab].str.split(\" \").apply(lambda x: int(x[0]))\nstart = df[self.vocab].str.split(\" \").apply(lambda x: int(x[1]))\nreturn (\nday,\nstart,\nstart + 1,\nself._default_repeat(df, self.value, VALUE_DEFAULT),\nself._default_repeat(df, self.lw, LW_DEFAULT),\n)\n</code></pre>"},{"location":"modules/plot/#latent_calendar.plot.iterate.iterate_dataframe","title":"<code>iterate_dataframe(df, config)</code>","text":"<p>Iterate the calendar data in DataFrame form based on config.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>pd.DataFrame</code> <p>DataFrame with calendar data.</p> required <code>config</code> <code>DataFrameConfig</code> <p>Configuration to describe what columns to use.</p> required Source code in <code>latent_calendar/plot/iterate.py</code> <pre><code>def iterate_dataframe(\ndf: pd.DataFrame,\nconfig: DataFrameConfig,\n) -&gt; CALENDAR_ITERATION:\n\"\"\"Iterate the calendar data in DataFrame form based on config.\n    Args:\n        df: DataFrame with calendar data.\n        config: Configuration to describe what columns to use.\n    \"\"\"\nfor values in zip(*config.extract_columns(df)):\nyield CalendarData(*values)\n</code></pre>"},{"location":"modules/plot/#latent_calendar.plot.iterate.iterate_matrix","title":"<code>iterate_matrix(calendar_data)</code>","text":"<p>Iterates the calendar matrix of values.</p> Source code in <code>latent_calendar/plot/iterate.py</code> <pre><code>def iterate_matrix(calendar_data: np.ndarray) -&gt; CALENDAR_ITERATION:\n\"\"\"Iterates the calendar matrix of values.\"\"\"\nif calendar_data.ndim != 2:\nraise ValueError(f\"Data must be 2d not of shape {calendar_data.shape}\")\nn_days, n_hours = calendar_data.shape\nif n_days != DAYS_IN_WEEK:\nraise ValueError(f\"Data must have {DAYS_IN_WEEK} days not {n_days}\")\nstep_size = HOURS_IN_DAY / n_hours\nfor day, hours in enumerate(calendar_data):\nfor hour, value in enumerate(hours):\nstart = hour * step_size\nend = start + step_size\nyield CalendarData(day, start, end, value)\n</code></pre>"},{"location":"modules/segments/","title":"Segments","text":"<p>Create hand picked segments on the calendar.</p> <p>Processing off calendar distribution.</p>"},{"location":"modules/segments/#latent_calendar.segments.hand_picked.create_blank_segment_series","title":"<code>create_blank_segment_series()</code>","text":"<p>Helper for making segments programatically.</p> Source code in <code>latent_calendar/segments/hand_picked.py</code> <pre><code>def create_blank_segment_series() -&gt; pd.Series:\n\"\"\"Helper for making segments programatically.\"\"\"\nreturn pd.Series(0, index=FULL_VOCAB)\n</code></pre>"},{"location":"modules/segments/#latent_calendar.segments.hand_picked.create_box_segment","title":"<code>create_box_segment(day_start, day_end, hour_start, hour_end, name=None)</code>","text":"<p>Programmatically make segment of box described by inputs.</p> Source code in <code>latent_calendar/segments/hand_picked.py</code> <pre><code>def create_box_segment(\nday_start: int,\nday_end: int,\nhour_start: int,\nhour_end: int,\nname: Optional[str] = None,\n) -&gt; pd.Series:\n\"\"\"Programmatically make segment of box described by inputs.\"\"\"\nser = create_blank_segment_series()\nfor dow in range(day_start, day_end):\nstart = DOWHour(dow=dow, hour=hour_start)\nend = DOWHour(dow=dow, hour=hour_end)\nser += create_series_for_range(start=start, end=end)\nname = name or f\"{day_start}-{day_end} {hour_start}-{hour_end}\"\nreturn ser.rename(name)\n</code></pre>"},{"location":"modules/segments/#latent_calendar.segments.hand_picked.create_dow_segments","title":"<code>create_dow_segments()</code>","text":"<p>Programmatically make the DOW segments.</p> <p>Each row is just each day of the week.</p> <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>DataFrame in the df_segments wide format</p> Source code in <code>latent_calendar/segments/hand_picked.py</code> <pre><code>def create_dow_segments() -&gt; pd.DataFrame:\n\"\"\"Programmatically make the DOW segments.\n    Each row is just each day of the week.\n    Returns:\n        DataFrame in the df_segments wide format\n    \"\"\"\nsegments = []\nfor i, day in enumerate(create_default_days()):\nday_number = str(i).zfill(2)\nname = f\"{day_number}-{day}\"\nstart = DOWHour(dow=i, hour=0)\nend = DOWHour(dow=i, hour=24)\nsegments.append(create_hourly_segment(start=start, end=end, name=name))\nreturn stack_segments(segments)\n</code></pre>"},{"location":"modules/segments/#latent_calendar.segments.hand_picked.create_empty_template","title":"<code>create_empty_template()</code>","text":"<p>Create blank template in order</p> Source code in <code>latent_calendar/segments/hand_picked.py</code> <pre><code>def create_empty_template() -&gt; pd.DataFrame:\n\"\"\"Create blank template in order\"\"\"\nindex = pd.Index(range(HOURS_IN_DAY), name=\"hour_start\")\nreturn pd.DataFrame(\nnp.nan,\nindex=index,\ncolumns=create_default_days(),\n)\n</code></pre>"},{"location":"modules/segments/#latent_calendar.segments.hand_picked.create_every_hour_segments","title":"<code>create_every_hour_segments()</code>","text":"<p>Programmatically segments for every hour</p> <p>Each row is just each time slot</p> <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>DataFrame in the df_segments wide format</p> Source code in <code>latent_calendar/segments/hand_picked.py</code> <pre><code>def create_every_hour_segments() -&gt; pd.DataFrame:\n\"\"\"Programmatically segments for every hour\n    Each row is just each time slot\n    Returns:\n        DataFrame in the df_segments wide format\n    \"\"\"\nsegments = []\nfor dow, hour in itertools.product(range(DAYS_IN_WEEK), range(HOURS_IN_DAY)):\nname = format_dow_hour(dow, hour)\nstart = DOWHour(dow=dow, hour=hour)\nend = DOWHour(dow=dow, hour=hour + 1)\nsegments.append(create_hourly_segment(start=start, end=end, name=name))\nreturn stack_segments(segments)\n</code></pre>"},{"location":"modules/segments/#latent_calendar.segments.hand_picked.create_hourly_segment","title":"<code>create_hourly_segment(start, end, name)</code>","text":"<p>Highlight from start until end.</p> Source code in <code>latent_calendar/segments/hand_picked.py</code> <pre><code>def create_hourly_segment(start: DOWHour, end: DOWHour, name: str) -&gt; pd.Series:\n\"\"\"Highlight from start until end.\"\"\"\nreturn create_series_for_range(start=start, end=end).rename(name)\n</code></pre>"},{"location":"modules/segments/#latent_calendar.segments.hand_picked.create_series_for_range","title":"<code>create_series_for_range(start, end)</code>","text":"<p>Create a series for a range of hours with ones for those in range.</p> Source code in <code>latent_calendar/segments/hand_picked.py</code> <pre><code>def create_series_for_range(start: DOWHour, end: DOWHour) -&gt; pd.Series:\n\"\"\"Create a series for a range of hours with ones for those in range.\"\"\"\nser = create_blank_segment_series()\nif start.is_after(end):\nend, start = start, end\nnegate = True\nelse:\nnegate = False\nstart_idx = format_dow_hour(start.dow, start.hour)\nend_idx = format_dow_hour(end.dow, end.hour - 1)\nser.loc[start_idx:end_idx] = 1\nif negate:\nser = (ser - 1) * -1\nreturn ser.astype(int)\n</code></pre>"},{"location":"modules/segments/#latent_calendar.segments.hand_picked.get_vocab_for_range","title":"<code>get_vocab_for_range(start, end)</code>","text":"<p>Get the vocab for a range of hours.</p> Source code in <code>latent_calendar/segments/hand_picked.py</code> <pre><code>def get_vocab_for_range(start: DOWHour, end: DOWHour) -&gt; List[str]:\n\"\"\"Get the vocab for a range of hours.\"\"\"\nreturn (\ncreate_series_for_range(start=start, end=end)\n.loc[lambda x: x == 1]\n.index.tolist()\n)\n</code></pre>"},{"location":"modules/segments/#latent_calendar.segments.hand_picked.stack_segments","title":"<code>stack_segments(segments)</code>","text":"<p>Stack segments into a single dataframe.</p> Source code in <code>latent_calendar/segments/hand_picked.py</code> <pre><code>def stack_segments(segments: List[pd.Series]) -&gt; pd.DataFrame:\n\"\"\"Stack segments into a single dataframe.\"\"\"\nreturn pd.concat(segments, axis=1).T\n</code></pre>"},{"location":"modules/segments/#latent_calendar.segments.convolution.identity","title":"<code>identity(df_probs)</code>","text":"<p>Return the input.</p> Source code in <code>latent_calendar/segments/convolution.py</code> <pre><code>def identity(df_probs: pd.DataFrame) -&gt; pd.DataFrame:\n\"\"\"Return the input.\"\"\"\nreturn df_probs\n</code></pre>"},{"location":"modules/segments/#latent_calendar.segments.convolution.mask_probs","title":"<code>mask_probs(X_segments, X_pred)</code>","text":"<p>Multiply out the mask.</p> <p>Parameters:</p> Name Type Description Default <code>X_segments</code> <p>(n_segments, n_times)</p> required <code>X_pred</code> <p>(nrows, n_times)</p> required <p>Returns:</p> Type Description <code>np.ndarray</code> <p>(n_segments, nrows, n_times) matrix of only the values that fall into the segments times</p> Source code in <code>latent_calendar/segments/convolution.py</code> <pre><code>def mask_probs(X_segments, X_pred) -&gt; np.ndarray:\n\"\"\"Multiply out the mask.\n    Args:\n        X_segments: (n_segments, n_times)\n        X_pred: (nrows, n_times)\n    Returns:\n        (n_segments, nrows, n_times) matrix of only the values that fall into the segments times\n    \"\"\"\nreturn X_segments[:, None, :] * X_pred\n</code></pre>"},{"location":"modules/segments/#latent_calendar.segments.convolution.sum_array_over_segments","title":"<code>sum_array_over_segments(X_pred, X_segment)</code>","text":"<p>Get the probability of the mask for the probabilities.</p> <p>Parameters:</p> Name Type Description Default <code>X_pred</code> <code>np.ndarray</code> <p>(nrows, n_times)</p> required <code>X_segment</code> <code>np.ndarray</code> <p>(n_segments, n_times)</p> required <p>Returns:</p> Type Description <code>np.ndarray</code> <p>Matrix of (nrows, n_segments) defining the probabilities of each segments</p> Source code in <code>latent_calendar/segments/convolution.py</code> <pre><code>def sum_array_over_segments(X_pred: np.ndarray, X_segment: np.ndarray) -&gt; np.ndarray:\n\"\"\"Get the probability of the mask for the probabilities.\n    Args:\n        X_pred: (nrows, n_times)\n        X_segment: (n_segments, n_times)\n    Returns:\n        Matrix of (nrows, n_segments) defining the probabilities of each segments\n    \"\"\"\nreturn mask_probs(X_segment, X_pred).sum(axis=2).T\n</code></pre>"},{"location":"modules/segments/#latent_calendar.segments.convolution.sum_next_hours","title":"<code>sum_next_hours(df, hours)</code>","text":"<p>Sum the next hours columns.</p> <p>Useful for finding probability of having tour in the next 5 hours 00 00 column would be 06 06 23</p> <p>TODO: Consider if negative hours should be allowed</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>pd.DataFrame</code> <p>DataFrame of probabilities</p> required <code>hours</code> <code>int</code> <p>Number of hours to sum after the current hour</p> required <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>DataFrame of probabilities summed over the next hours</p> Source code in <code>latent_calendar/segments/convolution.py</code> <pre><code>def sum_next_hours(df: pd.DataFrame, hours: int) -&gt; pd.DataFrame:\n\"\"\"Sum the next hours columns.\n    Useful for finding probability of having tour in the next 5 hours\n    00 00 column would be 06 06 23\n    TODO: Consider if negative hours should be allowed\n    Arguments:\n        df: DataFrame of probabilities\n        hours: Number of hours to sum after the current hour\n    Returns:\n        DataFrame of probabilities summed over the next hours\n    \"\"\"\nif hours &lt; 0:\nmsg = \"hours cannot be negative\"\nraise ValueError(msg)\nif hours == 0:\nreturn df\nreturn (\npd.concat([df, df.iloc[:, :hours]], axis=1)\n.pipe(_reverse_columns)\n.rolling(hours + 1, axis=1)\n.sum()\n.iloc[:, hours:]\n.pipe(_reverse_columns)\n)\n</code></pre>"},{"location":"modules/segments/#latent_calendar.segments.convolution.sum_over_segments","title":"<code>sum_over_segments(df, df_segments)</code>","text":"<p>Sum DataFrame over user defined segments.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>pd.DataFrame</code> <p>DataFrame of probabilities or counts in wide format</p> required <code>df_segments</code> <code>pd.DataFrame</code> <p>DataFrame of segments in wide format</p> required <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>DataFrame of probabilities or counts summed over the segments</p> Source code in <code>latent_calendar/segments/convolution.py</code> <pre><code>def sum_over_segments(df: pd.DataFrame, df_segments: pd.DataFrame) -&gt; pd.DataFrame:\n\"\"\"Sum DataFrame over user defined segments.\n    Args:\n        df: DataFrame of probabilities or counts in wide format\n        df_segments: DataFrame of segments in wide format\n    Returns:\n        DataFrame of probabilities or counts summed over the segments\n    \"\"\"\nreturn pd.DataFrame(\nsum_array_over_segments(df.to_numpy(), df_segments.to_numpy()),\nindex=df.index,\ncolumns=df_segments.index,\n)\n</code></pre>"},{"location":"modules/segments/#latent_calendar.segments.convolution.sum_over_vocab","title":"<code>sum_over_vocab(df, aggregation='dow')</code>","text":"<p>Sum the wide DataFrame columns to hours or dow.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>pd.DataFrame</code> <p>DataFrame with the full vocab columns</p> required <code>aggregation</code> <code>str</code> <p>either dow or hour</p> <code>'dow'</code> <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>DataFrame columns associated with the aggregation</p> Source code in <code>latent_calendar/segments/convolution.py</code> <pre><code>def sum_over_vocab(df: pd.DataFrame, aggregation: str = \"dow\") -&gt; pd.DataFrame:\n\"\"\"Sum the wide DataFrame columns to hours or dow.\n    Args:\n        df: DataFrame with the full vocab columns\n        aggregation: either dow or hour\n    Returns:\n        DataFrame columns associated with the aggregation\n    \"\"\"\nif aggregation not in {\"dow\", \"hour\"}:\nmsg = \"The aggregation must be hour or dow\"\nraise ValueError(msg)\nif aggregation == \"hour\":\nregex_func = _hour_regex\ntotal_values = HOURS_IN_DAY\ncolumn_name_func = lambda i: i\nelse:\nregex_func = _dow_regex\ntotal_values = DAYS_IN_WEEK\ncolumn_name_func = day_of_week_column_name_func\nreturn pd.concat(\n[\ndf.filter(regex=regex_func(i)).sum(axis=1).rename(column_name_func(i))\nfor i in range(total_values)\n],\naxis=1,\n)\n</code></pre>"},{"location":"modules/transformers/","title":"Transformers","text":"<p>scikit-learn transformers for the data.</p> <pre><code>from latent_calendar.datasets import load_online_transactions\ndf = load_online_transactions()\ntransformers = create_raw_to_vocab_transformer(id_col=\"Customer ID\", timestamp_col=\"InvoiceDate\")\ndf_wide = transformers.fit_transform(df)\n</code></pre>"},{"location":"modules/transformers/#latent_calendar.transformers.CalandarTimestampFeatures","title":"<code>CalandarTimestampFeatures</code>","text":"<p>             Bases: <code>BaseEstimator</code>, <code>TransformerMixin</code></p> <p>Day of week and prop into day columns creation.</p> Source code in <code>latent_calendar/transformers.py</code> <pre><code>class CalandarTimestampFeatures(BaseEstimator, TransformerMixin):\n\"\"\"Day of week and prop into day columns creation.\"\"\"\ndef __init__(\nself,\ntimestamp_col: str,\n) -&gt; None:\nself.timestamp_col = timestamp_col\ndef fit(self, X: pd.DataFrame, y=None):\nreturn self\ndef transform(self, X: pd.DataFrame, y=None) -&gt; pd.DataFrame:\n\"\"\"Create 2 new columns.\"\"\"\nif not hasattr(X[self.timestamp_col], \"dt\"):\nraise RuntimeError(\nf\"Column {self.timestamp_col!r} is not a datetime column. Use df[{self.timestamp_col!r}] = pd.to_datetime(df[{self.timestamp_col!r}]) first.\"\n)\nX = X.copy()\nX[\"prop_into_day_start\"] = prop_into_day(X[self.timestamp_col].dt)\nX[\"day_of_week\"] = X[self.timestamp_col].dt.dayofweek\nX[\"hour\"] = X[\"prop_into_day_start\"] * 24\ntmp_columns = [\"prop_into_day_start\"]\nself.created_columns = [\"day_of_week\", \"hour\"]\nX = X.drop(columns=tmp_columns)\nself.columns = list(X.columns)\nreturn X\ndef get_feature_names_out(self, input_features=None):\nreturn self.columns.extend(self.created_columns)\n</code></pre>"},{"location":"modules/transformers/#latent_calendar.transformers.CalandarTimestampFeatures.transform","title":"<code>transform(X, y=None)</code>","text":"<p>Create 2 new columns.</p> Source code in <code>latent_calendar/transformers.py</code> <pre><code>def transform(self, X: pd.DataFrame, y=None) -&gt; pd.DataFrame:\n\"\"\"Create 2 new columns.\"\"\"\nif not hasattr(X[self.timestamp_col], \"dt\"):\nraise RuntimeError(\nf\"Column {self.timestamp_col!r} is not a datetime column. Use df[{self.timestamp_col!r}] = pd.to_datetime(df[{self.timestamp_col!r}]) first.\"\n)\nX = X.copy()\nX[\"prop_into_day_start\"] = prop_into_day(X[self.timestamp_col].dt)\nX[\"day_of_week\"] = X[self.timestamp_col].dt.dayofweek\nX[\"hour\"] = X[\"prop_into_day_start\"] * 24\ntmp_columns = [\"prop_into_day_start\"]\nself.created_columns = [\"day_of_week\", \"hour\"]\nX = X.drop(columns=tmp_columns)\nself.columns = list(X.columns)\nreturn X\n</code></pre>"},{"location":"modules/transformers/#latent_calendar.transformers.HourDiscretizer","title":"<code>HourDiscretizer</code>","text":"<p>             Bases: <code>BaseEstimator</code>, <code>TransformerMixin</code></p> <p>Discretize the hour column.</p> Source code in <code>latent_calendar/transformers.py</code> <pre><code>class HourDiscretizer(BaseEstimator, TransformerMixin):\n\"\"\"Discretize the hour column.\"\"\"\ndef __init__(self, col: str = \"hour\") -&gt; None:\nself.col = col\ndef fit(self, X: pd.DataFrame, y=None):\nreturn self\ndef transform(self, X: pd.DataFrame, y=None):\nX[self.col] = (X[self.col] // 1).astype(int)\nself.columns = list(X.columns)\nreturn X\ndef get_feature_names_out(self, input_features=None):\nreturn self.columns\n</code></pre>"},{"location":"modules/transformers/#latent_calendar.transformers.LongToWide","title":"<code>LongToWide</code>","text":"<p>             Bases: <code>BaseEstimator</code>, <code>TransformerMixin</code></p> Source code in <code>latent_calendar/transformers.py</code> <pre><code>class LongToWide(BaseEstimator, TransformerMixin):\ndef __init__(self, col: str = \"num_events\", as_int: bool = True) -&gt; None:\nself.col = col\nself.as_int = as_int\ndef fit(self, X: pd.DataFrame, y=None):\nreturn self\ndef transform(self, X: pd.DataFrame, y=None) -&gt; pd.DataFrame:\n\"\"\"Unstack the assumed last index as vocab column.\"\"\"\nX_T = X.loc[:, self.col].unstack().T\nX_T.index = X_T.index.get_level_values(-1)\nX_T = X_T.reindex(FULL_VOCAB)\nX_res = X_T.T.fillna(value=0)\nif self.as_int:\nX_res = X_res.astype(int)\nreturn X_res\ndef get_feature_names_out(self, input_features=None):\nreturn FULL_VOCAB\n</code></pre>"},{"location":"modules/transformers/#latent_calendar.transformers.LongToWide.transform","title":"<code>transform(X, y=None)</code>","text":"<p>Unstack the assumed last index as vocab column.</p> Source code in <code>latent_calendar/transformers.py</code> <pre><code>def transform(self, X: pd.DataFrame, y=None) -&gt; pd.DataFrame:\n\"\"\"Unstack the assumed last index as vocab column.\"\"\"\nX_T = X.loc[:, self.col].unstack().T\nX_T.index = X_T.index.get_level_values(-1)\nX_T = X_T.reindex(FULL_VOCAB)\nX_res = X_T.T.fillna(value=0)\nif self.as_int:\nX_res = X_res.astype(int)\nreturn X_res\n</code></pre>"},{"location":"modules/transformers/#latent_calendar.transformers.RawToVocab","title":"<code>RawToVocab</code>","text":"<p>             Bases: <code>BaseEstimator</code>, <code>TransformerMixin</code></p> <p>Transformer timestamp level data into id level data with vocab columns.</p> Source code in <code>latent_calendar/transformers.py</code> <pre><code>class RawToVocab(BaseEstimator, TransformerMixin):\n\"\"\"Transformer timestamp level data into id level data with vocab columns.\"\"\"\ndef __init__(\nself,\nid_col: str,\ntimestamp_col: str,\nadditional_groups: Optional[List[str]] = None,\ncols: Optional[List[str]] = None,\n) -&gt; None:\nself.id_col = id_col\nself.timestamp_col = timestamp_col\nself.additional_groups = additional_groups\nself.cols = cols\ndef fit(self, X: pd.DataFrame, y=None):\n# New features at same index level\nself.features = create_timestamp_feature_pipeline(\nself.timestamp_col,\n)\ngroups = [self.id_col]\nif self.additional_groups is not None:\nif not isinstance(self.additional_groups, list):\nraise ValueError(\nf\"additional_groups should be list not {type(self.additional_groups)}\"\n)\ngroups.extend(self.additional_groups)\ngroups.append(\"vocab\")\n# Reaggregation\nself.aggregation = VocabAggregation(groups=groups, cols=self.cols)\n# Unstacking\nself.widden = LongToWide(col=\"num_events\")\n# Since nothing needs to be \"fit\"\nreturn self\ndef transform(self, X: pd.DataFrame, y=None) -&gt; pd.DataFrame:\nX_trans = self.features.transform(X)\nX_agg = self.aggregation.transform(X_trans)\nreturn self.widden.transform(X_agg)\n</code></pre>"},{"location":"modules/transformers/#latent_calendar.transformers.VocabAggregation","title":"<code>VocabAggregation</code>","text":"<p>             Bases: <code>BaseEstimator</code>, <code>TransformerMixin</code></p> <p>NOTE: The index of the grouping stays.</p> Source code in <code>latent_calendar/transformers.py</code> <pre><code>class VocabAggregation(BaseEstimator, TransformerMixin):\n\"\"\"NOTE: The index of the grouping stays.\"\"\"\ndef __init__(self, groups: List[str], cols: Optional[List[str]] = None) -&gt; None:\nself.groups = groups\nself.cols = cols\ndef fit(self, X: pd.DataFrame, y=None):\nreturn self\ndef transform(self, X: pd.DataFrame, y=None):\nstats = {}\nif self.cols is not None:\nstats.update({col: (col, \"sum\") for col in self.cols})\ndf_agg = (\nX.assign(num_events=1)\n.groupby(self.groups)\n.agg(num_events=(\"num_events\", \"sum\"), **stats)\n)\nself.columns = list(df_agg.columns)\nreturn df_agg\ndef get_feature_names_out(self, input_features=None):\nreturn self.columns\n</code></pre>"},{"location":"modules/transformers/#latent_calendar.transformers.VocabTransformer","title":"<code>VocabTransformer</code>","text":"<p>             Bases: <code>BaseEstimator</code>, <code>TransformerMixin</code></p> <p>Create a vocab column from the day of week and hour columns.</p> Source code in <code>latent_calendar/transformers.py</code> <pre><code>class VocabTransformer(BaseEstimator, TransformerMixin):\n\"\"\"Create a vocab column from the day of week and hour columns.\"\"\"\ndef __init__(\nself, day_of_week_col: str = \"day_of_week\", hour_col: str = \"hour\"\n) -&gt; None:\nself.day_of_week_col = day_of_week_col\nself.hour_col = hour_col\ndef fit(self, X: pd.DataFrame, y=None):\nreturn self\ndef transform(self, X: pd.DataFrame, y=None) -&gt; pd.DataFrame:\nX[\"vocab\"] = (\nX[self.day_of_week_col]\n.astype(str)\n.str.zfill(2)\n.str.cat(X[self.hour_col].astype(str).str.zfill(2), sep=\" \")\n)\nself.columns = list(X.columns)\nreturn X\ndef get_feature_names_out(self, input_features=None):\nreturn self.columns\n</code></pre>"},{"location":"modules/transformers/#latent_calendar.transformers.create_raw_to_vocab_transformer","title":"<code>create_raw_to_vocab_transformer(id_col, timestamp_col, additional_groups=None)</code>","text":"<p>Wrapper to create the transformer from the configuration options.</p> Source code in <code>latent_calendar/transformers.py</code> <pre><code>def create_raw_to_vocab_transformer(\nid_col: str,\ntimestamp_col: str,\nadditional_groups: Optional[List[str]] = None,\n) -&gt; RawToVocab:\n\"\"\"Wrapper to create the transformer from the configuration options.\"\"\"\nreturn RawToVocab(\nid_col=id_col,\ntimestamp_col=timestamp_col,\nadditional_groups=additional_groups,\n)\n</code></pre>"},{"location":"modules/transformers/#latent_calendar.transformers.create_timestamp_feature_pipeline","title":"<code>create_timestamp_feature_pipeline(timestamp_col)</code>","text":"<p>Create a pipeline that creates features from the timestamp column.</p> <p>Parameters:</p> Name Type Description Default <code>timestamp_col</code> <code>str</code> <p>The name of the timestamp column.</p> required <p>Returns:</p> Type Description <code>Pipeline</code> <p>A pipeline that creates features from the timestamp column.</p> Example <p>Create features for the online transactions dataset.</p> <pre><code>from latent_calendar.datasets import load_online_transactions\ndf = load_online_transactions()\ntransformers = create_timestamp_feature_pipeline(timestamp_col=\"InvoiceDate\")\ndf_features = transformers.fit_transform(df)\n</code></pre> Source code in <code>latent_calendar/transformers.py</code> <pre><code>def create_timestamp_feature_pipeline(\ntimestamp_col: str,\n) -&gt; Pipeline:\n\"\"\"Create a pipeline that creates features from the timestamp column.\n    Args:\n        timestamp_col: The name of the timestamp column.\n    Returns:\n        A pipeline that creates features from the timestamp column.\n    Example:\n        Create features for the online transactions dataset.\n        ```python\n        from latent_calendar.datasets import load_online_transactions\n        df = load_online_transactions()\n        transformers = create_timestamp_feature_pipeline(timestamp_col=\"InvoiceDate\")\n        df_features = transformers.fit_transform(df)\n        ```\n    \"\"\"\nvocab_col = \"hour\"\nreturn Pipeline(\n[\n(\n\"timestamp_features\",\nCalandarTimestampFeatures(timestamp_col=timestamp_col),\n),\n(\"binning\", HourDiscretizer(col=vocab_col)),\n(\"vocab_creation\", VocabTransformer(hour_col=vocab_col)),\n]\n).set_output(transform=\"pandas\")\n</code></pre>"},{"location":"modules/transformers/#latent_calendar.transformers.prop_into_day","title":"<code>prop_into_day(dt)</code>","text":"<p>Returns the proportion into the day from datetime like object.</p> <p>0.0 is midnight and 1.0 is midnight again.</p> <p>Parameters:</p> Name Type Description Default <code>dt</code> <code>Union[datetime, DatetimeProperties]</code> <p>datetime like object</p> required <p>Returns:</p> Type Description <code>Union[float, pd.Series]</code> <p>numeric value(s) between 0.0 and 1.0</p> Source code in <code>latent_calendar/transformers.py</code> <pre><code>def prop_into_day(dt: Union[datetime, DatetimeProperties]) -&gt; Union[float, pd.Series]:\n\"\"\"Returns the proportion into the day from datetime like object.\n    0.0 is midnight and 1.0 is midnight again.\n    Args:\n        dt: datetime like object\n    Returns:\n        numeric value(s) between 0.0 and 1.0\n    \"\"\"\nprop_hour = dt.hour / HOURS_IN_DAY\nprop_minute = dt.minute / MINUTES_IN_DAY\nprop_second = dt.second / SECONDS_IN_DAY\nprop_microsecond = dt.microsecond / MICROSECONDS_IN_DAY\nreturn prop_hour + prop_minute + prop_second + prop_microsecond\n</code></pre>"}]}