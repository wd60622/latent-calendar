{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Latent Calendar","text":"<p>Analyze and model data on a weekly calendar</p>"},{"location":"#installation","title":"Installation","text":"<p>Install from PyPI:</p> <pre><code>pip install latent-calendar\n</code></pre> <p>Or install directly from GitHub for the latest functionality.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Integrated automatically into <code>pandas</code> with <code>cal</code> attribute on DataFrames and Series</li> <li>Compatible with <code>scikit-learn</code> pipelines and transformers</li> <li>Transform and visualize data on a weekly calendar</li> <li>Model weekly calendar data with a mixture of calendars</li> <li>Create lower dimensional representations of calendar data</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>from latent_calendar.datasets import load_chicago_bikes\nfrom latent_calendar import LatentCalendar\nfrom latent_calendar.plot import plot_model_components\n\nimport matplotlib.pyplot as plt\n\ndf_trips = load_chicago_bikes()\ndf_stations = df_trips.cal.aggregate_events(\"start_station_name\", \"started_at\", minutes=60)\n\nmodel = LatentCalendar(n_components=10, random_state=42)\nmodel.fit(df_stations)\n\norder = model.component_distribution_.argsort()[::-1]\nplot_model_components(model, components=order)\nfirst_date, last_date = df_trips[\"started_at\"].min().date(), df_trips[\"started_at\"].max().date()\ntitle = f\"Trip behavior between {first_date} and {last_date} (ordered by component frequency)\"\nplt.suptitle(title)\n</code></pre>"},{"location":"draft/","title":"Draft","text":""},{"location":"draft/#1-transform-and-visualize","title":"1. Transform and visualize","text":"<p>Transform and visualize data on a weekly calendar with the <code>cal</code> attribute of DataFrames.</p> <pre><code>import matplotlib.pyplot as plt\n\nfrom latent_calendar.datasets import load_chicago_bikes\n\ndf = load_chicago_bikes()\ndf_member_casual = df.cal.aggregate_events(\"member_casual\", timestamp_col=\"started_at\")\n\n(\n    df_member_casual\n    .cal.normalize(\"max\")\n    .cal.plot_by_row()\n)\nfig = plt.gcf()\nfig.suptitle(\"Bike Rentals by Member Type\")\nplt.show()\n</code></pre> <p></p>"},{"location":"draft/#2-find-latent-structure","title":"2. Find latent structure","text":"<p>The <code>LatentCalendar</code> models calendar data by breaking down each calendar into a mixture of <code>n_components</code> calendars. Read more on the methodology here.</p> <pre><code>from latent_calendar import LatentCalendar\nfrom latent_calendar.plot import plot_model_components\n\ndf_stations = df.cal.aggregate_events(\"start_station_name\", timestamp_col=\"started_at\")\n\nmodel = LatentCalendar(n_components=3, random_state=42)\nmodel.fit(df_wide)\n\nplot_model_components(model)\nfig = plt.gcf()\nfig.suptitle(\"Chicago Bike Rental Model Components\")\nplt.show()\n</code></pre> <p></p>"},{"location":"draft/#3-recover-components-and-distributions","title":"3. Recover components and distributions","text":"<p>The <code>LatentCalendar</code> provides soft clusters for each row which can be recovered with the <code>transform</code> method.</p> <pre><code>df_component_probs = df_stations.cal.transform(model=model)\n\nhist_kwargs = dict(bins=10, edgecolor=\"black\", grid=False, layout=(1, 3))\naxes = df_component_probs.hist(**hist_kwargs)\naxes = axes.ravel()\nfor ax in axes:\n    ax.set_xlabel(\"Probability\")\n    title = ax.get_title()\n    ax.set_title(f\"Component {title}\")\naxes[0].set_ylabel(\"# Stations\")\nfig = plt.gcf()\nfig.suptitle(\"Station Component Distributions\")\nplt.show()\n</code></pre> <p></p> <p>The <code>predict</code> method recovers the joint distribution of the calendar data using the latent calendar components.</p> <pre><code>stations = [\"Wood St &amp; Milwaukee Ave\", \"Theater on the Lake\", \"Wabash Ave &amp; Grand Ave\"]\ndf_stations.loc[stations].cal.plot_profile()\nplt.show()\n</code></pre> <p></p>"},{"location":"methodology/","title":"Methodology","text":""},{"location":"methodology/#multinomial-distribution-from-events-on-calendar","title":"Multinomial Distribution from Events on Calendar","text":"<p>With \\(D = \\text{Day of Week}\\) with \\(d \\in \\{\\text{Monday}, \\text{Tuesday}, ..., \\text{Sunday}\\}\\) and \\(T = \\text{Time of Day}\\) with \\(t \\in [0, 24)\\), we are interested in the joint distribution of the \\(P(D=d, T=t)\\).</p> <p>However, if we discretize \\(T\\) into \\(H = \\text{Hour of Day}\\) which takes values \\(h \\in \\{0, 1, 2, ..., 23\\}\\), we get a discrete approximation of the distribution, \\(P[D=d, H=h]\\)</p> <p></p> <p>Introducing the number of events, \\(N\\), we can express this quantity as</p> \\[P[D=d, H=h] = \\sum_{n=0}^{\\infty} P[N=n] \\times P[D=d, H=h | N=n]\\] <p>having</p> \\[\\sum_{d, h \\in D \\times H} N(d, h) = n\\] <p>where \\(N(d, h)\\) is the number of events at \\(D=d\\), \\(H=h\\).</p> <p>This is two quantities now:</p> <ol> <li>How many events will happen: \\(P[N=n]\\)</li> <li>When on the calendar will these events happen: \\(P[D=d, H=h | N=n]\\)</li> </ol> <p>But since the day of week and time of day make up a discrete space of \"time slots\", we can use the multinomial distribution to model quantity 2.</p> <p></p>"},{"location":"methodology/#linking-to-latent-dirichlet-allocation","title":"Linking to Latent Dirichlet Allocation","text":"<p>The generative model for Latent Dirichlet Allocation is a mixture of multinomial distributions allowing us to introduce \\(c\\) calendar distributions.</p> \\[P[D=d, H=h | N=n] = \\sum_{l=1}^c P[L=l | N=n] \\times P[D=d, H=h | L=l, N=n]\\] <ol> <li>\\(P[L=l | N=n]\\) is the probability of being latent component</li> <li>\\(P[D=d, H=h | L=l, N=n]\\) is the calendar from latent component \\(l\\)</li> </ol> <p>By introducing latent calendar distributions, we introduce correlations between the time slots.</p>"},{"location":"examples/cal-attribute/","title":"Pandas Extensions","text":"<p>Transform and visualize data on a weekly calendar with the <code>cal</code> attribute of DataFrames.</p>"},{"location":"examples/cal-attribute/#event-level-data","title":"Event Level Data","text":"<pre><code>import matplotlib.pyplot as plt\n\nfrom latent_calendar.datasets import load_chicago_bikes\n\ndf = load_chicago_bikes()\ndf.head()\n</code></pre> <pre><code>                 start_station_name end_station_name  rideable_type          started_at            ended_at member_casual\nride_id\nABF4F851DE485B76                NaN              NaN  electric_bike 2023-06-30 18:56:13 2023-06-30 19:30:40        member\nF123B5D34B002CDB                NaN              NaN  electric_bike 2023-06-30 06:12:31 2023-06-30 06:23:05        member\nCA8E2C38AF641DFB                NaN              NaN  electric_bike 2023-06-30 08:28:51 2023-06-30 08:37:45        member\n93CCE4EA48CFDB69                NaN              NaN  electric_bike 2023-06-30 09:09:24 2023-06-30 09:17:41        member\nFDBCEFE7890F7262                NaN              NaN  electric_bike 2023-06-30 16:29:48 2023-06-30 16:38:51        member\n</code></pre>"},{"location":"examples/cal-attribute/#calendar-data","title":"Calendar Data","text":"<p>Aggregate event level data into wide format calendar data with the <code>cal.aggregate_events</code> method. This results in 7 * 24 = 168 columns, one for each hour of the week.</p> <pre><code>df_member_casual = df.cal.aggregate_events(\"member_casual\", \"started_at\")\n</code></pre> <pre><code>day_of_week      0                              ...     6\nhour            0    1    2   3   4    5    6   ...    17    18    19    20   21   22   23\nmember_casual                                   ...\ncasual         250  137  102  55  47   99  231  ...  1287  1195  1165   980  774  488  331\nmember         165   89   74  52  59  273  838  ...  1307  1355  1251  1137  800  505  294\n\n[2 rows x 168 columns]\n</code></pre>"},{"location":"examples/cal-attribute/#visualize-calendar-data","title":"Visualize Calendar Data","text":"<p>Various plot methods are available on the <code>cal</code> attribute of DataFrames. For instance, the <code>plot_by_row</code> plots each row of the wide format calendar data as a separate calendar.</p> <p>Custom color maps can be passed, but normalizing each row by the maximum value also does the trick.</p> <pre><code>(\n    df_member_casual\n    .cal.normalize(\"max\")\n    .cal.plot_by_row()\n)\nfig = plt.gcf()\nfig.suptitle(\"Bike Rentals by Member Type\")\nplt.show()\n</code></pre> <p></p>"},{"location":"examples/create-segments/","title":"Create segments","text":"<p>Create some segments for a calendar:</p> <pre><code>import pandas as pd\nimport numpy as np\n\nfrom latent_calendar.segments import create_box_segment, stack_segments\n\nmornings = create_box_segment(\n    day_start=0, day_end=7, hour_start=6, hour_end=11, name=\"Mornings\"\n)\nafternoons = create_box_segment(\n    day_start=0, day_end=7, hour_start=11, hour_end=16, name=\"Afternoons\"\n)\nevenings = create_box_segment(\n    day_start=0, day_end=7, hour_start=16, hour_end=21, name=\"Evenings\"\n)\n\ndf_segments = stack_segments([\n    mornings,\n    afternoons,\n    evenings,\n])\n\ndf_segments.cal.plot_by_row()\n</code></pre> <p></p> <p>These can be used to sum over for analysis of counts or probabilities by segment.</p> <pre><code>nrows = 10\nncols = len(df_segments.columns)\n\ndf = pd.DataFrame(np.ones((nrows, ncols)))\n\ndf_summed = df.cal.sum_over_segments(df_segments)\ndf_summed\n</code></pre> <pre><code>   Mornings  Afternoons  Evenings\n0      35.0        35.0      35.0\n1      35.0        35.0      35.0\n2      35.0        35.0      35.0\n3      35.0        35.0      35.0\n4      35.0        35.0      35.0\n5      35.0        35.0      35.0\n6      35.0        35.0      35.0\n7      35.0        35.0      35.0\n8      35.0        35.0      35.0\n9      35.0        35.0      35.0\n</code></pre>"},{"location":"examples/generation-process/","title":"Generation process","text":"<p>Some sample data can be generated with the <code>sample_from_lda</code> function. More to come!</p>"},{"location":"examples/datasets/bikes-in-chicago/","title":"Bikes in Chicago","text":"<p>The Chicago dataset is bike trips in the city of Chicago.</p> <pre><code>import pandas as pd\n\nimport matplotlib.pyplot as plt\n\nfrom latent_calendar.datasets import load_chicago_bikes\nfrom latent_calendar.plot.elements import CalendarEvent\n\ndf = load_chicago_bikes()\ndf.head()\n</code></pre> <pre><code>                 start_station_name end_station_name  rideable_type          started_at            ended_at member_casual\nride_id\nABF4F851DE485B76                NaN              NaN  electric_bike 2023-06-30 18:56:13 2023-06-30 19:30:40        member\nF123B5D34B002CDB                NaN              NaN  electric_bike 2023-06-30 06:12:31 2023-06-30 06:23:05        member\nCA8E2C38AF641DFB                NaN              NaN  electric_bike 2023-06-30 08:28:51 2023-06-30 08:37:45        member\n93CCE4EA48CFDB69                NaN              NaN  electric_bike 2023-06-30 09:09:24 2023-06-30 09:17:41        member\nFDBCEFE7890F7262                NaN              NaN  electric_bike 2023-06-30 16:29:48 2023-06-30 16:38:51        member\n</code></pre> <p>This dataset is two weeks of data starting at the end of June 2023. We can easily see this by plotting it as a calendar grouped by the week of year.</p> <pre><code># Map the week number to a human readable label\ndf[\"week_number\"] = df[\"started_at\"].dt.isocalendar().week\n\n# Bit scary but just trying to make a nice label\ndef create_label(df: pd.DataFrame) -&gt; pd.Series:\n    first_date = df[\"first_date\"]\n    last_date = df[\"last_date\"]\n    return first_date.dt.date.astype(str).str.cat(\n        last_date.dt.date.astype(str), sep=\" until \"\n    )\n\nlabel = (\n    df.groupby(\"week_number\")\n    .agg(first_date=(\"started_at\", \"min\"), last_date=(\"started_at\", \"max\"))\n    .pipe(create_label)\n)\ndf[\"week_of_year\"] = df[\"week_number\"].map(label.to_dict())\n\ndf_wide = df.cal.aggregate_events(\"week_of_year\", \"started_at\")\n\n(\n    df_wide\n    .cal.normalize(\"max\")\n    .cal.plot_by_row()\n)\nfig = plt.gcf()\nfig.suptitle(\"Two week of bike rides in Chicago\")\nplt.show()\n</code></pre> <p>We are able to understand that the data is two weeks of data starting at the end of June 2023, but also see that there is heavy influence from the July 4 holiday weekend. People have off work and this is reflected in the data.</p> <p></p> <p>Though the holiday effect around the 4th, there seems to be a lower volume the Sunday before and after work the day after. Interestingly enough, there was a rain storm on the weekend and  another storm the Wednesday the 4th. We can mark this on the calendar for reference.</p> <pre><code>def create_plot_storms_func(first_storm: CalendarEvent, second_storm: CalendarEvent):\n    def plot_storms(first_week_ax: plt.Axes, second_week_ax: plt.Axes):\n        alpha = 0.15\n        first_storm.plot(ax=first_week_ax, facecolor=\"blue\", alpha=alpha, label=\"rain storm\")\n        second_storm.plot(ax=second_week_ax, facecolor=\"blue\", alpha=alpha, label=\"rain storm\")\n        first_week_ax.legend()\n        second_week_ax.legend()\n\n    return plot_storms\n\nfirst_storm = CalendarEvent(day=6, start=7, end=18)\nsecond_storm = CalendarEvent(day=2, start=17, end=22)\nplot_storms = create_plot_storms_func(first_storm, second_storm)\n\n(\n    df_wide\n    .cal.normalize(\"max\")\n    .cal.plot_by_row()\n)\nfig = plt.gcf()\nfig.suptitle(\"Two week of bike rides in Chicago\")\n\n\nplot_storms(fig.axes[0], fig.axes[1])\nplt.show()\n</code></pre> <p></p> <p>Let's break it down further by adding the <code>member_casual</code> column to the aggregation.</p> <pre><code>df_wide = df.cal.aggregate_events([\"member_casual\", \"week_of_year\"], \"started_at\")\n\n\ndef title_func(idx, row) -&gt; str:\n    group, week = idx\n\n    return f\"{group} - {week}\"\n\n\n(\n    df_wide\n    .cal.normalize(\"max\")\n    .cal.plot_by_row(max_cols=2, title_func=title_func)\n)\nfig = plt.gcf()\nfig.suptitle(\"Two week of bike rides in Chicago\")\n\naxes = fig.axes\n\nplot_storms(axes[0], axes[1])\nplot_storms(axes[2], axes[3])\n\nplt.show()\n</code></pre> <p>We can see that the holiday weekend has heavy volume from the casual riders showing on the Monday and Tuesday of the holiday weekend. Not only that, but the members that use the bikes heavily to commute shift their usage with this holiday too.</p> <p></p> <p>The effect of rain can be investigated by sum the trips that happen during the day time. We can do this by creating a segment for each day of the week between the hours of 7am and 6pm, the time of the Sunday storm.</p> <pre><code>from latent_calendar.vocab import DOWHour\nfrom latent_calendar.segments.hand_picked import create_series_for_range, stack_segments\n\nall_daytime_rain = stack_segments([\n    create_series_for_range(\n        start=DOWHour(dow=dow, hour=7), end=DOWHour(dow=dow, hour=18)\n    ).rename(f\"all_daytime_{dow}\")\n    for dow in range(7)\n])\n\ndf_volume = df_wide.cal.sum_over_segments(all_daytime_rain)\n</code></pre> <p>These are the row totals between the hours of 7am and 6pm for each day of the week at the same index level as before.</p> <pre><code>                                           all_daytime_0  all_daytime_1  all_daytime_2  all_daytime_3  all_daytime_4  all_daytime_5  all_daytime_6\nmember_casual week_of_year\ncasual        2023-06-26 until 2023-07-02           3887           4086           4634           4012           6647           8213            481\n              2023-07-03 until 2023-07-09           8946          10868           4523           5616           6920           6802           9643\nmember        2023-06-26 until 2023-07-02           7949           8960           9043           7852           9242           7663            822\n              2023-07-03 until 2023-07-09           9105           8239           8511           9989           9873           7846           9573\n</code></pre> <p>Visualizing this data, we can see the heavy impact of the Sunday weather for casual riders and members alike but not enough to ruin the holiday weekend.</p> <pre><code>def replace_index(ser: pd.Series, index: pd.Index) -&gt; pd.Series:\n    ser.index = index\n    return ser\n\nstart_date = df[\"started_at\"].min().date()\nend_date = df[\"started_at\"].max().date()\ndates = pd.date_range(start_date, end_date, freq=\"D\")\n\nax = (\n    df_volume\n    .stack()\n    .unstack(0)\n    .pipe(replace_index, index=dates)\n    .plot()\n)\nax.set(\n    ylabel=\"# trips\",\n    title=\"Trips between 7am and 6pm\",\n    ylim=(0, None),\n)\nax.legend(title=\"customer type\")\nplt.show()\n</code></pre> <p></p>"},{"location":"examples/datasets/store-transactions/","title":"Store transactions","text":"<pre><code>import matplotlib.pyplot as plt\n\nfrom latent_calendar.datasets import load_online_transactions\n\ndf = load_online_transactions()\ndf.head()\n</code></pre> <pre><code>  Invoice StockCode                          Description  Quantity         InvoiceDate  Price  Customer ID         Country\n0  489434     85048  15CM CHRISTMAS GLASS BALL 20 LIGHTS        12 2009-12-01 07:45:00   6.95      13085.0  United Kingdom\n1  489434    79323P                   PINK CHERRY LIGHTS        12 2009-12-01 07:45:00   6.75      13085.0  United Kingdom\n2  489434    79323W                  WHITE CHERRY LIGHTS        12 2009-12-01 07:45:00   6.75      13085.0  United Kingdom\n3  489434     22041         RECORD FRAME 7\" SINGLE SIZE         48 2009-12-01 07:45:00   2.10      13085.0  United Kingdom\n4  489434     21232       STRAWBERRY CERAMIC TRINKET BOX        24 2009-12-01 07:45:00   1.25      13085.0  United Kingdom\n</code></pre> <p>By default, a new <code>cal</code> attribute will be added to DataFrames given access to module functionality.</p> <pre><code>df_wide = df.cal.aggregate_events(\"Country\", \"InvoiceDate\")\n\ndf_wide.head()\n</code></pre> <pre><code>day_of_week  0                                                                                  1     ...  5     6\nhour        0  1  2  3  4  5  6  7   8   9   10  11   12  13  14   15  16 17 18 19 20 21 22 23 0  1   ... 22 23 0  1  2  3  4  5  6  7  8  9   10  11  12  13  14   15 16 17 18 19 20 21 22 23\nCountry                                                                                               ...\nAustralia    0  0  0  0  0  0  0  0   0  27   6  19   20   7   2  105  27  0  0  0  0  0  0  0  0  0  ...  0  0  0  0  0  0  0  0  0  0  0  0  11  37  20   0  16    0  0  0  0  0  0  0  0  0\nAustria      0  0  0  0  0  0  0  0   9  55  81   0   18   0   0   33   0  0  0  0  0  0  0  0  0  0  ...  0  0  0  0  0  0  0  0  0  0  0  0   0   0   0   0  37    0  0  0  0  0  0  0  0  0\nBahrain      0  0  0  0  0  0  0  0   0   0   1   6    0  13   0    0   0  0  0  0  0  0  0  0  0  0  ...  0  0  0  0  0  0  0  0  0  0  0  0   0   0   0   0   0    0  0  0  0  0  0  0  0  0\nBelgium      0  0  0  0  0  0  0  0  15  15  42  26  109  54  38   17  26  0  0  0  0  0  0  0  0  0  ...  0  0  0  0  0  0  0  0  0  0  0  0  18  20  28  41   0  131  0  0  0  0  0  0  0  0\nBermuda      0  0  0  0  0  0  0  0   0   0   0   0    0   0   0    0   0  0  0  0  0  0  0  0  0  0  ...  0  0  0  0  0  0  0  0  0  0  0  0   0   0   0   0   0    0  0  0  0  0  0  0  0  0\n\n[5 rows x 168 columns]\n</code></pre> <p>We can clearly see the weekly hours of operation for these countries. Even though these are online transactions, these hours affect the transaction times.</p> <p>The slight shift in hours for the UK might be the difference in time zones between the UK and the other countries. Maybe it could be difference in buying patterns of these populations. Not sure but this visual gives us a good glance at the data and starting point to ask questions</p> <pre><code>countries = [\"United Kingdom\", \"Germany\", \"France\"]\n\n(\n    df_wide\n    .loc[countries]\n    .cal.normalize(\"max\")\n    .cal.plot_by_row()\n)\nfig = plt.gcf()\nfig.suptitle(\"Store Transactions by Country\")\nplt.show()\n</code></pre> <p></p>"},{"location":"examples/datasets/ufo-sightings/","title":"UFO Sightings","text":"<pre><code>import matplotlib.pyplot as plt\n\nfrom latent_calendar.datasets import load_ufo_sightings\n\ndf = load_ufo_sightings()\n</code></pre> <p>Each row of the dataset is a UFO sighting somewhere around the world.</p> <pre><code>            Date_time                  city state/province country  ...                                        description date_documented    latitude   longitude\n0 1949-10-10 20:30:00            san marcos             tx      us  ...  This event took place in early fall around 194...       4/27/2004  29.8830556  -97.941111\n1 1949-10-10 21:00:00          lackland afb             tx     NaN  ...  1949 Lackland AFB&amp;#44 TX.  Lights racing acros...      12/16/2005    29.38421  -98.581082\n2 1955-10-10 17:00:00  chester (uk/england)            NaN      gb  ...  Green/Orange circular disc over Chester&amp;#44 En...       1/21/2008        53.2   -2.916667\n3 1956-10-10 21:00:00                  edna             tx      us  ...  My older brother and twin sister were leaving ...       1/17/2004  28.9783333  -96.645833\n4 1960-10-10 20:00:00               kaneohe             hi      us  ...  AS a Marine 1st Lt. flying an FJ4B fighter/att...       1/22/2004  21.4180556 -157.803611\n\n[5 rows x 11 columns]\n</code></pre> <pre><code>df[\"year\"] = df[\"Date_time\"].dt.year\n\ndf_wide = df.cal.aggregate_events(\"year\", \"Date_time\")\n\ndf_5_year = df_wide.tail(5)\n</code></pre> <p>which has the data in the wide format where each row is a weekly calendar.</p> <pre><code>day_of_week  0                                                                                  1     ...  5     6\nhour        0  1  2  3  4  5  6  7   8   9   10  11   12  13  14   15  16 17 18 19 20 21 22 23 0  1   ... 22 23 0  1  2  3  4  5  6  7  8  9   10  11  12  13  14   15 16 17 18 19 20 21 22 23\nCountry                                                                                               ...\nAustralia    0  0  0  0  0  0  0  0   0  27   6  19   20   7   2  105  27  0  0  0  0  0  0  0  0  0  ...  0  0  0  0  0  0  0  0  0  0  0  0  11  37  20   0  16    0  0  0  0  0  0  0  0  0\nAustria      0  0  0  0  0  0  0  0   9  55  81   0   18   0   0   33   0  0  0  0  0  0  0  0  0  0  ...  0  0  0  0  0  0  0  0  0  0  0  0   0   0   0   0  37    0  0  0  0  0  0  0  0  0\nBahrain      0  0  0  0  0  0  0  0   0   0   1   6    0  13   0    0   0  0  0  0  0  0  0  0  0  0  ...  0  0  0  0  0  0  0  0  0  0  0  0   0   0   0   0   0    0  0  0  0  0  0  0  0  0\nBelgium      0  0  0  0  0  0  0  0  15  15  42  26  109  54  38   17  26  0  0  0  0  0  0  0  0  0  ...  0  0  0  0  0  0  0  0  0  0  0  0  18  20  28  41   0  131  0  0  0  0  0  0  0  0\nBermuda      0  0  0  0  0  0  0  0   0   0   0   0    0   0   0    0   0  0  0  0  0  0  0  0  0  0  ...  0  0  0  0  0  0  0  0  0  0  0  0   0   0   0   0   0    0  0  0  0  0  0  0  0  0\n\n[5 rows x 168 columns]\n</code></pre> <p>We can make use the <code>cal</code> attribute further to plot an aggregate of the data and plots of the data by day of week and hour of day.</p> <pre><code>fig, axes = plt.subplots(ncols=3)\n\ndf_5_year.sum().cal.plot_row(ax=axes[0])\n\naxes[0].set(\n    title=\"Weekly UFO sightings\",\n)\n\nfor aggregation, ax in zip([\"dow\", \"hour\"], axes.ravel()[1:]):\n    (\n        df_5_year\n        .cal.sum_over_vocab(aggregation=aggregation)\n        .cal.normalize(\"probs\")\n        .mul(100)\n        .T.plot(ax=ax)\n    )\n    ymax = ax.get_ylim()[1]\n    ax.set_ylim(0, ymax * 1.1)\n\naxes[1].set_xticks(axes[0].get_xticks())\n\naxes[1].set(\n    title=\"Chance of UFO sighting by day of week\",\n    xlabel=\"Day of week\",\n    ylabel=\"Chance of UFO sighting (%)\",\n)\naxes[2].set(\n    title=\"Chance of UFO sighting by hour of day\",\n    xlabel=\"Hour of day\",\n    ylabel=\"\",\n)\nfig.suptitle(\"UFO sightings over 5 years\")\nplt.show()\n</code></pre> <p></p>"},{"location":"examples/model/sklearn-compat/","title":"Scikit-Learn Compatibility","text":"<p>The <code>LatentCalendar</code> class is <code>scikit-learn</code> compatible making it very easy to integrate into your existing machine learning pipelines.</p> <p>Here are a few examples but feel free to get creative and combine them all together!</p>"},{"location":"examples/model/sklearn-compat/#pipelines","title":"Pipelines","text":"<p><code>LatentCalendar</code> can be used in <code>scikit-learn</code> pipelines. The <code>tranform</code> method will be used based on the <code>TransformerMixin</code> base of <code>LatentDirichletAllocation</code>.</p> <pre><code>from sklearn.pipeline import Pipeline\nfrom sklearn.mixture import GaussianMixture\n\nfrom latent_calendar import LatentCalendar\n\n\ndef create_hard_clustering_pipeline(n_components: int) -&gt; Pipeline:\n    gaussian_components = n_components ** 2 - 1\n    return Pipeline(\n        [\n            (\"latent_calendar\", LatentCalendar(n_components=n_components)),\n            (\"gaussian_mixture\", GaussianMixture(n_components=gaussian_components)),\n        ]\n    )\n\npipeline = create_hard_clustering_pipeline(n_components=3)\npipeline.fit(df_wide)\n\n# Hard cluster labels\npipline.predict(df_wide)\n</code></pre>"},{"location":"examples/model/sklearn-compat/#columntransformer","title":"ColumnTransformer","text":"<p>Similar with <code>Pipeline</code>s, the <code>transform</code> method will be used.</p> <pre><code>from sklearn.compose import ColumnTransformer\n\nvocab_columns = df_wide.columns.tolist()\n\ndf_wide[\"total_events\"] = df_wide.sum(axis=1)\n\ntransformer = ColumnTransformer(\n    [\n        (\"latent_calendar\", LatentCalendar(n_components=3), vocab_columns),\n    ], remainder=\"passthrough\"\n)\n\ntransformer = transformer.fit(df_wide)\n</code></pre>"},{"location":"examples/model/sklearn-compat/#other-transformers","title":"Other Transformers","text":"<pre><code>import pandas as pd\n\nfrom sklearn.base import BaseEstimator, TransformerMixin\nfrom sklearn.pipeline import Pipeline\n\nclass RemoveLowVolumeTimeSlots(BaseEstimator, TransformerMixin):\n    def __init__(self, model: LatentCalendar, min_count: int):\n        self.model = model\n        self.min_count = min_count\n\n    def fit(self, X: pd.DataFrame, y=None) -&gt; \"RemoveLowVolumeTimeSlots\":\n        self.original_columns = X.columns\n\n        column_counts = X.sum()\n        self.columns_to_keep = column_counts[column_counts &gt; self.min_count].index\n\n        self.model.fit(X.loc[:, self.columns_to_keep])\n\n        return self\n\n    def transform(self, X: pd.DataFrame, y=None) -&gt; pd.DataFrame:\n        return self.model.predict(X.loc[:, self.columns_to_keep])\n\n    def predict(self, X: pd.DataFrame, y=None) -&gt; pd.DataFrame:\n        X_pred = self.model.predict(X.loc[:, self.columns_to_keep])\n        return X_pred.reindex(self.original_columns, fill_value=0, axis=1)\n\n\nmodel = LatentCalendar(n_components=3)\ntransformer = RemoveLowVolumeTimeSlots(model=model, min_count=10)\ntransformer.fit(df_wide)\n</code></pre>"},{"location":"examples/plotting/add-calendar-events/","title":"Add calendar events","text":"<p>Can use the <code>CalendarEvent</code> class to add arbitrary events to calendar.</p> <p>The constructor takes a day of week, start time, an end time or duration, and number of days.</p> <p>The <code>plot</code> method takes a <code>plt.Axes</code> and allows for customization with additional keyword arguments</p> <pre><code>import matplotlib.pyplot as plt\n\nfrom latent_calendar.plot import plot_blank_calendar\nfrom latent_calendar.plot.elements import CalendarEvent\n\nax = plot_blank_calendar()\n\nevent = CalendarEvent(\n    day=4, start=12, duration=90,\n)\nevent.plot(ax=ax, label=\"90 minutes\", linestyle=\"--\", alpha=0.25)\n\nevent = CalendarEvent(\n    day=0, start=23, duration=3 * 60,\n)\nevent.plot(ax=ax, label=\"Overnight\", facecolor=\"red\", linestyle=\"dashed\", lw=1.5)\n\nevent = CalendarEvent(\n    day=6, start=17, end=19, days=3,\n)\nevent.plot(ax=ax, label=\"Multiday\", facecolor=\"orange\", linestyle=\"--\")\n\nax.legend()\nplt.show()\n</code></pre> <p></p>"},{"location":"examples/plotting/calendar-customization/","title":"Calendar customization","text":"<p>Each calendar plot is made up of the following components:</p> <ul> <li>X axis (Day of week)</li> <li>Y axis (Time of the day)</li> <li>Grid Lines</li> <li>Events (Rectangles)</li> </ul> <p>The X axis and Y axis have default values but can be customized</p> <pre><code>import matplotlib.pyplot as plt\n\nfrom latent_calendar.plot import plot_blank_calendar\nfrom latent_calendar.plot.elements import DayLabeler, TimeLabeler, GridLines\n\n\nfig, axes = plt.subplots(ncols=2, nrows=2)\nfig.suptitle(\"Calendar Customization\")\n\nax = axes[0, 0]\nplot_blank_calendar(ax=ax)\nax.set_title(\"Default\")\n\nax = axes[0, 1]\nplot_blank_calendar(\n    ax=ax, monday_start=False\n)\nax.set_title(\"Sunday Start\")\n\nax = axes[1, 0]\nday_labeler = DayLabeler(days_of_week=[\"M\", \"T\", \"W\", \"Th\", \"F\", \"Sa\", \"Su\"], rotation=0)\nhour_formatter = lambda hour: f\"{hour}h\"\ntime_labeler = TimeLabeler(hour_formatter=hour_formatter, stride=4)\nplot_blank_calendar(\n    ax=ax,\n    day_labeler=day_labeler,\n    time_labeler=time_labeler,\n)\nax.set_title(\"Custom Labels\")\n\nax = axes[1, 1]\ngrid_lines = GridLines(dow=True, hour=True)\nplot_blank_calendar(\n    ax=ax, grid_lines=grid_lines\n)\nax.set_title(\"Adding Grid Lines\")\n\nplt.show()\n</code></pre> <p></p> <p>Additionally, the labels can be turned off completely. This is done automatically with functions that plot multiple calendars.</p> <pre><code>fig, axes = plt.subplots(ncols=2, nrows=1)\n\nax = axes[0]\nday_labeler = DayLabeler(days_of_week=[\"M\", \"T\", \"W\", \"Th\", \"F\", \"Sa\", \"Su\"], rotation=0, display=False)\nplot_blank_calendar(\n    day_labeler=day_labeler,\n    ax=axes[0]\n)\nax.set(title=\"No Day Labels\")\n\nax = axes[1]\nhour_formatter = lambda hour: f\"{hour}h\"\ntime_labeler = TimeLabeler(hour_formatter=hour_formatter, stride=4, display=False)\nplot_blank_calendar(\n    time_labeler=time_labeler,\n    ax=ax\n)\nax.set(title=\"No Time Labels\")\nplt.show()\n</code></pre> <p></p> <p>This customization is available through the other plotting functions and methods as well. Access them with through the same parameter names.</p> <pre><code>from latent_calendar.segments.hand_picked import create_box_segment, stack_segments\n\nmornings = create_box_segment(\n    hour_start=6,\n    hour_end=11,\n    day_start=0, day_end=7,\n    name=\"mornings\"\n)\n\nevenings = create_box_segment(\n    hour_start=18,\n    hour_end=21,\n    day_start=0, day_end=7,\n    name=\"evenings\"\n)\n\nweekend_daytimes = create_box_segment(\n    hour_start=11,\n    hour_end=18,\n    day_start=5, day_end=7,\n    name=\"weekend daytimes\"\n)\n\ndf_segments = stack_segments([mornings, evenings, weekend_daytimes])\n\n# Plotting\n(\n    df_segments\n    .cal.plot_by_row(\n        day_labeler=day_labeler,\n        time_labeler=time_labeler\n    )\n)\nplt.show()\n</code></pre> <p></p>"},{"location":"examples/plotting/event-frequency/","title":"Event frequency","text":"<p>All number of time slots divisible by 7 (days of the week) are supported for plotting. This is thanks to the <code>plot_calendar</code> function taking an iterable.</p> <pre><code>import numpy as np\n\nimport matplotlib.pyplot as plt\n\nfrom latent_calendar.plot import plot_calendar\nfrom latent_calendar.plot.iterate import iterate_matrix\nfrom latent_calendar.plot.colors import create_default_cmap\n\ntime_slots = [12, 24, 48]\n\nfig, axes = plt.subplots(ncols=len(time_slots))\n\nrng = np.random.default_rng(0)\nfor ts, ax in zip(time_slots, axes.ravel()):\n    data = rng.poisson(lam=1, size=(7, ts))\n\n    cmap = create_default_cmap(data.max())\n    plot_calendar(\n        iterate_matrix(data),\n        cmap=cmap,\n        ax=ax,\n    )\n    ax.set_title(f\"{ts} Time Slots\")\n\nfig.suptitle(\"Calendar Plot with Different # Time Slots\")\nplt.show()\n</code></pre> <p></p>"},{"location":"examples/plotting/pandas-methods/","title":"Pandas methods","text":"<p>DataFrames can be plotted in various ways with the <code>cal</code> attribute.</p> <p>Event level data with the <code>cal.plot</code> or <code>cal.plot_across_column</code></p> <p>Wide data with the <code>cal.plot_by_row</code></p> <p>Check out the methods that start with <code>plot</code> in the Extensions section of the docs.</p>"},{"location":"modules/const/","title":"Const","text":"<p>Constants used to create the full vocabulary of the dataset.</p>"},{"location":"modules/const/#latent_calendar.const.create_full_vocab","title":"<code>create_full_vocab(days_in_week, minutes, as_multiindex=True)</code>","text":"<p>Create the full vocabulary of the dataset.</p> <p>Parameters:</p> Name Type Description Default <code>days_in_week</code> <code>int</code> <p>Number of days in the week.</p> required <code>minutes</code> <code>int</code> <p>Number of minutes to discretize the hours by.</p> required <code>as_multiindex</code> <code>bool</code> <p>Whether to return a multiindex or a list of strings.</p> <code>True</code> <p>Returns:</p> Type Description <code>MultiIndex | list[str]</code> <p>The full vocabulary of the dataset. Either a MultiIndex or a list of strings.</p> Source code in <code>latent_calendar/const.py</code> <pre><code>def create_full_vocab(\n    days_in_week: int,\n    minutes: int,\n    as_multiindex: bool = True,\n) -&gt; pd.MultiIndex | list[str]:\n    \"\"\"Create the full vocabulary of the dataset.\n\n    Args:\n        days_in_week: Number of days in the week.\n        minutes: Number of minutes to discretize the hours by.\n        as_multiindex: Whether to return a multiindex or a list of strings.\n\n    Returns:\n        The full vocabulary of the dataset.\n            Either a MultiIndex or a list of strings.\n\n    \"\"\"\n\n    if not as_multiindex:\n        return [\n            format_dow_hour(day_of_week, hour)\n            for day_of_week, hour in product(\n                range(days_in_week), dicretized_hours(minutes)\n            )\n        ]\n\n    return pd.MultiIndex.from_product(\n        [range(days_in_week), dicretized_hours(minutes)], names=[\"day_of_week\", \"hour\"]\n    )\n</code></pre>"},{"location":"modules/datasets/","title":"Datasets","text":"<p>Example datasets for latent_calendar.</p> <p>All datasets are loaded from the web and cached locally if desired with the <code>local_save</code> argument.</p> <p>The datasets all include one or more columns that represent a datetime that can be used for calendar analysis.</p> <p>Examples:</p> <p>Load the chicago bikes dataset:</p> <pre><code>from latent_calendar.datasets import load_chicago_bikes\n\ndf = load_chicago_bikes()\ndf.head()\n</code></pre> <pre><code>                start_station_name end_station_name  rideable_type          started_at            ended_at member_casual\nride_id\nABF4F851DE485B76                NaN              NaN  electric_bike 2023-06-30 18:56:13 2023-06-30 19:30:40        member\nF123B5D34B002CDB                NaN              NaN  electric_bike 2023-06-30 06:12:31 2023-06-30 06:23:05        member\nCA8E2C38AF641DFB                NaN              NaN  electric_bike 2023-06-30 08:28:51 2023-06-30 08:37:45        member\n93CCE4EA48CFDB69                NaN              NaN  electric_bike 2023-06-30 09:09:24 2023-06-30 09:17:41        member\nFDBCEFE7890F7262                NaN              NaN  electric_bike 2023-06-30 16:29:48 2023-06-30 16:38:51        member\n</code></pre>"},{"location":"modules/datasets/#latent_calendar.datasets.load_chicago_bikes","title":"<code>load_chicago_bikes(local_save=False, **read_kwargs)</code>","text":"<p>Bikesharing trip level data from Chicago's Divvy system.</p> <p>Read more about the data source here.</p> <p>The data is two weeks of trips starting June 26th, 2023 until July 9th, 2023.</p> <p>Parameters:</p> Name Type Description Default <code>local_save</code> <code>bool</code> <p>Whether to save the data locally if it doesn't exists.</p> <code>False</code> <code>read_kwargs</code> <p>kwargs to pass to pd.read_csv</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Trips data from Chicago's Divvy system.</p> Source code in <code>latent_calendar/datasets/__init__.py</code> <pre><code>def load_chicago_bikes(local_save: bool = False, **read_kwargs) -&gt; pd.DataFrame:\n    \"\"\"Bikesharing trip level data from Chicago's Divvy system.\n\n    Read more about the data source [here](https://data.cityofchicago.org/Transportation/Divvy-Trips/fg6s-gzvg).\n\n    The data is two weeks of trips starting June 26th, 2023 until July 9th, 2023.\n\n    Args:\n        local_save: Whether to save the data locally if it doesn't exists.\n        read_kwargs: kwargs to pass to pd.read_csv\n\n    Returns:\n        Trips data from Chicago's Divvy system.\n\n    \"\"\"\n    name = \"chicago-bikes\"\n    read_kwargs = {\n        \"parse_dates\": [\"started_at\", \"ended_at\"],\n        \"index_col\": [\"ride_id\"],\n        **read_kwargs,\n    }\n\n    return _load_data(name, read_kwargs=read_kwargs, local_save=local_save)\n</code></pre>"},{"location":"modules/datasets/#latent_calendar.datasets.load_online_transactions","title":"<code>load_online_transactions(local_save=False, **read_kwargs)</code>","text":"<p>Kaggle Data for an non-store online retailer in UK. More information here.</p> <p>Parameters:</p> Name Type Description Default <code>local_save</code> <code>bool</code> <p>Whether to save the data locally if it doesn't exists.</p> <code>False</code> <code>read_kwargs</code> <p>kwargs to pass to pd.read_csv</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Online transactions data from a non-store online retailer in UK.</p> Source code in <code>latent_calendar/datasets/__init__.py</code> <pre><code>def load_online_transactions(local_save: bool = False, **read_kwargs) -&gt; pd.DataFrame:\n    \"\"\"Kaggle Data for an non-store online retailer in UK. More information [here](https://www.kaggle.com/datasets/mashlyn/online-retail-ii-uci).\n\n    Args:\n        local_save: Whether to save the data locally if it doesn't exists.\n        read_kwargs: kwargs to pass to pd.read_csv\n\n    Returns:\n        Online transactions data from a non-store online retailer in UK.\n\n    \"\"\"\n    name = \"online_retail_II\"\n    read_kwargs = {\n        \"parse_dates\": [\"InvoiceDate\"],\n        **read_kwargs,\n    }\n\n    return _load_data(name, read_kwargs=read_kwargs, local_save=local_save)\n</code></pre>"},{"location":"modules/datasets/#latent_calendar.datasets.load_ufo_sightings","title":"<code>load_ufo_sightings(local_save=False, **read_kwargs)</code>","text":"<p>UFO sightings over time around the world. More info here.</p> <p>Parameters:</p> Name Type Description Default <code>local_save</code> <code>bool</code> <p>Whether to save the data locally if it doesn't exists.</p> <code>False</code> <code>read_kwargs</code> <p>kwargs to pass to pd.read_csv</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Sighting level data for UFOs.</p> Source code in <code>latent_calendar/datasets/__init__.py</code> <pre><code>def load_ufo_sightings(local_save: bool = False, **read_kwargs) -&gt; pd.DataFrame:\n    \"\"\"UFO sightings over time around the world. More info [here](https://www.kaggle.com/datasets/camnugent/ufo-sightings-around-the-world).\n\n    Args:\n        local_save: Whether to save the data locally if it doesn't exists.\n        read_kwargs: kwargs to pass to pd.read_csv\n\n    Returns:\n        Sighting level data for UFOs.\n\n    \"\"\"\n    name = \"ufo_sighting_data\"\n    read_kwargs = {\"low_memory\": False, **read_kwargs}\n    save_kwargs = {\"index\": False}\n\n    df = _load_data(\n        name, read_kwargs=read_kwargs, save_kwargs=save_kwargs, local_save=local_save\n    )\n    df[\"Date_time\"] = pd.to_datetime(\n        df[\"Date_time\"]\n        .str.replace(\" 24:00\", \" 23:59\")\n        .pipe(pd.to_datetime, format=\"mixed\", dayfirst=True)\n    )\n\n    return df\n</code></pre>"},{"location":"modules/extensions/","title":"Extensions","text":"<p>Pandas extensions for <code>latent-calendar</code> and primary interface for the package.</p> <p>Provides a <code>cal</code> accessor to <code>DataFrame</code> and <code>Series</code> instances for easy transformation and plotting after import of <code>latent_calendar</code>.</p> <p>Functionality includes:</p> <ul> <li>aggregation of events to wide format</li> <li>convolutions of wide formats</li> <li>making transformations and predictions with models</li> <li>plotting of events, predictions, and comparisons as calendars</li> </ul> <p>Each <code>DataFrame</code> will be either at event level or an aggregated wide format.</p> <p>Methods that end in <code>row</code> or <code>by_row</code> will be for wide format DataFrames and will plot each row as a calendar.</p> <p>Examples:</p> <p>Plotting an event level Series as a calendar</p> <pre><code>import pandas as pd\nimport latent_calendar\n\ndates = pd.date_range(\"2023-01-01\", \"2023-01-14\", freq=\"h\")\nser = (\n    pd.Series(dates)\n    .sample(10, random_state=42)\n)\n\nser.cal.plot()\n</code></pre> <p></p> <p>Transform event level DataFrame to wide format and plot</p> <pre><code>from latent_calendar.datasets import load_online_transactions\n\ndf = load_online_transactions()\n\n# (n_customer, n_timeslots)\ndf_wide = (\n    df\n    .cal.aggregate_events(\"Customer ID\", timestamp_col=\"InvoiceDate\")\n)\n\n(\n    df_wide\n    .sample(n=12, random_state=42)\n    .cal.plot_by_row(max_cols=4)\n)\n</code></pre> <p></p> <p>Train a model and plot predictions</p> <pre><code>from latent_calendar import LatentCalendar\n\nmodel = LatentCalendar(n_components=5, random_state=42)\nmodel.fit(df_wide.to_numpy())\n\n(\n    df_wide\n    .head(2)\n    .cal.plot_profile_by_row(model=model)\n)\n</code></pre> <p></p>"},{"location":"modules/extensions/#latent_calendar.extensions.DataFrameAccessor","title":"<code>DataFrameAccessor</code>","text":"<p>DataFrame accessor for latent_calendar accessed through <code>cal</code> attribute of DataFrames.</p> Source code in <code>latent_calendar/extensions.py</code> <pre><code>@pd.api.extensions.register_dataframe_accessor(\"cal\")\nclass DataFrameAccessor:\n    \"\"\"DataFrame accessor for latent_calendar accessed through `cal` attribute of DataFrames.\"\"\"\n\n    def __init__(self, pandas_obj: pd.DataFrame):\n        self._obj = pandas_obj\n\n    def divide_by_max(self) -&gt; pd.DataFrame:\n        \"\"\"Divide each row by the max value.\n\n        Returns:\n            DataFrame with row-wise operations applied\n\n        \"\"\"\n        return self._obj.div(self._obj.max(axis=1), axis=0)\n\n    def divide_by_sum(self) -&gt; pd.DataFrame:\n        \"\"\"Divide each row by the sum of the row.\n\n        Returns:\n            DataFrame with row-wise operations applied\n\n        \"\"\"\n        return self._obj.div(self._obj.sum(axis=1), axis=0)\n\n    def divide_by_even_rate(self) -&gt; pd.DataFrame:\n        \"\"\"Divide each row by the number of columns.\n\n        Returns:\n            DataFrame with row-wise operations applied\n\n        \"\"\"\n        value = self._obj.shape[1]\n        return self._obj.mul(value)\n\n    def normalize(self, kind: Literal[\"max\", \"probs\", \"even_rate\"]) -&gt; pd.DataFrame:\n        \"\"\"Row-wise operations on DataFrame.\n\n        Args:\n            kind: The normalization to apply.\n\n        Returns:\n            DataFrame with row-wise operations applied\n\n        \"\"\"\n        import warnings\n\n        def warn(message):\n            warnings.warn(message, DeprecationWarning, stacklevel=3)\n\n        warning_message = \"This method will be deprecated in future versions\"\n\n        funcs = {\n            \"max\": self.divide_by_max,\n            \"probs\": self.divide_by_sum,\n            \"even_rate\": self.divide_by_even_rate,\n        }\n\n        if kind not in funcs:\n            warn(warning_message)\n            raise ValueError(\n                f\"kind must be one of ['max', 'probs', 'even_rate'], got {kind}\"\n            )\n\n        func = funcs[kind]\n\n        warning_message = f\"{warning_message} in favor of df.cal.{func.__name__}()\"\n        warn(warning_message)\n\n        return func()\n\n    def conditional_probabilities(\n        self,\n        *,\n        level: int | str = 0,\n    ) -&gt; pd.DataFrame:\n        \"\"\"Calculate conditional probabilities for each row over the level.\n\n        Args:\n            level: level of the columns MultiIndex.\n                Default 0 or day_of_week\n\n        Returns:\n            DataFrame with conditional probabilities\n\n        \"\"\"\n        if not isinstance(self._obj.columns, pd.MultiIndex):\n            raise ValueError(\n                \"DataFrame is expected to have a MultiIndex with the last column as the vocab.\"\n            )\n\n        return self._obj.div(\n            self._obj.T.groupby(level=level).sum().T, level=level, axis=1\n        )\n\n    def timestamp_features(\n        self,\n        column: str,\n        discretize: bool = True,\n        minutes: int = 60,\n        create_vocab: bool = True,\n    ) -&gt; pd.DataFrame:\n        \"\"\"Create day of week and proportion into day columns for event level DataFrame\n\n        Exposed as a method on DataFrame for convenience. Use `cal.aggregate_events` instead to create the wide format DataFrame.\n\n        Args:\n            column: The name of the timestamp column.\n            discretize: Whether to discretize the hour column.\n            minutes: The number of minutes to discretize by. Ingored if `discretize` is False.\n            create_vocab: Whether to create the vocab column.\n\n        Returns:\n            DataFrame with features added\n\n        \"\"\"\n        transformer = create_timestamp_feature_pipeline(\n            timestamp_col=column,\n            discretize=discretize,\n            create_vocab=create_vocab,\n            minutes=minutes,\n        )\n\n        return transformer.fit_transform(self._obj)\n\n    def widen(\n        self,\n        column: str,\n        as_int: bool = True,\n        minutes: int = 60,\n        multiindex: bool = True,\n    ) -&gt; pd.DataFrame:\n        \"\"\"Transform an aggregated DataFrame to wide calendar format.\n\n        Wrapper around `LongToWide` transformer to transform to wide format.\n\n        Args:\n            column: column to widen\n            as_int: whether to cast the column to int\n            minutes: number of minutes to\n            multiindex: whether to use a MultiIndex\n\n        Returns:\n            DataFrame in wide format\n\n        \"\"\"\n        if not isinstance(self._obj.index, pd.MultiIndex):\n            raise ValueError(\n                \"DataFrame is expected to have a MultiIndex with the last column as the vocab.\"\n            )\n\n        transformer = LongToWide(\n            col=column, as_int=as_int, minutes=minutes, multiindex=multiindex\n        )\n\n        return transformer.fit_transform(self._obj)\n\n    def aggregate_events(\n        self,\n        by: str | list[str],\n        timestamp_col: str,\n        minutes: int = 60,\n        as_multiindex: bool = True,\n    ) -&gt; pd.DataFrame:\n        \"\"\"Transform event level DataFrame to wide format with groups as index.\n\n        Wrapper around `create_raw_to_vocab_transformer` to transform to wide format.\n\n        Args:\n            by: column(s) to use as index\n            timestamp_col: column to use as timestamp\n            minutes: The number of minutes to discretize by.\n            as_multiindex: whether to use MultiIndex columns\n\n        Returns:\n            DataFrame in wide format\n\n        \"\"\"\n        if not isinstance(by, list):\n            id_col = by\n            additional_groups = None\n        else:\n            id_col, *additional_groups = by\n\n        transformer = create_raw_to_vocab_transformer(\n            id_col=id_col,\n            timestamp_col=timestamp_col,\n            minutes=minutes,\n            additional_groups=additional_groups,\n            as_multiindex=as_multiindex,\n        )\n        return transformer.fit_transform(self._obj)\n\n    def sum_over_vocab(self, aggregation: str = \"dow\") -&gt; pd.DataFrame:\n        \"\"\"Sum the wide format to day of week or hour of day.\n\n        Args:\n            aggregation: one of ['dow', 'hour']\n\n        Returns:\n            DataFrame with summed values\n\n        Examples:\n            Sum to day of week\n\n            ```python\n            df_dow = df_wide.cal.sum_over_vocab(aggregation='dow')\n            ```\n\n        \"\"\"\n        return sum_over_vocab(self._obj, aggregation=aggregation)\n\n    def sum_next_hours(self, hours: int) -&gt; pd.DataFrame:\n        \"\"\"Sum the wide format over next hours.\n\n        Args:\n            hours: number of hours to sum over\n\n        Returns:\n            DataFrame with summed values\n\n        \"\"\"\n        return sum_next_hours(self._obj, hours=hours)\n\n    def sum_over_segments(self, df_segments: pd.DataFrame) -&gt; pd.DataFrame:\n        \"\"\"Sum the wide format over user defined segments.\n\n        Args:\n            df_segments: DataFrame in wide format with segments as index\n\n        Returns:\n            DataFrame with columns as the segments and summed values\n\n        \"\"\"\n        return sum_over_segments(self._obj, df_segments=df_segments)\n\n    def transform(self, *, model: LatentCalendar) -&gt; pd.DataFrame:\n        \"\"\"Transform DataFrame with model.\n\n        Applies the dimensionality reduction to each row of the DataFrame.\n\n        Args:\n            model: model to use for transformation\n\n        Returns:\n            DataFrame with transformed values\n\n        \"\"\"\n        return transform_on_dataframe(self._obj, model=model)\n\n    def predict(self, *, model: LatentCalendar) -&gt; pd.DataFrame:\n        \"\"\"Predict DataFrame with model.\n\n        Args:\n            model: model to use for prediction\n\n        Returns:\n            DataFrame with predicted values (wide format)\n\n        \"\"\"\n        return predict_on_dataframe(self._obj, model=model)\n\n    def plot(\n        self,\n        start_col: str,\n        *,\n        end_col: str | None = None,\n        duration: int | None = None,\n        alpha: float = None,\n        cmap=None,\n        day_labeler: DayLabeler = DayLabeler(),\n        time_labeler: TimeLabeler = TimeLabeler(),\n        grid_lines: GridLines = GridLines(),\n        monday_start: bool = True,\n        ax: plt.Axes | None = None,\n    ) -&gt; plt.Axes:\n        \"\"\"Plot DataFrame of timestamps as a calendar.\n\n        Args:\n            start_col: column with start timestamp\n            end_col: column with end timestamp\n            duration: length of event in minutes. Alternative to end_col\n            alpha: alpha value for the color\n            cmap: function that maps floats to string colors\n            monday_start: whether to start the week on Monday or Sunday\n            ax: optional matplotlib axis to plot on\n\n        Returns:\n            Modified matplotlib axis\n\n        \"\"\"\n        config = StartEndConfig(start=start_col, end=end_col, minutes=duration)\n\n        return plot_dataframe_as_calendar(\n            self._obj,\n            config=config,\n            alpha=alpha,\n            cmap=cmap,\n            day_labeler=day_labeler,\n            time_labeler=time_labeler,\n            grid_lines=grid_lines,\n            monday_start=monday_start,\n            ax=ax,\n        )\n\n    def plot_across_column(\n        self,\n        start_col: str,\n        grid_col: str,\n        *,\n        end_col: str | None = None,\n        duration: int | None = None,\n        day_labeler: DayLabeler = DayLabeler(),\n        time_labeler: TimeLabeler = TimeLabeler(),\n        grid_lines: GridLines = GridLines(),\n        max_cols: int = 3,\n        alpha: float = None,\n    ) -&gt; None:\n        \"\"\"Plot DataFrame of timestamps as a calendar as grid across column values.\n\n        NA values are excluded\n\n        Args:\n            start_col: column with start timestamp\n            grid_col: column of values to use as grid\n            end_col: column with end timestamp\n            duration: length of event in minutes. Alternative to end_col\n            max_cols: max number of columns per row\n            alpha: alpha value for the color\n\n        Returns:\n            None\n\n        \"\"\"\n        config = StartEndConfig(start=start_col, end=end_col, minutes=duration)\n\n        plot_dataframe_grid_across_column(\n            self._obj,\n            grid_col=grid_col,\n            config=config,\n            max_cols=max_cols,\n            alpha=alpha,\n            day_labeler=day_labeler,\n            time_labeler=time_labeler,\n            grid_lines=grid_lines,\n        )\n\n    def plot_by_row(\n        self,\n        *,\n        max_cols: int = 3,\n        title_func: TITLE_FUNC | None = None,\n        cmaps: CMAP | ColorMap | CMAP_GENERATOR | None = None,\n        day_labeler: DayLabeler = DayLabeler(),\n        time_labeler: TimeLabeler = TimeLabeler(),\n        grid_lines: GridLines = GridLines(),\n        monday_start: bool = True,\n    ) -&gt; None:\n        \"\"\"Plot each row of the DataFrame as a calendar plot. Data must have been transformed to wide format first.\n\n        Wrapper around `latent_calendar.plot.plot_calendar_by_row`.\n\n        Args:\n            max_cols: max number of columns per row of grid\n            title_func: function to generate title for each row\n            day_labeler: function to generate day labels\n            time_labeler: function to generate time labels\n            cmaps: optional generator of colormaps\n            grid_lines: optional grid lines\n            monday_start: whether to start the week on Monday or Sunday\n\n        Returns:\n            None\n\n        \"\"\"\n        return plot_calendar_by_row(\n            self._obj,\n            max_cols=max_cols,\n            title_func=title_func,\n            day_labeler=day_labeler,\n            time_labeler=time_labeler,\n            cmaps=cmaps,\n            grid_lines=grid_lines,\n            monday_start=monday_start,\n        )\n\n    def plot_profile_by_row(\n        self,\n        *,\n        model: LatentCalendar,\n        index_func=lambda idx: idx,\n        include_components: bool = True,\n        day_labeler: DayLabeler = DayLabeler(),\n        time_labeler: TimeLabeler = TimeLabeler(),\n    ) -&gt; np.ndarray:\n        \"\"\"Plot each row of the DataFrame as a profile plot. Data must have been transformed to wide format first.\n\n        Args:\n            model: model to use for prediction and transform\n            index_func: function to generate title for each row\n            include_components: whether to include components in the plot\n            day_labeler: DayLabeler instance to use for day labels\n            time_labeler: TimeLabeler instance to use for time labels\n\n        Returns:\n            grid of axes\n\n        \"\"\"\n        return plot_profile_by_row(\n            self._obj,\n            model=model,\n            index_func=index_func,\n            include_components=include_components,\n            day_labeler=day_labeler,\n            time_labeler=time_labeler,\n        )\n\n    def plot_raw_and_predicted_by_row(\n        self,\n        *,\n        model: LatentCalendar,\n        index_func=lambda idx: idx,\n        day_labeler: DayLabeler = DayLabeler(),\n        time_labeler: TimeLabeler = TimeLabeler(),\n    ) -&gt; np.ndarray:\n        \"\"\"Plot raw and predicted values for a model. Data must have been transformed to wide format first.\n\n        Args:\n            model: model to use for prediction\n            index_func: function to generate title for each row\n            day_labeler: DayLabeler instance to use for day labels\n            time_labeler: TimeLabeler instance to use for time labels\n\n        Returns:\n            grid of axes\n\n        \"\"\"\n        return plot_profile_by_row(\n            self._obj,\n            model=model,\n            index_func=index_func,\n            include_components=False,\n            day_labeler=day_labeler,\n            time_labeler=time_labeler,\n        )\n\n    def plot_model_predictions_by_row(\n        self,\n        df_holdout: pd.DataFrame,\n        *,\n        model: LatentCalendar,\n        index_func=lambda idx: idx,\n        divergent: bool = True,\n        day_labeler: DayLabeler = DayLabeler(),\n        time_labeler: TimeLabeler = TimeLabeler(),\n    ) -&gt; np.ndarray:\n        \"\"\"Plot model predictions for each row of the DataFrame. Data must have been transformed to wide format first.\n\n        Args:\n            df_holdout: holdout DataFrame for comparison\n            model: model to use for prediction\n            index_func: function to generate title for each row\n            divergent: whether to use divergent colormap\n            day_labeler: DayLabeler instance to use for day labels\n            time_labeler: TimeLabeler instance to use for time labels\n\n        Returns:\n            grid of axes\n\n        \"\"\"\n        return plot_model_predictions_by_row(\n            self._obj,\n            df_holdout=df_holdout,\n            model=model,\n            index_func=index_func,\n            divergent=divergent,\n            day_labeler=day_labeler,\n            time_labeler=time_labeler,\n        )\n</code></pre>"},{"location":"modules/extensions/#latent_calendar.extensions.DataFrameAccessor.aggregate_events","title":"<code>aggregate_events(by, timestamp_col, minutes=60, as_multiindex=True)</code>","text":"<p>Transform event level DataFrame to wide format with groups as index.</p> <p>Wrapper around <code>create_raw_to_vocab_transformer</code> to transform to wide format.</p> <p>Parameters:</p> Name Type Description Default <code>by</code> <code>str | list[str]</code> <p>column(s) to use as index</p> required <code>timestamp_col</code> <code>str</code> <p>column to use as timestamp</p> required <code>minutes</code> <code>int</code> <p>The number of minutes to discretize by.</p> <code>60</code> <code>as_multiindex</code> <code>bool</code> <p>whether to use MultiIndex columns</p> <code>True</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame in wide format</p> Source code in <code>latent_calendar/extensions.py</code> <pre><code>def aggregate_events(\n    self,\n    by: str | list[str],\n    timestamp_col: str,\n    minutes: int = 60,\n    as_multiindex: bool = True,\n) -&gt; pd.DataFrame:\n    \"\"\"Transform event level DataFrame to wide format with groups as index.\n\n    Wrapper around `create_raw_to_vocab_transformer` to transform to wide format.\n\n    Args:\n        by: column(s) to use as index\n        timestamp_col: column to use as timestamp\n        minutes: The number of minutes to discretize by.\n        as_multiindex: whether to use MultiIndex columns\n\n    Returns:\n        DataFrame in wide format\n\n    \"\"\"\n    if not isinstance(by, list):\n        id_col = by\n        additional_groups = None\n    else:\n        id_col, *additional_groups = by\n\n    transformer = create_raw_to_vocab_transformer(\n        id_col=id_col,\n        timestamp_col=timestamp_col,\n        minutes=minutes,\n        additional_groups=additional_groups,\n        as_multiindex=as_multiindex,\n    )\n    return transformer.fit_transform(self._obj)\n</code></pre>"},{"location":"modules/extensions/#latent_calendar.extensions.DataFrameAccessor.conditional_probabilities","title":"<code>conditional_probabilities(*, level=0)</code>","text":"<p>Calculate conditional probabilities for each row over the level.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>int | str</code> <p>level of the columns MultiIndex. Default 0 or day_of_week</p> <code>0</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with conditional probabilities</p> Source code in <code>latent_calendar/extensions.py</code> <pre><code>def conditional_probabilities(\n    self,\n    *,\n    level: int | str = 0,\n) -&gt; pd.DataFrame:\n    \"\"\"Calculate conditional probabilities for each row over the level.\n\n    Args:\n        level: level of the columns MultiIndex.\n            Default 0 or day_of_week\n\n    Returns:\n        DataFrame with conditional probabilities\n\n    \"\"\"\n    if not isinstance(self._obj.columns, pd.MultiIndex):\n        raise ValueError(\n            \"DataFrame is expected to have a MultiIndex with the last column as the vocab.\"\n        )\n\n    return self._obj.div(\n        self._obj.T.groupby(level=level).sum().T, level=level, axis=1\n    )\n</code></pre>"},{"location":"modules/extensions/#latent_calendar.extensions.DataFrameAccessor.divide_by_even_rate","title":"<code>divide_by_even_rate()</code>","text":"<p>Divide each row by the number of columns.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with row-wise operations applied</p> Source code in <code>latent_calendar/extensions.py</code> <pre><code>def divide_by_even_rate(self) -&gt; pd.DataFrame:\n    \"\"\"Divide each row by the number of columns.\n\n    Returns:\n        DataFrame with row-wise operations applied\n\n    \"\"\"\n    value = self._obj.shape[1]\n    return self._obj.mul(value)\n</code></pre>"},{"location":"modules/extensions/#latent_calendar.extensions.DataFrameAccessor.divide_by_max","title":"<code>divide_by_max()</code>","text":"<p>Divide each row by the max value.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with row-wise operations applied</p> Source code in <code>latent_calendar/extensions.py</code> <pre><code>def divide_by_max(self) -&gt; pd.DataFrame:\n    \"\"\"Divide each row by the max value.\n\n    Returns:\n        DataFrame with row-wise operations applied\n\n    \"\"\"\n    return self._obj.div(self._obj.max(axis=1), axis=0)\n</code></pre>"},{"location":"modules/extensions/#latent_calendar.extensions.DataFrameAccessor.divide_by_sum","title":"<code>divide_by_sum()</code>","text":"<p>Divide each row by the sum of the row.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with row-wise operations applied</p> Source code in <code>latent_calendar/extensions.py</code> <pre><code>def divide_by_sum(self) -&gt; pd.DataFrame:\n    \"\"\"Divide each row by the sum of the row.\n\n    Returns:\n        DataFrame with row-wise operations applied\n\n    \"\"\"\n    return self._obj.div(self._obj.sum(axis=1), axis=0)\n</code></pre>"},{"location":"modules/extensions/#latent_calendar.extensions.DataFrameAccessor.normalize","title":"<code>normalize(kind)</code>","text":"<p>Row-wise operations on DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>kind</code> <code>Literal['max', 'probs', 'even_rate']</code> <p>The normalization to apply.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with row-wise operations applied</p> Source code in <code>latent_calendar/extensions.py</code> <pre><code>def normalize(self, kind: Literal[\"max\", \"probs\", \"even_rate\"]) -&gt; pd.DataFrame:\n    \"\"\"Row-wise operations on DataFrame.\n\n    Args:\n        kind: The normalization to apply.\n\n    Returns:\n        DataFrame with row-wise operations applied\n\n    \"\"\"\n    import warnings\n\n    def warn(message):\n        warnings.warn(message, DeprecationWarning, stacklevel=3)\n\n    warning_message = \"This method will be deprecated in future versions\"\n\n    funcs = {\n        \"max\": self.divide_by_max,\n        \"probs\": self.divide_by_sum,\n        \"even_rate\": self.divide_by_even_rate,\n    }\n\n    if kind not in funcs:\n        warn(warning_message)\n        raise ValueError(\n            f\"kind must be one of ['max', 'probs', 'even_rate'], got {kind}\"\n        )\n\n    func = funcs[kind]\n\n    warning_message = f\"{warning_message} in favor of df.cal.{func.__name__}()\"\n    warn(warning_message)\n\n    return func()\n</code></pre>"},{"location":"modules/extensions/#latent_calendar.extensions.DataFrameAccessor.plot","title":"<code>plot(start_col, *, end_col=None, duration=None, alpha=None, cmap=None, day_labeler=DayLabeler(), time_labeler=TimeLabeler(), grid_lines=GridLines(), monday_start=True, ax=None)</code>","text":"<p>Plot DataFrame of timestamps as a calendar.</p> <p>Parameters:</p> Name Type Description Default <code>start_col</code> <code>str</code> <p>column with start timestamp</p> required <code>end_col</code> <code>str | None</code> <p>column with end timestamp</p> <code>None</code> <code>duration</code> <code>int | None</code> <p>length of event in minutes. Alternative to end_col</p> <code>None</code> <code>alpha</code> <code>float</code> <p>alpha value for the color</p> <code>None</code> <code>cmap</code> <p>function that maps floats to string colors</p> <code>None</code> <code>monday_start</code> <code>bool</code> <p>whether to start the week on Monday or Sunday</p> <code>True</code> <code>ax</code> <code>Axes | None</code> <p>optional matplotlib axis to plot on</p> <code>None</code> <p>Returns:</p> Type Description <code>Axes</code> <p>Modified matplotlib axis</p> Source code in <code>latent_calendar/extensions.py</code> <pre><code>def plot(\n    self,\n    start_col: str,\n    *,\n    end_col: str | None = None,\n    duration: int | None = None,\n    alpha: float = None,\n    cmap=None,\n    day_labeler: DayLabeler = DayLabeler(),\n    time_labeler: TimeLabeler = TimeLabeler(),\n    grid_lines: GridLines = GridLines(),\n    monday_start: bool = True,\n    ax: plt.Axes | None = None,\n) -&gt; plt.Axes:\n    \"\"\"Plot DataFrame of timestamps as a calendar.\n\n    Args:\n        start_col: column with start timestamp\n        end_col: column with end timestamp\n        duration: length of event in minutes. Alternative to end_col\n        alpha: alpha value for the color\n        cmap: function that maps floats to string colors\n        monday_start: whether to start the week on Monday or Sunday\n        ax: optional matplotlib axis to plot on\n\n    Returns:\n        Modified matplotlib axis\n\n    \"\"\"\n    config = StartEndConfig(start=start_col, end=end_col, minutes=duration)\n\n    return plot_dataframe_as_calendar(\n        self._obj,\n        config=config,\n        alpha=alpha,\n        cmap=cmap,\n        day_labeler=day_labeler,\n        time_labeler=time_labeler,\n        grid_lines=grid_lines,\n        monday_start=monday_start,\n        ax=ax,\n    )\n</code></pre>"},{"location":"modules/extensions/#latent_calendar.extensions.DataFrameAccessor.plot_across_column","title":"<code>plot_across_column(start_col, grid_col, *, end_col=None, duration=None, day_labeler=DayLabeler(), time_labeler=TimeLabeler(), grid_lines=GridLines(), max_cols=3, alpha=None)</code>","text":"<p>Plot DataFrame of timestamps as a calendar as grid across column values.</p> <p>NA values are excluded</p> <p>Parameters:</p> Name Type Description Default <code>start_col</code> <code>str</code> <p>column with start timestamp</p> required <code>grid_col</code> <code>str</code> <p>column of values to use as grid</p> required <code>end_col</code> <code>str | None</code> <p>column with end timestamp</p> <code>None</code> <code>duration</code> <code>int | None</code> <p>length of event in minutes. Alternative to end_col</p> <code>None</code> <code>max_cols</code> <code>int</code> <p>max number of columns per row</p> <code>3</code> <code>alpha</code> <code>float</code> <p>alpha value for the color</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>latent_calendar/extensions.py</code> <pre><code>def plot_across_column(\n    self,\n    start_col: str,\n    grid_col: str,\n    *,\n    end_col: str | None = None,\n    duration: int | None = None,\n    day_labeler: DayLabeler = DayLabeler(),\n    time_labeler: TimeLabeler = TimeLabeler(),\n    grid_lines: GridLines = GridLines(),\n    max_cols: int = 3,\n    alpha: float = None,\n) -&gt; None:\n    \"\"\"Plot DataFrame of timestamps as a calendar as grid across column values.\n\n    NA values are excluded\n\n    Args:\n        start_col: column with start timestamp\n        grid_col: column of values to use as grid\n        end_col: column with end timestamp\n        duration: length of event in minutes. Alternative to end_col\n        max_cols: max number of columns per row\n        alpha: alpha value for the color\n\n    Returns:\n        None\n\n    \"\"\"\n    config = StartEndConfig(start=start_col, end=end_col, minutes=duration)\n\n    plot_dataframe_grid_across_column(\n        self._obj,\n        grid_col=grid_col,\n        config=config,\n        max_cols=max_cols,\n        alpha=alpha,\n        day_labeler=day_labeler,\n        time_labeler=time_labeler,\n        grid_lines=grid_lines,\n    )\n</code></pre>"},{"location":"modules/extensions/#latent_calendar.extensions.DataFrameAccessor.plot_by_row","title":"<code>plot_by_row(*, max_cols=3, title_func=None, cmaps=None, day_labeler=DayLabeler(), time_labeler=TimeLabeler(), grid_lines=GridLines(), monday_start=True)</code>","text":"<p>Plot each row of the DataFrame as a calendar plot. Data must have been transformed to wide format first.</p> <p>Wrapper around <code>latent_calendar.plot.plot_calendar_by_row</code>.</p> <p>Parameters:</p> Name Type Description Default <code>max_cols</code> <code>int</code> <p>max number of columns per row of grid</p> <code>3</code> <code>title_func</code> <code>TITLE_FUNC | None</code> <p>function to generate title for each row</p> <code>None</code> <code>day_labeler</code> <code>DayLabeler</code> <p>function to generate day labels</p> <code>DayLabeler()</code> <code>time_labeler</code> <code>TimeLabeler</code> <p>function to generate time labels</p> <code>TimeLabeler()</code> <code>cmaps</code> <code>CMAP | ColorMap | CMAP_GENERATOR | None</code> <p>optional generator of colormaps</p> <code>None</code> <code>grid_lines</code> <code>GridLines</code> <p>optional grid lines</p> <code>GridLines()</code> <code>monday_start</code> <code>bool</code> <p>whether to start the week on Monday or Sunday</p> <code>True</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>latent_calendar/extensions.py</code> <pre><code>def plot_by_row(\n    self,\n    *,\n    max_cols: int = 3,\n    title_func: TITLE_FUNC | None = None,\n    cmaps: CMAP | ColorMap | CMAP_GENERATOR | None = None,\n    day_labeler: DayLabeler = DayLabeler(),\n    time_labeler: TimeLabeler = TimeLabeler(),\n    grid_lines: GridLines = GridLines(),\n    monday_start: bool = True,\n) -&gt; None:\n    \"\"\"Plot each row of the DataFrame as a calendar plot. Data must have been transformed to wide format first.\n\n    Wrapper around `latent_calendar.plot.plot_calendar_by_row`.\n\n    Args:\n        max_cols: max number of columns per row of grid\n        title_func: function to generate title for each row\n        day_labeler: function to generate day labels\n        time_labeler: function to generate time labels\n        cmaps: optional generator of colormaps\n        grid_lines: optional grid lines\n        monday_start: whether to start the week on Monday or Sunday\n\n    Returns:\n        None\n\n    \"\"\"\n    return plot_calendar_by_row(\n        self._obj,\n        max_cols=max_cols,\n        title_func=title_func,\n        day_labeler=day_labeler,\n        time_labeler=time_labeler,\n        cmaps=cmaps,\n        grid_lines=grid_lines,\n        monday_start=monday_start,\n    )\n</code></pre>"},{"location":"modules/extensions/#latent_calendar.extensions.DataFrameAccessor.plot_model_predictions_by_row","title":"<code>plot_model_predictions_by_row(df_holdout, *, model, index_func=lambda idx: idx, divergent=True, day_labeler=DayLabeler(), time_labeler=TimeLabeler())</code>","text":"<p>Plot model predictions for each row of the DataFrame. Data must have been transformed to wide format first.</p> <p>Parameters:</p> Name Type Description Default <code>df_holdout</code> <code>DataFrame</code> <p>holdout DataFrame for comparison</p> required <code>model</code> <code>LatentCalendar</code> <p>model to use for prediction</p> required <code>index_func</code> <p>function to generate title for each row</p> <code>lambda idx: idx</code> <code>divergent</code> <code>bool</code> <p>whether to use divergent colormap</p> <code>True</code> <code>day_labeler</code> <code>DayLabeler</code> <p>DayLabeler instance to use for day labels</p> <code>DayLabeler()</code> <code>time_labeler</code> <code>TimeLabeler</code> <p>TimeLabeler instance to use for time labels</p> <code>TimeLabeler()</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>grid of axes</p> Source code in <code>latent_calendar/extensions.py</code> <pre><code>def plot_model_predictions_by_row(\n    self,\n    df_holdout: pd.DataFrame,\n    *,\n    model: LatentCalendar,\n    index_func=lambda idx: idx,\n    divergent: bool = True,\n    day_labeler: DayLabeler = DayLabeler(),\n    time_labeler: TimeLabeler = TimeLabeler(),\n) -&gt; np.ndarray:\n    \"\"\"Plot model predictions for each row of the DataFrame. Data must have been transformed to wide format first.\n\n    Args:\n        df_holdout: holdout DataFrame for comparison\n        model: model to use for prediction\n        index_func: function to generate title for each row\n        divergent: whether to use divergent colormap\n        day_labeler: DayLabeler instance to use for day labels\n        time_labeler: TimeLabeler instance to use for time labels\n\n    Returns:\n        grid of axes\n\n    \"\"\"\n    return plot_model_predictions_by_row(\n        self._obj,\n        df_holdout=df_holdout,\n        model=model,\n        index_func=index_func,\n        divergent=divergent,\n        day_labeler=day_labeler,\n        time_labeler=time_labeler,\n    )\n</code></pre>"},{"location":"modules/extensions/#latent_calendar.extensions.DataFrameAccessor.plot_profile_by_row","title":"<code>plot_profile_by_row(*, model, index_func=lambda idx: idx, include_components=True, day_labeler=DayLabeler(), time_labeler=TimeLabeler())</code>","text":"<p>Plot each row of the DataFrame as a profile plot. Data must have been transformed to wide format first.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>LatentCalendar</code> <p>model to use for prediction and transform</p> required <code>index_func</code> <p>function to generate title for each row</p> <code>lambda idx: idx</code> <code>include_components</code> <code>bool</code> <p>whether to include components in the plot</p> <code>True</code> <code>day_labeler</code> <code>DayLabeler</code> <p>DayLabeler instance to use for day labels</p> <code>DayLabeler()</code> <code>time_labeler</code> <code>TimeLabeler</code> <p>TimeLabeler instance to use for time labels</p> <code>TimeLabeler()</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>grid of axes</p> Source code in <code>latent_calendar/extensions.py</code> <pre><code>def plot_profile_by_row(\n    self,\n    *,\n    model: LatentCalendar,\n    index_func=lambda idx: idx,\n    include_components: bool = True,\n    day_labeler: DayLabeler = DayLabeler(),\n    time_labeler: TimeLabeler = TimeLabeler(),\n) -&gt; np.ndarray:\n    \"\"\"Plot each row of the DataFrame as a profile plot. Data must have been transformed to wide format first.\n\n    Args:\n        model: model to use for prediction and transform\n        index_func: function to generate title for each row\n        include_components: whether to include components in the plot\n        day_labeler: DayLabeler instance to use for day labels\n        time_labeler: TimeLabeler instance to use for time labels\n\n    Returns:\n        grid of axes\n\n    \"\"\"\n    return plot_profile_by_row(\n        self._obj,\n        model=model,\n        index_func=index_func,\n        include_components=include_components,\n        day_labeler=day_labeler,\n        time_labeler=time_labeler,\n    )\n</code></pre>"},{"location":"modules/extensions/#latent_calendar.extensions.DataFrameAccessor.plot_raw_and_predicted_by_row","title":"<code>plot_raw_and_predicted_by_row(*, model, index_func=lambda idx: idx, day_labeler=DayLabeler(), time_labeler=TimeLabeler())</code>","text":"<p>Plot raw and predicted values for a model. Data must have been transformed to wide format first.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>LatentCalendar</code> <p>model to use for prediction</p> required <code>index_func</code> <p>function to generate title for each row</p> <code>lambda idx: idx</code> <code>day_labeler</code> <code>DayLabeler</code> <p>DayLabeler instance to use for day labels</p> <code>DayLabeler()</code> <code>time_labeler</code> <code>TimeLabeler</code> <p>TimeLabeler instance to use for time labels</p> <code>TimeLabeler()</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>grid of axes</p> Source code in <code>latent_calendar/extensions.py</code> <pre><code>def plot_raw_and_predicted_by_row(\n    self,\n    *,\n    model: LatentCalendar,\n    index_func=lambda idx: idx,\n    day_labeler: DayLabeler = DayLabeler(),\n    time_labeler: TimeLabeler = TimeLabeler(),\n) -&gt; np.ndarray:\n    \"\"\"Plot raw and predicted values for a model. Data must have been transformed to wide format first.\n\n    Args:\n        model: model to use for prediction\n        index_func: function to generate title for each row\n        day_labeler: DayLabeler instance to use for day labels\n        time_labeler: TimeLabeler instance to use for time labels\n\n    Returns:\n        grid of axes\n\n    \"\"\"\n    return plot_profile_by_row(\n        self._obj,\n        model=model,\n        index_func=index_func,\n        include_components=False,\n        day_labeler=day_labeler,\n        time_labeler=time_labeler,\n    )\n</code></pre>"},{"location":"modules/extensions/#latent_calendar.extensions.DataFrameAccessor.predict","title":"<code>predict(*, model)</code>","text":"<p>Predict DataFrame with model.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>LatentCalendar</code> <p>model to use for prediction</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with predicted values (wide format)</p> Source code in <code>latent_calendar/extensions.py</code> <pre><code>def predict(self, *, model: LatentCalendar) -&gt; pd.DataFrame:\n    \"\"\"Predict DataFrame with model.\n\n    Args:\n        model: model to use for prediction\n\n    Returns:\n        DataFrame with predicted values (wide format)\n\n    \"\"\"\n    return predict_on_dataframe(self._obj, model=model)\n</code></pre>"},{"location":"modules/extensions/#latent_calendar.extensions.DataFrameAccessor.sum_next_hours","title":"<code>sum_next_hours(hours)</code>","text":"<p>Sum the wide format over next hours.</p> <p>Parameters:</p> Name Type Description Default <code>hours</code> <code>int</code> <p>number of hours to sum over</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with summed values</p> Source code in <code>latent_calendar/extensions.py</code> <pre><code>def sum_next_hours(self, hours: int) -&gt; pd.DataFrame:\n    \"\"\"Sum the wide format over next hours.\n\n    Args:\n        hours: number of hours to sum over\n\n    Returns:\n        DataFrame with summed values\n\n    \"\"\"\n    return sum_next_hours(self._obj, hours=hours)\n</code></pre>"},{"location":"modules/extensions/#latent_calendar.extensions.DataFrameAccessor.sum_over_segments","title":"<code>sum_over_segments(df_segments)</code>","text":"<p>Sum the wide format over user defined segments.</p> <p>Parameters:</p> Name Type Description Default <code>df_segments</code> <code>DataFrame</code> <p>DataFrame in wide format with segments as index</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with columns as the segments and summed values</p> Source code in <code>latent_calendar/extensions.py</code> <pre><code>def sum_over_segments(self, df_segments: pd.DataFrame) -&gt; pd.DataFrame:\n    \"\"\"Sum the wide format over user defined segments.\n\n    Args:\n        df_segments: DataFrame in wide format with segments as index\n\n    Returns:\n        DataFrame with columns as the segments and summed values\n\n    \"\"\"\n    return sum_over_segments(self._obj, df_segments=df_segments)\n</code></pre>"},{"location":"modules/extensions/#latent_calendar.extensions.DataFrameAccessor.sum_over_vocab","title":"<code>sum_over_vocab(aggregation='dow')</code>","text":"<p>Sum the wide format to day of week or hour of day.</p> <p>Parameters:</p> Name Type Description Default <code>aggregation</code> <code>str</code> <p>one of ['dow', 'hour']</p> <code>'dow'</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with summed values</p> <p>Examples:</p> <p>Sum to day of week</p> <pre><code>df_dow = df_wide.cal.sum_over_vocab(aggregation='dow')\n</code></pre> Source code in <code>latent_calendar/extensions.py</code> <pre><code>def sum_over_vocab(self, aggregation: str = \"dow\") -&gt; pd.DataFrame:\n    \"\"\"Sum the wide format to day of week or hour of day.\n\n    Args:\n        aggregation: one of ['dow', 'hour']\n\n    Returns:\n        DataFrame with summed values\n\n    Examples:\n        Sum to day of week\n\n        ```python\n        df_dow = df_wide.cal.sum_over_vocab(aggregation='dow')\n        ```\n\n    \"\"\"\n    return sum_over_vocab(self._obj, aggregation=aggregation)\n</code></pre>"},{"location":"modules/extensions/#latent_calendar.extensions.DataFrameAccessor.timestamp_features","title":"<code>timestamp_features(column, discretize=True, minutes=60, create_vocab=True)</code>","text":"<p>Create day of week and proportion into day columns for event level DataFrame</p> <p>Exposed as a method on DataFrame for convenience. Use <code>cal.aggregate_events</code> instead to create the wide format DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>column</code> <code>str</code> <p>The name of the timestamp column.</p> required <code>discretize</code> <code>bool</code> <p>Whether to discretize the hour column.</p> <code>True</code> <code>minutes</code> <code>int</code> <p>The number of minutes to discretize by. Ingored if <code>discretize</code> is False.</p> <code>60</code> <code>create_vocab</code> <code>bool</code> <p>Whether to create the vocab column.</p> <code>True</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with features added</p> Source code in <code>latent_calendar/extensions.py</code> <pre><code>def timestamp_features(\n    self,\n    column: str,\n    discretize: bool = True,\n    minutes: int = 60,\n    create_vocab: bool = True,\n) -&gt; pd.DataFrame:\n    \"\"\"Create day of week and proportion into day columns for event level DataFrame\n\n    Exposed as a method on DataFrame for convenience. Use `cal.aggregate_events` instead to create the wide format DataFrame.\n\n    Args:\n        column: The name of the timestamp column.\n        discretize: Whether to discretize the hour column.\n        minutes: The number of minutes to discretize by. Ingored if `discretize` is False.\n        create_vocab: Whether to create the vocab column.\n\n    Returns:\n        DataFrame with features added\n\n    \"\"\"\n    transformer = create_timestamp_feature_pipeline(\n        timestamp_col=column,\n        discretize=discretize,\n        create_vocab=create_vocab,\n        minutes=minutes,\n    )\n\n    return transformer.fit_transform(self._obj)\n</code></pre>"},{"location":"modules/extensions/#latent_calendar.extensions.DataFrameAccessor.transform","title":"<code>transform(*, model)</code>","text":"<p>Transform DataFrame with model.</p> <p>Applies the dimensionality reduction to each row of the DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>LatentCalendar</code> <p>model to use for transformation</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with transformed values</p> Source code in <code>latent_calendar/extensions.py</code> <pre><code>def transform(self, *, model: LatentCalendar) -&gt; pd.DataFrame:\n    \"\"\"Transform DataFrame with model.\n\n    Applies the dimensionality reduction to each row of the DataFrame.\n\n    Args:\n        model: model to use for transformation\n\n    Returns:\n        DataFrame with transformed values\n\n    \"\"\"\n    return transform_on_dataframe(self._obj, model=model)\n</code></pre>"},{"location":"modules/extensions/#latent_calendar.extensions.DataFrameAccessor.widen","title":"<code>widen(column, as_int=True, minutes=60, multiindex=True)</code>","text":"<p>Transform an aggregated DataFrame to wide calendar format.</p> <p>Wrapper around <code>LongToWide</code> transformer to transform to wide format.</p> <p>Parameters:</p> Name Type Description Default <code>column</code> <code>str</code> <p>column to widen</p> required <code>as_int</code> <code>bool</code> <p>whether to cast the column to int</p> <code>True</code> <code>minutes</code> <code>int</code> <p>number of minutes to</p> <code>60</code> <code>multiindex</code> <code>bool</code> <p>whether to use a MultiIndex</p> <code>True</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame in wide format</p> Source code in <code>latent_calendar/extensions.py</code> <pre><code>def widen(\n    self,\n    column: str,\n    as_int: bool = True,\n    minutes: int = 60,\n    multiindex: bool = True,\n) -&gt; pd.DataFrame:\n    \"\"\"Transform an aggregated DataFrame to wide calendar format.\n\n    Wrapper around `LongToWide` transformer to transform to wide format.\n\n    Args:\n        column: column to widen\n        as_int: whether to cast the column to int\n        minutes: number of minutes to\n        multiindex: whether to use a MultiIndex\n\n    Returns:\n        DataFrame in wide format\n\n    \"\"\"\n    if not isinstance(self._obj.index, pd.MultiIndex):\n        raise ValueError(\n            \"DataFrame is expected to have a MultiIndex with the last column as the vocab.\"\n        )\n\n    transformer = LongToWide(\n        col=column, as_int=as_int, minutes=minutes, multiindex=multiindex\n    )\n\n    return transformer.fit_transform(self._obj)\n</code></pre>"},{"location":"modules/extensions/#latent_calendar.extensions.SeriesAccessor","title":"<code>SeriesAccessor</code>","text":"<p>Series accessor for latent_calendar accessed through <code>cal</code> attribute of Series.</p> Source code in <code>latent_calendar/extensions.py</code> <pre><code>@pd.api.extensions.register_series_accessor(\"cal\")\nclass SeriesAccessor:\n    \"\"\"Series accessor for latent_calendar accessed through `cal` attribute of Series.\"\"\"\n\n    def __init__(self, pandas_obj: pd.Series):\n        self._obj = pandas_obj\n\n    def aggregate_events(\n        self,\n        minutes: int = 60,\n        as_multiindex: bool = True,\n    ) -&gt; pd.Series:\n        \"\"\"Transform event level Series to row of wide format.\n\n        Args:\n            minutes: The number of minutes to discretize by.\n            as_multiindex: whether to use MultiIndex columns\n\n        Returns:\n            Series that would be row of wide format\n\n        Examples:\n            Discretize datetime Series to 30 minutes\n\n            ```python\n            import pandas as pd\n\n            import matplotlib.pyplot as plt\n\n            from latent_calendar.datasets import load_chicago_bikes\n\n            df_trips = load_chicago_bikes()\n\n            start_times = df_trips[\"started_at\"]\n\n            agg_start_times = start_times.cal.aggregate_events(minutes=30)\n            agg_start_times.cal.plot_row()\n            plt.show()\n\n\n            ```\n\n\n        \"\"\"\n        name = self._obj.name or \"timestamp\"\n        return (\n            self._obj.rename(name)\n            .to_frame()\n            .assign(tmp=1)\n            .cal.aggregate_events(\n                by=\"tmp\",\n                timestamp_col=name,\n                minutes=minutes,\n                as_multiindex=as_multiindex,\n            )\n            .iloc[0]\n            .rename(name)\n        )\n\n    def timestamp_features(\n        self, discretize: bool = True, minutes: int = 60, create_vocab: bool = True\n    ) -&gt; pd.DataFrame:\n        \"\"\"Create day of week and proportion into day columns.\n\n        Exposed as a method on Series for convenience.\n\n        Args:\n            discretize: Whether to discretize the hour column.\n            minutes: The number of minutes to discretize by. Ingored if `discretize` is False.\n            create_vocab: Whether to create the vocab column.\n\n        Returns:\n            DataFrame with features\n\n        Examples:\n            Create the features for some dates\n\n            ```python\n            ser = pd.Series(pd.date_range(\"2023-01-01\", \"2023-01-14\", freq=\"h\"))\n\n            ser.cal.timestamp_features()\n            ```\n\n            ```text\n                        timestamp  day_of_week  hour\n            0   2023-01-01 00:00:00            6   0.0\n            1   2023-01-01 01:00:00            6   1.0\n            2   2023-01-01 02:00:00            6   2.0\n            3   2023-01-01 03:00:00            6   3.0\n            4   2023-01-01 04:00:00            6   4.0\n            ..                  ...          ...   ...\n            308 2023-01-13 20:00:00            4  20.0\n            309 2023-01-13 21:00:00            4  21.0\n            310 2023-01-13 22:00:00            4  22.0\n            311 2023-01-13 23:00:00            4  23.0\n            312 2023-01-14 00:00:00            5   0.0\n\n            [313 rows x 3 columns]\n            ```\n\n        \"\"\"\n        name = self._obj.name or \"timestamp\"\n        transformer = create_timestamp_feature_pipeline(\n            timestamp_col=name,\n            discretize=discretize,\n            minutes=minutes,\n            create_vocab=create_vocab,\n        )\n\n        return transformer.fit_transform(self._obj.rename(name).to_frame())\n\n    def conditional_probabilities(\n        self,\n        *,\n        level: int | str = 0,\n    ) -&gt; pd.Series:\n        \"\"\"Calculate conditional probabilities for each the row over the level.\n\n        Args:\n            level: level of the column MultiIndex.\n                Default 0 or day_of_week\n\n        Returns:\n            Series with conditional probabilities\n\n        \"\"\"\n\n        if not isinstance(self._obj.index, pd.MultiIndex):\n            raise ValueError(\n                \"Series is expected to have a MultiIndex with the last column as the vocab.\"\n            )\n\n        return self._obj.div(self._obj.groupby(level=level).sum(), level=level)\n\n    def plot(\n        self,\n        *,\n        duration: int = 5,\n        alpha: float = None,\n        cmap=None,\n        day_labeler: DayLabeler = DayLabeler(),\n        time_labeler: TimeLabeler = TimeLabeler(),\n        grid_lines: GridLines = GridLines(),\n        monday_start: bool = True,\n        ax: plt.Axes | None = None,\n    ) -&gt; plt.Axes:\n        \"\"\"Plot Series of timestamps as a calendar.\n\n        Args:\n            duration: duration of each event in minutes\n            alpha: alpha value for the color\n            cmap: function that maps floats to string colors\n            day_labeler: DayLabeler instance\n            time_labeler: TimeLabeler instance\n            grid_lines: GridLines instance\n            monday_start: whether to start the week on Monday or Sunday\n            ax: matplotlib axis to plot on\n\n        Returns:\n            Modified matplotlib axis\n\n        \"\"\"\n        tmp_name = \"tmp_name\"\n        config = StartEndConfig(start=tmp_name, end=None, minutes=duration)\n\n        return plot_dataframe_as_calendar(\n            self._obj.rename(tmp_name).to_frame(),\n            config=config,\n            alpha=alpha,\n            cmap=cmap,\n            monday_start=monday_start,\n            day_labeler=day_labeler,\n            time_labeler=time_labeler,\n            grid_lines=grid_lines,\n            ax=ax,\n        )\n\n    def plot_row(\n        self,\n        *,\n        alpha: float = None,\n        cmap=None,\n        day_labeler: DayLabeler = DayLabeler(),\n        time_labeler: TimeLabeler = TimeLabeler(),\n        grid_lines: GridLines = GridLines(),\n        monday_start: bool = True,\n        ax: plt.Axes | None = None,\n    ) -&gt; plt.Axes:\n        \"\"\"Plot Series of timestamps as a calendar.\n\n        Args:\n            alpha: alpha value for the color\n            cmap: function that maps floats to string colors\n            monday_start: whether to start the week on Monday or Sunday\n            ax: matplotlib axis to plot on\n\n        Returns:\n            Modified matplotlib axis\n\n        \"\"\"\n        return plot_series_as_calendar(\n            self._obj,\n            alpha=alpha,\n            cmap=cmap,\n            ax=ax,\n            monday_start=monday_start,\n            day_labeler=day_labeler,\n            time_labeler=time_labeler,\n            grid_lines=grid_lines,\n        )\n</code></pre>"},{"location":"modules/extensions/#latent_calendar.extensions.SeriesAccessor.aggregate_events","title":"<code>aggregate_events(minutes=60, as_multiindex=True)</code>","text":"<p>Transform event level Series to row of wide format.</p> <p>Parameters:</p> Name Type Description Default <code>minutes</code> <code>int</code> <p>The number of minutes to discretize by.</p> <code>60</code> <code>as_multiindex</code> <code>bool</code> <p>whether to use MultiIndex columns</p> <code>True</code> <p>Returns:</p> Type Description <code>Series</code> <p>Series that would be row of wide format</p> <p>Examples:</p> <p>Discretize datetime Series to 30 minutes</p> <pre><code>import pandas as pd\n\nimport matplotlib.pyplot as plt\n\nfrom latent_calendar.datasets import load_chicago_bikes\n\ndf_trips = load_chicago_bikes()\n\nstart_times = df_trips[\"started_at\"]\n\nagg_start_times = start_times.cal.aggregate_events(minutes=30)\nagg_start_times.cal.plot_row()\nplt.show()\n</code></pre> Source code in <code>latent_calendar/extensions.py</code> <pre><code>def aggregate_events(\n    self,\n    minutes: int = 60,\n    as_multiindex: bool = True,\n) -&gt; pd.Series:\n    \"\"\"Transform event level Series to row of wide format.\n\n    Args:\n        minutes: The number of minutes to discretize by.\n        as_multiindex: whether to use MultiIndex columns\n\n    Returns:\n        Series that would be row of wide format\n\n    Examples:\n        Discretize datetime Series to 30 minutes\n\n        ```python\n        import pandas as pd\n\n        import matplotlib.pyplot as plt\n\n        from latent_calendar.datasets import load_chicago_bikes\n\n        df_trips = load_chicago_bikes()\n\n        start_times = df_trips[\"started_at\"]\n\n        agg_start_times = start_times.cal.aggregate_events(minutes=30)\n        agg_start_times.cal.plot_row()\n        plt.show()\n\n\n        ```\n\n\n    \"\"\"\n    name = self._obj.name or \"timestamp\"\n    return (\n        self._obj.rename(name)\n        .to_frame()\n        .assign(tmp=1)\n        .cal.aggregate_events(\n            by=\"tmp\",\n            timestamp_col=name,\n            minutes=minutes,\n            as_multiindex=as_multiindex,\n        )\n        .iloc[0]\n        .rename(name)\n    )\n</code></pre>"},{"location":"modules/extensions/#latent_calendar.extensions.SeriesAccessor.conditional_probabilities","title":"<code>conditional_probabilities(*, level=0)</code>","text":"<p>Calculate conditional probabilities for each the row over the level.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>int | str</code> <p>level of the column MultiIndex. Default 0 or day_of_week</p> <code>0</code> <p>Returns:</p> Type Description <code>Series</code> <p>Series with conditional probabilities</p> Source code in <code>latent_calendar/extensions.py</code> <pre><code>def conditional_probabilities(\n    self,\n    *,\n    level: int | str = 0,\n) -&gt; pd.Series:\n    \"\"\"Calculate conditional probabilities for each the row over the level.\n\n    Args:\n        level: level of the column MultiIndex.\n            Default 0 or day_of_week\n\n    Returns:\n        Series with conditional probabilities\n\n    \"\"\"\n\n    if not isinstance(self._obj.index, pd.MultiIndex):\n        raise ValueError(\n            \"Series is expected to have a MultiIndex with the last column as the vocab.\"\n        )\n\n    return self._obj.div(self._obj.groupby(level=level).sum(), level=level)\n</code></pre>"},{"location":"modules/extensions/#latent_calendar.extensions.SeriesAccessor.plot","title":"<code>plot(*, duration=5, alpha=None, cmap=None, day_labeler=DayLabeler(), time_labeler=TimeLabeler(), grid_lines=GridLines(), monday_start=True, ax=None)</code>","text":"<p>Plot Series of timestamps as a calendar.</p> <p>Parameters:</p> Name Type Description Default <code>duration</code> <code>int</code> <p>duration of each event in minutes</p> <code>5</code> <code>alpha</code> <code>float</code> <p>alpha value for the color</p> <code>None</code> <code>cmap</code> <p>function that maps floats to string colors</p> <code>None</code> <code>day_labeler</code> <code>DayLabeler</code> <p>DayLabeler instance</p> <code>DayLabeler()</code> <code>time_labeler</code> <code>TimeLabeler</code> <p>TimeLabeler instance</p> <code>TimeLabeler()</code> <code>grid_lines</code> <code>GridLines</code> <p>GridLines instance</p> <code>GridLines()</code> <code>monday_start</code> <code>bool</code> <p>whether to start the week on Monday or Sunday</p> <code>True</code> <code>ax</code> <code>Axes | None</code> <p>matplotlib axis to plot on</p> <code>None</code> <p>Returns:</p> Type Description <code>Axes</code> <p>Modified matplotlib axis</p> Source code in <code>latent_calendar/extensions.py</code> <pre><code>def plot(\n    self,\n    *,\n    duration: int = 5,\n    alpha: float = None,\n    cmap=None,\n    day_labeler: DayLabeler = DayLabeler(),\n    time_labeler: TimeLabeler = TimeLabeler(),\n    grid_lines: GridLines = GridLines(),\n    monday_start: bool = True,\n    ax: plt.Axes | None = None,\n) -&gt; plt.Axes:\n    \"\"\"Plot Series of timestamps as a calendar.\n\n    Args:\n        duration: duration of each event in minutes\n        alpha: alpha value for the color\n        cmap: function that maps floats to string colors\n        day_labeler: DayLabeler instance\n        time_labeler: TimeLabeler instance\n        grid_lines: GridLines instance\n        monday_start: whether to start the week on Monday or Sunday\n        ax: matplotlib axis to plot on\n\n    Returns:\n        Modified matplotlib axis\n\n    \"\"\"\n    tmp_name = \"tmp_name\"\n    config = StartEndConfig(start=tmp_name, end=None, minutes=duration)\n\n    return plot_dataframe_as_calendar(\n        self._obj.rename(tmp_name).to_frame(),\n        config=config,\n        alpha=alpha,\n        cmap=cmap,\n        monday_start=monday_start,\n        day_labeler=day_labeler,\n        time_labeler=time_labeler,\n        grid_lines=grid_lines,\n        ax=ax,\n    )\n</code></pre>"},{"location":"modules/extensions/#latent_calendar.extensions.SeriesAccessor.plot_row","title":"<code>plot_row(*, alpha=None, cmap=None, day_labeler=DayLabeler(), time_labeler=TimeLabeler(), grid_lines=GridLines(), monday_start=True, ax=None)</code>","text":"<p>Plot Series of timestamps as a calendar.</p> <p>Parameters:</p> Name Type Description Default <code>alpha</code> <code>float</code> <p>alpha value for the color</p> <code>None</code> <code>cmap</code> <p>function that maps floats to string colors</p> <code>None</code> <code>monday_start</code> <code>bool</code> <p>whether to start the week on Monday or Sunday</p> <code>True</code> <code>ax</code> <code>Axes | None</code> <p>matplotlib axis to plot on</p> <code>None</code> <p>Returns:</p> Type Description <code>Axes</code> <p>Modified matplotlib axis</p> Source code in <code>latent_calendar/extensions.py</code> <pre><code>def plot_row(\n    self,\n    *,\n    alpha: float = None,\n    cmap=None,\n    day_labeler: DayLabeler = DayLabeler(),\n    time_labeler: TimeLabeler = TimeLabeler(),\n    grid_lines: GridLines = GridLines(),\n    monday_start: bool = True,\n    ax: plt.Axes | None = None,\n) -&gt; plt.Axes:\n    \"\"\"Plot Series of timestamps as a calendar.\n\n    Args:\n        alpha: alpha value for the color\n        cmap: function that maps floats to string colors\n        monday_start: whether to start the week on Monday or Sunday\n        ax: matplotlib axis to plot on\n\n    Returns:\n        Modified matplotlib axis\n\n    \"\"\"\n    return plot_series_as_calendar(\n        self._obj,\n        alpha=alpha,\n        cmap=cmap,\n        ax=ax,\n        monday_start=monday_start,\n        day_labeler=day_labeler,\n        time_labeler=time_labeler,\n        grid_lines=grid_lines,\n    )\n</code></pre>"},{"location":"modules/extensions/#latent_calendar.extensions.SeriesAccessor.timestamp_features","title":"<code>timestamp_features(discretize=True, minutes=60, create_vocab=True)</code>","text":"<p>Create day of week and proportion into day columns.</p> <p>Exposed as a method on Series for convenience.</p> <p>Parameters:</p> Name Type Description Default <code>discretize</code> <code>bool</code> <p>Whether to discretize the hour column.</p> <code>True</code> <code>minutes</code> <code>int</code> <p>The number of minutes to discretize by. Ingored if <code>discretize</code> is False.</p> <code>60</code> <code>create_vocab</code> <code>bool</code> <p>Whether to create the vocab column.</p> <code>True</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with features</p> <p>Examples:</p> <p>Create the features for some dates</p> <pre><code>ser = pd.Series(pd.date_range(\"2023-01-01\", \"2023-01-14\", freq=\"h\"))\n\nser.cal.timestamp_features()\n</code></pre> <pre><code>            timestamp  day_of_week  hour\n0   2023-01-01 00:00:00            6   0.0\n1   2023-01-01 01:00:00            6   1.0\n2   2023-01-01 02:00:00            6   2.0\n3   2023-01-01 03:00:00            6   3.0\n4   2023-01-01 04:00:00            6   4.0\n..                  ...          ...   ...\n308 2023-01-13 20:00:00            4  20.0\n309 2023-01-13 21:00:00            4  21.0\n310 2023-01-13 22:00:00            4  22.0\n311 2023-01-13 23:00:00            4  23.0\n312 2023-01-14 00:00:00            5   0.0\n\n[313 rows x 3 columns]\n</code></pre> Source code in <code>latent_calendar/extensions.py</code> <pre><code>def timestamp_features(\n    self, discretize: bool = True, minutes: int = 60, create_vocab: bool = True\n) -&gt; pd.DataFrame:\n    \"\"\"Create day of week and proportion into day columns.\n\n    Exposed as a method on Series for convenience.\n\n    Args:\n        discretize: Whether to discretize the hour column.\n        minutes: The number of minutes to discretize by. Ingored if `discretize` is False.\n        create_vocab: Whether to create the vocab column.\n\n    Returns:\n        DataFrame with features\n\n    Examples:\n        Create the features for some dates\n\n        ```python\n        ser = pd.Series(pd.date_range(\"2023-01-01\", \"2023-01-14\", freq=\"h\"))\n\n        ser.cal.timestamp_features()\n        ```\n\n        ```text\n                    timestamp  day_of_week  hour\n        0   2023-01-01 00:00:00            6   0.0\n        1   2023-01-01 01:00:00            6   1.0\n        2   2023-01-01 02:00:00            6   2.0\n        3   2023-01-01 03:00:00            6   3.0\n        4   2023-01-01 04:00:00            6   4.0\n        ..                  ...          ...   ...\n        308 2023-01-13 20:00:00            4  20.0\n        309 2023-01-13 21:00:00            4  21.0\n        310 2023-01-13 22:00:00            4  22.0\n        311 2023-01-13 23:00:00            4  23.0\n        312 2023-01-14 00:00:00            5   0.0\n\n        [313 rows x 3 columns]\n        ```\n\n    \"\"\"\n    name = self._obj.name or \"timestamp\"\n    transformer = create_timestamp_feature_pipeline(\n        timestamp_col=name,\n        discretize=discretize,\n        minutes=minutes,\n        create_vocab=create_vocab,\n    )\n\n    return transformer.fit_transform(self._obj.rename(name).to_frame())\n</code></pre>"},{"location":"modules/generate/","title":"Generate","text":"<p>Generate some fake data for various purposes.</p>"},{"location":"modules/generate/#latent_calendar.generate.sample_from_lda","title":"<code>sample_from_lda(components_prior, components_time_slots_prior, n_samples, random_state=None)</code>","text":"<p>Sample from LDA model.</p> <p>Parameters:</p> Name Type Description Default <code>components_prior</code> <code>ndarray | TensorVariable</code> <p>prior probability of each component (n_components, )</p> required <code>components_time_slots_prior</code> <code>ndarray | TensorVariable</code> <p>prior for time slots (n_components, n_time_slots)</p> required <code>n_samples</code> <code>ndarray</code> <p>number of samples for each user (n_user, )</p> required <code>random_state</code> <code>int | None</code> <p>random state for sampling</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[DataFrame, DataFrame]</code> <p>probability DataFrame (n_user, n_components) and event count DataFrame with (n_user, n_time_slots) with each row summing up to <code>n</code></p> Source code in <code>latent_calendar/generate.py</code> <pre><code>def sample_from_lda(\n    components_prior: np.ndarray | TensorVariable,\n    components_time_slots_prior: np.ndarray | TensorVariable,\n    n_samples: np.ndarray,\n    random_state: int | None = None,\n) -&gt; tuple[pd.DataFrame, pd.DataFrame]:\n    \"\"\"Sample from LDA model.\n\n    Args:\n        components_prior: prior probability of each component (n_components, )\n        components_time_slots_prior: prior for time slots (n_components, n_time_slots)\n        n_samples: number of samples for each user (n_user, )\n        random_state: random state for sampling\n\n    Returns:\n        probability DataFrame (n_user, n_components) and event count DataFrame with (n_user, n_time_slots) with each row summing up to `n`\n\n    \"\"\"\n    rng = np.random.default_rng(random_state)\n\n    user_travel_style_data = []\n    user_time_slot_data = []\n\n    travel_style = pm.Dirichlet.dist(components_prior)\n    time_slot_styles = pm.Dirichlet.dist(components_time_slots_prior)\n\n    for n in n_samples:\n        _, user_time_slots = define_single_user_samples(\n            travel_style, time_slot_styles, n_samples=int(n)\n        )\n\n        user_travel_style_samples, user_time_slot_samples = pm.draw(\n            [travel_style, user_time_slots.sum(axis=0)], draws=1, random_seed=rng\n        )\n\n        user_travel_style_data.append(user_travel_style_samples)\n        user_time_slot_data.append(user_time_slot_samples)\n\n    df_user_travel_style = pd.DataFrame(user_travel_style_data)\n    df_user_time_slots = pd.DataFrame(user_time_slot_data)\n\n    return df_user_travel_style, df_user_time_slots\n</code></pre>"},{"location":"modules/generate/#latent_calendar.generate.wide_format_dataframe","title":"<code>wide_format_dataframe(n_rows, rate=1.0, random_state=None)</code>","text":"<p>Generate some data from Poisson distribution.</p> <p>Parameters:</p> Name Type Description Default <code>n_rows</code> <code>int</code> <p>number of rows to generate</p> required <code>rate</code> <code>float</code> <p>rate parameter for Poisson distribution</p> <code>1.0</code> <code>random_state</code> <code>int | None</code> <p>random state for reproducibility</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with columns from FULL_VOCAB and n_rows rows</p> Source code in <code>latent_calendar/generate.py</code> <pre><code>def wide_format_dataframe(\n    n_rows: int,\n    rate: float = 1.0,\n    random_state: int | None = None,\n) -&gt; pd.DataFrame:\n    \"\"\"Generate some data from Poisson distribution.\n\n    Args:\n        n_rows: number of rows to generate\n        rate: rate parameter for Poisson distribution\n        random_state: random state for reproducibility\n\n    Returns:\n        DataFrame with columns from FULL_VOCAB and n_rows rows\n\n    \"\"\"\n    if random_state is not None:\n        np.random.seed(random_state)\n\n    data = np.random.poisson(lam=rate, size=(n_rows, len(FULL_VOCAB)))\n\n    return pd.DataFrame(data, columns=FULL_VOCAB)\n</code></pre>"},{"location":"modules/model/","title":"Model","text":"<p>Models for the joint distribution of weekly calendar data.</p> <pre><code>model = LatentCalendar(n_components=3, random_state=42)\n\nX = df_wide.to_numpy()\nmodel.fit(X)\n\nX_latent = model.transform(X)\nX_pred = model.predict(X)\n</code></pre>"},{"location":"modules/model/#latent_calendar.model.latent_calendar.ConjugateModel","title":"<code>ConjugateModel</code>","text":"<p>               Bases: <code>BaseEstimator</code>, <code>TransformerMixin</code></p> <p>Conjugate model for the calendar joint distribution.</p> <p>This is a wrapper around the conjugate model for the multinomial distribution. It is a wrapper around the Dirichlet distribution.</p> <p>This doesn't use dimensionality reduction, but it does use the conjugate model.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>ndarray | None</code> <p>(n_times,) prior for each hour of the day. If None, then the prior is the average of the data.</p> <code>None</code> Source code in <code>latent_calendar/model/latent_calendar.py</code> <pre><code>class ConjugateModel(BaseEstimator, TransformerMixin):\n    \"\"\"Conjugate model for the calendar joint distribution.\n\n    This is a wrapper around the conjugate model for the multinomial\n    distribution. It is a wrapper around the Dirichlet distribution.\n\n    This doesn't use dimensionality reduction, but it does use the\n    conjugate model.\n\n    Args:\n        a: (n_times,) prior for each hour of the day. If None, then\n            the prior is the average of the data.\n\n    \"\"\"\n\n    def __init__(self, a: np.ndarray | None = None) -&gt; None:\n        self.a = a\n\n    def fit(self, X, y=None) -&gt; \"ConjugateModel\":\n        \"\"\"Fit the conjugate model.\"\"\"\n        if self.a is None:\n            self.a = hourly_prior(X)\n\n        self.prior_ = Dirichlet(alpha=self.a)\n        return self\n\n    def transform(self, X, y=None) -&gt; np.ndarray:\n        return multinomial_dirichlet(x=X, prior=self.prior_).dist.mean()\n\n    def predict(self, X, y=None) -&gt; np.ndarray:\n        return self.transform(X, y=y)\n</code></pre>"},{"location":"modules/model/#latent_calendar.model.latent_calendar.ConjugateModel.fit","title":"<code>fit(X, y=None)</code>","text":"<p>Fit the conjugate model.</p> Source code in <code>latent_calendar/model/latent_calendar.py</code> <pre><code>def fit(self, X, y=None) -&gt; \"ConjugateModel\":\n    \"\"\"Fit the conjugate model.\"\"\"\n    if self.a is None:\n        self.a = hourly_prior(X)\n\n    self.prior_ = Dirichlet(alpha=self.a)\n    return self\n</code></pre>"},{"location":"modules/model/#latent_calendar.model.latent_calendar.DummyModel","title":"<code>DummyModel</code>","text":"<p>               Bases: <code>LatentCalendar</code></p> <p>Return even probability of a latent.</p> <p>This can be used as the worse possible baseline.</p> Source code in <code>latent_calendar/model/latent_calendar.py</code> <pre><code>class DummyModel(LatentCalendar):\n    \"\"\"Return even probability of a latent.\n\n    This can be used as the worse possible baseline.\n\n    \"\"\"\n\n    def fit(self, X, y=None) -&gt; \"DummyModel\":\n        \"\"\"All components are equal probabilty of every hour.\"\"\"\n        # Even probabilty for every thing\n        self.n_components = 1\n        TIME_SLOTS = X.shape[1]\n        EVEN_PROBABILITY = 1 / TIME_SLOTS\n        self.components_ = np.ones((self.n_components, TIME_SLOTS)) * EVEN_PROBABILITY\n\n        return self\n\n    def transform(self, X, y=None) -&gt; np.ndarray:\n        \"\"\"Everyone has equal probability of being in each group.\"\"\"\n        nrows = len(X)\n\n        return np.ones((nrows, self.n_components)) / self.n_components\n\n    @classmethod\n    def create(cls) -&gt; \"DummyModel\":\n        \"\"\"Return a dummy model ready for transforming and predicting.\"\"\"\n        model = cls()\n        model.fit(X=None)\n\n        return model\n\n    @classmethod\n    def from_prior(cls, prior: np.ndarray) -&gt; \"DummyModel\":\n        \"\"\"Return a dummy model from a prior.\"\"\"\n        model = cls()\n        model.components_ = prior[np.newaxis, :]\n        model.n_components = 1\n\n        return model\n</code></pre>"},{"location":"modules/model/#latent_calendar.model.latent_calendar.DummyModel.create","title":"<code>create()</code>  <code>classmethod</code>","text":"<p>Return a dummy model ready for transforming and predicting.</p> Source code in <code>latent_calendar/model/latent_calendar.py</code> <pre><code>@classmethod\ndef create(cls) -&gt; \"DummyModel\":\n    \"\"\"Return a dummy model ready for transforming and predicting.\"\"\"\n    model = cls()\n    model.fit(X=None)\n\n    return model\n</code></pre>"},{"location":"modules/model/#latent_calendar.model.latent_calendar.DummyModel.fit","title":"<code>fit(X, y=None)</code>","text":"<p>All components are equal probabilty of every hour.</p> Source code in <code>latent_calendar/model/latent_calendar.py</code> <pre><code>def fit(self, X, y=None) -&gt; \"DummyModel\":\n    \"\"\"All components are equal probabilty of every hour.\"\"\"\n    # Even probabilty for every thing\n    self.n_components = 1\n    TIME_SLOTS = X.shape[1]\n    EVEN_PROBABILITY = 1 / TIME_SLOTS\n    self.components_ = np.ones((self.n_components, TIME_SLOTS)) * EVEN_PROBABILITY\n\n    return self\n</code></pre>"},{"location":"modules/model/#latent_calendar.model.latent_calendar.DummyModel.from_prior","title":"<code>from_prior(prior)</code>  <code>classmethod</code>","text":"<p>Return a dummy model from a prior.</p> Source code in <code>latent_calendar/model/latent_calendar.py</code> <pre><code>@classmethod\ndef from_prior(cls, prior: np.ndarray) -&gt; \"DummyModel\":\n    \"\"\"Return a dummy model from a prior.\"\"\"\n    model = cls()\n    model.components_ = prior[np.newaxis, :]\n    model.n_components = 1\n\n    return model\n</code></pre>"},{"location":"modules/model/#latent_calendar.model.latent_calendar.DummyModel.transform","title":"<code>transform(X, y=None)</code>","text":"<p>Everyone has equal probability of being in each group.</p> Source code in <code>latent_calendar/model/latent_calendar.py</code> <pre><code>def transform(self, X, y=None) -&gt; np.ndarray:\n    \"\"\"Everyone has equal probability of being in each group.\"\"\"\n    nrows = len(X)\n\n    return np.ones((nrows, self.n_components)) / self.n_components\n</code></pre>"},{"location":"modules/model/#latent_calendar.model.latent_calendar.LatentCalendar","title":"<code>LatentCalendar</code>","text":"<p>               Bases: <code>LatentDirichletAllocation</code></p> <p>Model weekly calendar data as a mixture of multinomial distributions.</p> <p>Adapted from sklearn's Latent Dirichlet Allocation model.</p> <p>Provides a <code>predict</code> method that returns the marginal probability of each time slot for a given row and a <code>transform</code> method that returns the latent representation of each row.</p> Source code in <code>latent_calendar/model/latent_calendar.py</code> <pre><code>class LatentCalendar(BaseLDA):\n    \"\"\"Model weekly calendar data as a mixture of multinomial distributions.\n\n    Adapted from sklearn's [Latent Dirichlet Allocation](https://scikit-learn.org/stable/modules/generated/sklearn.decomposition.LatentDirichletAllocation.html) model.\n\n    Provides a `predict` method that returns the marginal probability of each time slot for a given row and\n    a `transform` method that returns the latent representation of each row.\n\n    \"\"\"\n\n    @property\n    def normalized_components_(self) -&gt; np.ndarray:\n        \"\"\"Components that each sum to 1.\"\"\"\n        return self.components_ / self.components_.sum(axis=1)[:, np.newaxis]\n\n    def joint_distribution(self, X_latent: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Marginalize out the components.\"\"\"\n        return joint_distribution(\n            X_latent=X_latent, components=self.normalized_components_\n        )\n\n    def predict(self, X: np.ndarray, y=None) -&gt; np.ndarray:\n        \"\"\"Return the marginal probabilities for a given row.\n\n        Marginalize out the loads via law of total probability\n\n        $$P[time=t | Row=r] = \\sum_{l=0}^{c} P[time=t | L=l, Row=r] * P[L=l | Row=r]$$\n\n        \"\"\"\n        # (n, n_components)\n        X_latent = self.transform(X)\n\n        return self.joint_distribution(X_latent=X_latent)\n\n    @property\n    def component_distribution_(self) -&gt; np.ndarray:\n        \"\"\"Population frequency of each component.\"\"\"\n        return self.components_.sum(axis=1) / self.components_.sum()\n</code></pre>"},{"location":"modules/model/#latent_calendar.model.latent_calendar.LatentCalendar.component_distribution_","title":"<code>component_distribution_</code>  <code>property</code>","text":"<p>Population frequency of each component.</p>"},{"location":"modules/model/#latent_calendar.model.latent_calendar.LatentCalendar.normalized_components_","title":"<code>normalized_components_</code>  <code>property</code>","text":"<p>Components that each sum to 1.</p>"},{"location":"modules/model/#latent_calendar.model.latent_calendar.LatentCalendar.joint_distribution","title":"<code>joint_distribution(X_latent)</code>","text":"<p>Marginalize out the components.</p> Source code in <code>latent_calendar/model/latent_calendar.py</code> <pre><code>def joint_distribution(self, X_latent: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Marginalize out the components.\"\"\"\n    return joint_distribution(\n        X_latent=X_latent, components=self.normalized_components_\n    )\n</code></pre>"},{"location":"modules/model/#latent_calendar.model.latent_calendar.LatentCalendar.predict","title":"<code>predict(X, y=None)</code>","text":"<p>Return the marginal probabilities for a given row.</p> <p>Marginalize out the loads via law of total probability</p> \\[P[time=t | Row=r] = \\sum_{l=0}^{c} P[time=t | L=l, Row=r] * P[L=l | Row=r]\\] Source code in <code>latent_calendar/model/latent_calendar.py</code> <pre><code>def predict(self, X: np.ndarray, y=None) -&gt; np.ndarray:\n    \"\"\"Return the marginal probabilities for a given row.\n\n    Marginalize out the loads via law of total probability\n\n    $$P[time=t | Row=r] = \\sum_{l=0}^{c} P[time=t | L=l, Row=r] * P[L=l | Row=r]$$\n\n    \"\"\"\n    # (n, n_components)\n    X_latent = self.transform(X)\n\n    return self.joint_distribution(X_latent=X_latent)\n</code></pre>"},{"location":"modules/model/#latent_calendar.model.latent_calendar.MarginalModel","title":"<code>MarginalModel</code>","text":"<p>               Bases: <code>LatentCalendar</code></p> Source code in <code>latent_calendar/model/latent_calendar.py</code> <pre><code>class MarginalModel(LatentCalendar):\n    def fit(self, X, y=None) -&gt; \"MarginalModel\":\n        \"\"\"Just sum over all the rows.\"\"\"\n        self.n_components = 1\n        # (1, n_times)\n        self.components_ = X.sum(axis=0)[np.newaxis, :]\n\n        return self\n\n    def transform(self, X, y=None) -&gt; np.ndarray:\n        \"\"\"There is only one component to be a part of.\"\"\"\n        nrows = len(X)\n\n        # (nrows, 1)\n        return np.repeat(1, nrows)[:, np.newaxis]\n</code></pre>"},{"location":"modules/model/#latent_calendar.model.latent_calendar.MarginalModel.fit","title":"<code>fit(X, y=None)</code>","text":"<p>Just sum over all the rows.</p> Source code in <code>latent_calendar/model/latent_calendar.py</code> <pre><code>def fit(self, X, y=None) -&gt; \"MarginalModel\":\n    \"\"\"Just sum over all the rows.\"\"\"\n    self.n_components = 1\n    # (1, n_times)\n    self.components_ = X.sum(axis=0)[np.newaxis, :]\n\n    return self\n</code></pre>"},{"location":"modules/model/#latent_calendar.model.latent_calendar.MarginalModel.transform","title":"<code>transform(X, y=None)</code>","text":"<p>There is only one component to be a part of.</p> Source code in <code>latent_calendar/model/latent_calendar.py</code> <pre><code>def transform(self, X, y=None) -&gt; np.ndarray:\n    \"\"\"There is only one component to be a part of.\"\"\"\n    nrows = len(X)\n\n    # (nrows, 1)\n    return np.repeat(1, nrows)[:, np.newaxis]\n</code></pre>"},{"location":"modules/model/#latent_calendar.model.latent_calendar.constant_prior","title":"<code>constant_prior(X, value=1.0)</code>","text":"<p>Return the prior for each hour of the day.</p> <p>This is the average of all the rows.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>ndarray</code> <p>(nrows, n_times)</p> required Source code in <code>latent_calendar/model/latent_calendar.py</code> <pre><code>def constant_prior(X: np.ndarray, value: float = 1.0) -&gt; np.ndarray:\n    \"\"\"Return the prior for each hour of the day.\n\n    This is the average of all the rows.\n\n    Args:\n        X: (nrows, n_times)\n    \"\"\"\n    TIME_SLOTS = X.shape[1]\n    return np.repeat(value, TIME_SLOTS)\n</code></pre>"},{"location":"modules/model/#latent_calendar.model.latent_calendar.hourly_prior","title":"<code>hourly_prior(X)</code>","text":"<p>Return the prior for each hour of the day.</p> <p>This is the average of all the rows.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>ndarray</code> <p>(nrows, n_times)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>(n_times,)</p> Source code in <code>latent_calendar/model/latent_calendar.py</code> <pre><code>def hourly_prior(X: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Return the prior for each hour of the day.\n\n    This is the average of all the rows.\n\n    Args:\n        X: (nrows, n_times)\n\n    Returns:\n        (n_times,)\n\n    \"\"\"\n    return (X &gt; 0).sum(axis=0) / len(X)\n</code></pre>"},{"location":"modules/model/#latent_calendar.model.latent_calendar.joint_distribution","title":"<code>joint_distribution(X_latent, components)</code>","text":"<p>Marginalize out the components.</p> Source code in <code>latent_calendar/model/latent_calendar.py</code> <pre><code>def joint_distribution(X_latent: np.ndarray, components: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Marginalize out the components.\"\"\"\n    return X_latent @ components\n</code></pre>"},{"location":"modules/model/#latent_calendar.model.utils.predict_on_dataframe","title":"<code>predict_on_dataframe(df, model)</code>","text":"<p>Small wrapper to predict on DataFrame and keep same columns and index.</p> Source code in <code>latent_calendar/model/utils.py</code> <pre><code>def predict_on_dataframe(df: pd.DataFrame, model: LatentCalendar) -&gt; pd.DataFrame:\n    \"\"\"Small wrapper to predict on DataFrame and keep same columns and index.\"\"\"\n    return pd.DataFrame(\n        model.predict(df.to_numpy()), columns=df.columns, index=df.index\n    )\n</code></pre>"},{"location":"modules/model/#latent_calendar.model.utils.transform_on_dataframe","title":"<code>transform_on_dataframe(df, model)</code>","text":"<p>Small wrapper to transform on DataFrame and keep index.</p> Source code in <code>latent_calendar/model/utils.py</code> <pre><code>def transform_on_dataframe(df: pd.DataFrame, model: LatentCalendar) -&gt; pd.DataFrame:\n    \"\"\"Small wrapper to transform on DataFrame and keep index.\"\"\"\n    return pd.DataFrame(model.transform(df.to_numpy()), index=df.index)\n</code></pre>"},{"location":"modules/plot/","title":"Plot","text":"<p>Plotting functions for latent calendar.</p> <p>These functions and classes build every calendar plot.</p>"},{"location":"modules/segments/","title":"Segments","text":"<p>Create hand picked segments on the calendar.</p> <p>Examples:</p> <p>Create some segments for a calendar:</p> <pre><code>mornings = create_box_segment(\n    day_start=0, day_end=7, hour_start=6, hour_end=11, name=\"Mornings\"\n)\nafternoons = create_box_segment(\n    day_start=0, day_end=7, hour_start=11, hour_end=16, name=\"Afternoons\"\n)\nevenings = create_box_segment(\n    day_start=0, day_end=7, hour_start=16, hour_end=21, name=\"Evenings\"\n)\n\ndf_segments = stack_segments([\n    mornings,\n    afternoons,\n    evenings,\n])\n\ndf_segments.cal.plot_by_row()\n</code></pre> <p></p> <p>Processing off calendar distribution.</p>"},{"location":"modules/segments/#latent_calendar.segments.hand_picked.create_blank_segment_series","title":"<code>create_blank_segment_series()</code>","text":"<p>Helper for making segments programatically.</p> Source code in <code>latent_calendar/segments/hand_picked.py</code> <pre><code>def create_blank_segment_series() -&gt; pd.Series:\n    \"\"\"Helper for making segments programatically.\"\"\"\n    return pd.Series(0, index=FULL_VOCAB)\n</code></pre>"},{"location":"modules/segments/#latent_calendar.segments.hand_picked.create_box_segment","title":"<code>create_box_segment(day_start, day_end, hour_start, hour_end, name=None)</code>","text":"<p>Programmatically make segment of box described by inputs.</p> Source code in <code>latent_calendar/segments/hand_picked.py</code> <pre><code>def create_box_segment(\n    day_start: int,\n    day_end: int,\n    hour_start: int,\n    hour_end: int,\n    name: str | None = None,\n) -&gt; pd.Series:\n    \"\"\"Programmatically make segment of box described by inputs.\"\"\"\n    ser = create_blank_segment_series()\n\n    for dow in range(day_start, day_end):\n        start = DOWHour(dow=dow, hour=hour_start)\n        end = DOWHour(dow=dow, hour=hour_end)\n\n        ser += create_series_for_range(start=start, end=end)\n\n    name = name or f\"{day_start}-{day_end} {hour_start}-{hour_end}\"\n    return ser.rename(name)\n</code></pre>"},{"location":"modules/segments/#latent_calendar.segments.hand_picked.create_dow_segments","title":"<code>create_dow_segments()</code>","text":"<p>Programmatically make the DOW segments.</p> <p>Each row is just each day of the week.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame in the df_segments wide format</p> Source code in <code>latent_calendar/segments/hand_picked.py</code> <pre><code>def create_dow_segments() -&gt; pd.DataFrame:\n    \"\"\"Programmatically make the DOW segments.\n\n    Each row is just each day of the week.\n\n    Returns:\n        DataFrame in the df_segments wide format\n\n    \"\"\"\n    segments = []\n\n    for i, day in enumerate(create_default_days()):\n        day_number = str(i).zfill(2)\n        name = f\"{day_number}-{day}\"\n\n        start = DOWHour(dow=i, hour=0)\n        end = DOWHour(dow=i, hour=24)\n\n        segments.append(create_hourly_segment(start=start, end=end, name=name))\n\n    return stack_segments(segments)\n</code></pre>"},{"location":"modules/segments/#latent_calendar.segments.hand_picked.create_empty_template","title":"<code>create_empty_template()</code>","text":"<p>Create blank template in order</p> Source code in <code>latent_calendar/segments/hand_picked.py</code> <pre><code>def create_empty_template() -&gt; pd.DataFrame:\n    \"\"\"Create blank template in order\"\"\"\n    index = pd.Index(range(HOURS_IN_DAY), name=\"hour_start\")\n    return pd.DataFrame(\n        np.nan,\n        index=index,\n        columns=create_default_days(),\n    )\n</code></pre>"},{"location":"modules/segments/#latent_calendar.segments.hand_picked.create_every_hour_segments","title":"<code>create_every_hour_segments()</code>","text":"<p>Programmatically segments for every hour</p> <p>Each row is just each time slot</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame in the df_segments wide format</p> Source code in <code>latent_calendar/segments/hand_picked.py</code> <pre><code>def create_every_hour_segments() -&gt; pd.DataFrame:\n    \"\"\"Programmatically segments for every hour\n\n    Each row is just each time slot\n\n    Returns:\n        DataFrame in the df_segments wide format\n\n    \"\"\"\n    segments = []\n\n    for dow, hour in itertools.product(range(DAYS_IN_WEEK), range(HOURS_IN_DAY)):\n        name = format_dow_hour(dow, hour)\n\n        start = DOWHour(dow=dow, hour=hour)\n        end = DOWHour(dow=dow, hour=hour + 1)\n        segments.append(create_hourly_segment(start=start, end=end, name=name))\n\n    return stack_segments(segments)\n</code></pre>"},{"location":"modules/segments/#latent_calendar.segments.hand_picked.create_hourly_segment","title":"<code>create_hourly_segment(start, end, name)</code>","text":"<p>Highlight from start until end.</p> Source code in <code>latent_calendar/segments/hand_picked.py</code> <pre><code>def create_hourly_segment(start: DOWHour, end: DOWHour, name: str) -&gt; pd.Series:\n    \"\"\"Highlight from start until end.\"\"\"\n    return create_series_for_range(start=start, end=end).rename(name)\n</code></pre>"},{"location":"modules/segments/#latent_calendar.segments.hand_picked.create_series_for_range","title":"<code>create_series_for_range(start, end)</code>","text":"<p>Create a series for a range of hours with ones for those in range.</p> Source code in <code>latent_calendar/segments/hand_picked.py</code> <pre><code>def create_series_for_range(start: DOWHour, end: DOWHour) -&gt; pd.Series:\n    \"\"\"Create a series for a range of hours with ones for those in range.\"\"\"\n    ser = create_blank_segment_series()\n\n    if start.is_after(end):\n        end, start = start, end\n        negate = True\n    else:\n        negate = False\n\n    if isinstance(ser.index, pd.MultiIndex):\n        start_idx = pd.IndexSlice[start.dow, start.hour]\n        end_idx = pd.IndexSlice[end.dow, end.hour - 1]\n    else:\n        start_idx = format_dow_hour(start.dow, start.hour)\n        end_idx = format_dow_hour(end.dow, end.hour - 1)\n\n    ser.loc[start_idx:end_idx] = 1\n\n    if negate:\n        ser = (ser - 1) * -1\n\n    return ser.astype(int)\n</code></pre>"},{"location":"modules/segments/#latent_calendar.segments.hand_picked.get_vocab_for_range","title":"<code>get_vocab_for_range(start, end)</code>","text":"<p>Get the vocab for a range of hours.</p> Source code in <code>latent_calendar/segments/hand_picked.py</code> <pre><code>def get_vocab_for_range(start: DOWHour, end: DOWHour) -&gt; list[str]:\n    \"\"\"Get the vocab for a range of hours.\"\"\"\n    return (\n        create_series_for_range(start=start, end=end)\n        .loc[lambda x: x == 1]\n        .index.tolist()\n    )\n</code></pre>"},{"location":"modules/segments/#latent_calendar.segments.hand_picked.stack_segments","title":"<code>stack_segments(segments)</code>","text":"<p>Stack segments into a single dataframe.</p> Source code in <code>latent_calendar/segments/hand_picked.py</code> <pre><code>def stack_segments(segments: list[SEGMENT]) -&gt; pd.DataFrame:\n    \"\"\"Stack segments into a single dataframe.\"\"\"\n    segments = [seg.T if isinstance(seg, pd.DataFrame) else seg for seg in segments]\n    return pd.concat(segments, axis=1).T\n</code></pre>"},{"location":"modules/segments/#latent_calendar.segments.convolution.sum_array_over_segments","title":"<code>sum_array_over_segments(X_pred, X_segment)</code>","text":"<p>Get the probability of the mask for the probabilities.</p> <p>Parameters:</p> Name Type Description Default <code>X_pred</code> <code>ndarray</code> <p>(nrows, n_times)</p> required <code>X_segment</code> <code>ndarray</code> <p>(n_segments, n_times)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Matrix of (nrows, n_segments) defining the probabilities of each segments</p> Source code in <code>latent_calendar/segments/convolution.py</code> <pre><code>def sum_array_over_segments(X_pred: np.ndarray, X_segment: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Get the probability of the mask for the probabilities.\n\n    Args:\n        X_pred: (nrows, n_times)\n        X_segment: (n_segments, n_times)\n\n    Returns:\n        Matrix of (nrows, n_segments) defining the probabilities of each segments\n\n    \"\"\"\n    return _mask_probs(X_segment, X_pred).sum(axis=2).T\n</code></pre>"},{"location":"modules/segments/#latent_calendar.segments.convolution.sum_next_hours","title":"<code>sum_next_hours(df, hours)</code>","text":"<p>Sum the next hours columns.</p> <p>Useful for finding probability of having tour in the next 5 hours 00 00 column would be 06 06 23</p> <p>TODO: Consider if negative hours should be allowed TODO: Handle when minutes are not 60</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>DataFrame of probabilities or counts in wide format</p> required <code>hours</code> <code>int</code> <p>Number of hours to sum after the current hour</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame summed over the next hours</p> Source code in <code>latent_calendar/segments/convolution.py</code> <pre><code>def sum_next_hours(df: pd.DataFrame, hours: int) -&gt; pd.DataFrame:\n    \"\"\"Sum the next hours columns.\n\n    Useful for finding probability of having tour in the next 5 hours\n    00 00 column would be 06 06 23\n\n    TODO: Consider if negative hours should be allowed\n    TODO: Handle when minutes are not 60\n\n    Arguments:\n        df: DataFrame of probabilities or counts in wide format\n        hours: Number of hours to sum after the current hour\n\n    Returns:\n        DataFrame summed over the next hours\n\n    \"\"\"\n    if hours &lt; 0:\n        msg = \"hours cannot be negative\"\n        raise ValueError(msg)\n\n    if hours == 0:\n        return df\n\n    return (\n        pd.concat([df, df.iloc[:, :hours]], axis=1)\n        .pipe(_reverse_columns)\n        .T.rolling(hours + 1)\n        .sum()\n        .T.iloc[:, hours:]\n        .pipe(_reverse_columns)\n    )\n</code></pre>"},{"location":"modules/segments/#latent_calendar.segments.convolution.sum_over_segments","title":"<code>sum_over_segments(df, df_segments)</code>","text":"<p>Sum DataFrame over user defined segments.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>DataFrame of probabilities or counts in wide format</p> required <code>df_segments</code> <code>DataFrame</code> <p>DataFrame of segments in wide format</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame of probabilities or counts summed over the segments</p> Source code in <code>latent_calendar/segments/convolution.py</code> <pre><code>def sum_over_segments(df: pd.DataFrame, df_segments: pd.DataFrame) -&gt; pd.DataFrame:\n    \"\"\"Sum DataFrame over user defined segments.\n\n    Args:\n        df: DataFrame of probabilities or counts in wide format\n        df_segments: DataFrame of segments in wide format\n\n    Returns:\n        DataFrame of probabilities or counts summed over the segments\n\n    \"\"\"\n    return pd.DataFrame(\n        sum_array_over_segments(df.to_numpy(), df_segments.to_numpy()),\n        index=df.index,\n        columns=df_segments.index,\n    )\n</code></pre>"},{"location":"modules/segments/#latent_calendar.segments.convolution.sum_over_vocab","title":"<code>sum_over_vocab(df, aggregation='dow')</code>","text":"<p>Sum the wide DataFrame columns to hours or dow.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>DataFrame in wide format with vocab column names</p> required <code>aggregation</code> <code>str</code> <p>either dow or hour</p> <code>'dow'</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame columns associated with the aggregation</p> Source code in <code>latent_calendar/segments/convolution.py</code> <pre><code>def sum_over_vocab(df: pd.DataFrame, aggregation: str = \"dow\") -&gt; pd.DataFrame:\n    \"\"\"Sum the wide DataFrame columns to hours or dow.\n\n    Args:\n        df: DataFrame in wide format with vocab column names\n        aggregation: either dow or hour\n\n    Returns:\n        DataFrame columns associated with the aggregation\n\n    \"\"\"\n    if aggregation not in {\"dow\", \"hour\"}:\n        msg = \"The aggregation must be hour or dow\"\n        raise ValueError(msg)\n\n    if not isinstance(df.columns, pd.MultiIndex):\n        raise ValueError(\"The columns must be a MultiIndex of day_of_week and hour.\")\n\n    level = 1 if aggregation == \"hour\" else 0\n    return df.T.groupby(level=level).sum().T\n</code></pre>"},{"location":"modules/transformers/","title":"Transformers","text":"<p>scikit-learn transformers for the data.</p> <pre><code>from latent_calendar.datasets import load_online_transactions\n\ndf = load_online_transactions()\n\ntransformers = create_raw_to_vocab_transformer(id_col=\"Customer ID\", timestamp_col=\"InvoiceDate\")\n\ndf_wide = transformers.fit_transform(df)\n</code></pre>"},{"location":"modules/transformers/#latent_calendar.transformers.CalandarTimestampFeatures","title":"<code>CalandarTimestampFeatures</code>","text":"<p>               Bases: <code>BaseEstimator</code>, <code>TransformerMixin</code></p> <p>Day of week and prop into day columns creation.</p> Source code in <code>latent_calendar/transformers.py</code> <pre><code>class CalandarTimestampFeatures(BaseEstimator, TransformerMixin):\n    \"\"\"Day of week and prop into day columns creation.\"\"\"\n\n    def __init__(\n        self,\n        timestamp_col: str,\n    ) -&gt; None:\n        self.timestamp_col = timestamp_col\n\n    def fit(self, X: pd.DataFrame, y=None):\n        return self\n\n    def transform(self, X: pd.DataFrame, y=None) -&gt; pd.DataFrame:\n        \"\"\"Create 2 new columns.\"\"\"\n        if not hasattr(X[self.timestamp_col], \"dt\"):\n            raise RuntimeError(\n                f\"Column {self.timestamp_col!r} is not a datetime column. Use df[{self.timestamp_col!r}] = pd.to_datetime(df[{self.timestamp_col!r}]) first.\"\n            )\n\n        X = X.copy()\n\n        X[\"prop_into_day_start\"] = prop_into_day(X[self.timestamp_col].dt)\n        X[\"day_of_week\"] = X[self.timestamp_col].dt.dayofweek\n\n        X[\"hour\"] = X[\"prop_into_day_start\"] * 24\n\n        tmp_columns = [\"prop_into_day_start\"]\n        self.created_columns = [\"day_of_week\", \"hour\"]\n\n        X = X.drop(columns=tmp_columns)\n        self.columns = list(X.columns)\n\n        return X\n\n    def get_feature_names_out(self, input_features=None):\n        return self.columns.extend(self.created_columns)\n</code></pre>"},{"location":"modules/transformers/#latent_calendar.transformers.CalandarTimestampFeatures.transform","title":"<code>transform(X, y=None)</code>","text":"<p>Create 2 new columns.</p> Source code in <code>latent_calendar/transformers.py</code> <pre><code>def transform(self, X: pd.DataFrame, y=None) -&gt; pd.DataFrame:\n    \"\"\"Create 2 new columns.\"\"\"\n    if not hasattr(X[self.timestamp_col], \"dt\"):\n        raise RuntimeError(\n            f\"Column {self.timestamp_col!r} is not a datetime column. Use df[{self.timestamp_col!r}] = pd.to_datetime(df[{self.timestamp_col!r}]) first.\"\n        )\n\n    X = X.copy()\n\n    X[\"prop_into_day_start\"] = prop_into_day(X[self.timestamp_col].dt)\n    X[\"day_of_week\"] = X[self.timestamp_col].dt.dayofweek\n\n    X[\"hour\"] = X[\"prop_into_day_start\"] * 24\n\n    tmp_columns = [\"prop_into_day_start\"]\n    self.created_columns = [\"day_of_week\", \"hour\"]\n\n    X = X.drop(columns=tmp_columns)\n    self.columns = list(X.columns)\n\n    return X\n</code></pre>"},{"location":"modules/transformers/#latent_calendar.transformers.HourDiscretizer","title":"<code>HourDiscretizer</code>","text":"<p>               Bases: <code>BaseEstimator</code>, <code>TransformerMixin</code></p> <p>Discretize the hour column.</p> <p>Parameters:</p> Name Type Description Default <code>col</code> <code>str</code> <p>The name of the column to discretize.</p> <code>'hour'</code> <code>minutes</code> <code>int</code> <p>The number of minutes to discretize by.</p> <code>60</code> Source code in <code>latent_calendar/transformers.py</code> <pre><code>class HourDiscretizer(BaseEstimator, TransformerMixin):\n    \"\"\"Discretize the hour column.\n\n    Args:\n        col: The name of the column to discretize.\n        minutes: The number of minutes to discretize by.\n\n    \"\"\"\n\n    def __init__(self, col: str = \"hour\", minutes: int = 60) -&gt; None:\n        self.col = col\n        self.minutes = minutes\n\n    def fit(self, X: pd.DataFrame, y=None):\n        return self\n\n    def transform(self, X: pd.DataFrame, y=None) -&gt; pd.DataFrame:\n        divisor = 1 if self.minutes == 60 else self.minutes / 60\n        X[self.col] = (X[self.col] // divisor) * divisor\n\n        if self.minutes % 60 == 0:\n            X[self.col] = X[self.col].astype(int)\n\n        self.columns = list(X.columns)\n\n        return X\n\n    def get_feature_names_out(self, input_features=None):\n        return self.columns\n</code></pre>"},{"location":"modules/transformers/#latent_calendar.transformers.LongToWide","title":"<code>LongToWide</code>","text":"<p>               Bases: <code>BaseEstimator</code>, <code>TransformerMixin</code></p> <p>Unstack the assumed last index as vocab column.</p> <p>Parameters:</p> Name Type Description Default <code>col</code> <code>str</code> <p>The name of the column to unstack.</p> <code>'num_events'</code> <code>as_int</code> <code>bool</code> <p>Whether to cast the values to int.</p> <code>True</code> <code>minutes</code> <code>int</code> <p>The number of minutes to discretize by.</p> <code>60</code> <code>multiindex</code> <code>bool</code> <p>Whether the columns are a multiindex.</p> <code>True</code> Source code in <code>latent_calendar/transformers.py</code> <pre><code>class LongToWide(BaseEstimator, TransformerMixin):\n    \"\"\"Unstack the assumed last index as vocab column.\n\n    Args:\n        col: The name of the column to unstack.\n        as_int: Whether to cast the values to int.\n        minutes: The number of minutes to discretize by.\n        multiindex: Whether the columns are a multiindex.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        col: str = \"num_events\",\n        as_int: bool = True,\n        minutes: int = 60,\n        multiindex: bool = True,\n    ) -&gt; None:\n        self.col = col\n        self.as_int = as_int\n        self.minutes = minutes\n        self.multiindex = multiindex\n\n    def fit(self, X: pd.DataFrame, y=None):\n        return self\n\n    @property\n    def columns(self) -&gt; list[str]:\n        return create_full_vocab(\n            days_in_week=DAYS_IN_WEEK,\n            minutes=self.minutes,\n            as_multiindex=self.multiindex,\n        )\n\n    def transform(self, X: pd.DataFrame, y=None) -&gt; pd.DataFrame:\n        \"\"\"Unstack the assumed last index as vocab column.\"\"\"\n        X_res = X.loc[:, self.col]\n\n        level = [-2, -1] if self.multiindex else -1\n        X_res = X_res.unstack(level=level)\n\n        X_res = X_res.reindex(self.columns, axis=1)\n        X_res = X_res.fillna(value=0)\n        if self.as_int:\n            X_res = X_res.astype(int)\n\n        return X_res\n\n    def get_feature_names_out(self, input_features=None):\n        return self.columns\n</code></pre>"},{"location":"modules/transformers/#latent_calendar.transformers.LongToWide.transform","title":"<code>transform(X, y=None)</code>","text":"<p>Unstack the assumed last index as vocab column.</p> Source code in <code>latent_calendar/transformers.py</code> <pre><code>def transform(self, X: pd.DataFrame, y=None) -&gt; pd.DataFrame:\n    \"\"\"Unstack the assumed last index as vocab column.\"\"\"\n    X_res = X.loc[:, self.col]\n\n    level = [-2, -1] if self.multiindex else -1\n    X_res = X_res.unstack(level=level)\n\n    X_res = X_res.reindex(self.columns, axis=1)\n    X_res = X_res.fillna(value=0)\n    if self.as_int:\n        X_res = X_res.astype(int)\n\n    return X_res\n</code></pre>"},{"location":"modules/transformers/#latent_calendar.transformers.RawToVocab","title":"<code>RawToVocab</code>","text":"<p>               Bases: <code>BaseEstimator</code>, <code>TransformerMixin</code></p> <p>Transformer timestamp level data into id level data with vocab columns.</p> <p>Parameters:</p> Name Type Description Default <code>id_col</code> <code>str</code> <p>The name of the id column.</p> required <code>timestamp_col</code> <code>str</code> <p>The name of the timestamp column.</p> required <code>minutes</code> <code>int</code> <p>The number of minutes to discretize by.</p> <code>60</code> <code>additional_groups</code> <code>list[str] | None</code> <p>Additional columns to group by.</p> <code>None</code> <code>cols</code> <code>list[str] | None</code> <p>Additional columns to sum.</p> <code>None</code> <code>as_multiindex</code> <code>bool</code> <p>Whether to return columns as a multiindex.</p> <code>True</code> Source code in <code>latent_calendar/transformers.py</code> <pre><code>class RawToVocab(BaseEstimator, TransformerMixin):\n    \"\"\"Transformer timestamp level data into id level data with vocab columns.\n\n    Args:\n        id_col: The name of the id column.\n        timestamp_col: The name of the timestamp column.\n        minutes: The number of minutes to discretize by.\n        additional_groups: Additional columns to group by.\n        cols: Additional columns to sum.\n        as_multiindex: Whether to return columns as a multiindex.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        id_col: str,\n        timestamp_col: str,\n        minutes: int = 60,\n        additional_groups: list[str] | None = None,\n        cols: list[str] | None = None,\n        as_multiindex: bool = True,\n    ) -&gt; None:\n        self.id_col = id_col\n        self.timestamp_col = timestamp_col\n        self.minutes = minutes\n        self.additional_groups = additional_groups\n        self.cols = cols\n        self.as_multiindex = as_multiindex\n\n    def fit(self, X: pd.DataFrame, y=None):\n        # New features at same index level\n        self.features = create_timestamp_feature_pipeline(\n            self.timestamp_col,\n            minutes=self.minutes,\n            create_vocab=not self.as_multiindex,\n        )\n\n        groups = [self.id_col]\n        if self.additional_groups is not None:\n            if not isinstance(self.additional_groups, list):\n                raise ValueError(\n                    f\"additional_groups should be list not {type(self.additional_groups)}\"\n                )\n\n            groups.extend(self.additional_groups)\n\n        if self.as_multiindex:\n            groups.extend([\"day_of_week\", \"hour\"])\n        else:\n            groups.append(\"vocab\")\n\n        # Reaggregation\n        self.aggregation = VocabAggregation(groups=groups, cols=self.cols)\n        # Unstacking\n        self.widden = LongToWide(\n            col=\"num_events\", minutes=self.minutes, multiindex=self.as_multiindex\n        )\n        # Since nothing needs to be \"fit\"\n        return self\n\n    def transform(self, X: pd.DataFrame, y=None) -&gt; pd.DataFrame:\n        X_trans = self.features.transform(X)\n\n        X_agg = self.aggregation.transform(X_trans)\n        return self.widden.transform(X_agg)\n</code></pre>"},{"location":"modules/transformers/#latent_calendar.transformers.VocabAggregation","title":"<code>VocabAggregation</code>","text":"<p>               Bases: <code>BaseEstimator</code>, <code>TransformerMixin</code></p> <p>NOTE: The index of the grouping stays.</p> <p>Parameters:</p> Name Type Description Default <code>groups</code> <code>list[str]</code> <p>The columns to group by.</p> required <code>cols</code> <code>list[str] | None</code> <p>Additional columns to sum.</p> <code>None</code> Source code in <code>latent_calendar/transformers.py</code> <pre><code>class VocabAggregation(BaseEstimator, TransformerMixin):\n    \"\"\"NOTE: The index of the grouping stays.\n\n    Args:\n        groups: The columns to group by.\n        cols: Additional columns to sum.\n\n    \"\"\"\n\n    def __init__(self, groups: list[str], cols: list[str] | None = None) -&gt; None:\n        self.groups = groups\n        self.cols = cols\n\n    def fit(self, X: pd.DataFrame, y=None):\n        return self\n\n    def transform(self, X: pd.DataFrame, y=None):\n        stats = {}\n        if self.cols is not None:\n            stats.update({col: (col, \"sum\") for col in self.cols})\n\n        df_agg = (\n            X.assign(num_events=1)\n            .groupby(self.groups)\n            .agg(num_events=(\"num_events\", \"sum\"), **stats)\n        )\n        self.columns = list(df_agg.columns)\n\n        return df_agg\n\n    def get_feature_names_out(self, input_features=None):\n        return self.columns\n</code></pre>"},{"location":"modules/transformers/#latent_calendar.transformers.VocabTransformer","title":"<code>VocabTransformer</code>","text":"<p>               Bases: <code>BaseEstimator</code>, <code>TransformerMixin</code></p> <p>Create a vocab column from the day of week and hour columns.</p> Source code in <code>latent_calendar/transformers.py</code> <pre><code>class VocabTransformer(BaseEstimator, TransformerMixin):\n    \"\"\"Create a vocab column from the day of week and hour columns.\"\"\"\n\n    def __init__(\n        self, day_of_week_col: str = \"day_of_week\", hour_col: str = \"hour\"\n    ) -&gt; None:\n        self.day_of_week_col = day_of_week_col\n        self.hour_col = hour_col\n\n    def fit(self, X: pd.DataFrame, y=None):\n        return self\n\n    def transform(self, X: pd.DataFrame, y=None) -&gt; pd.DataFrame:\n        X[\"vocab\"] = (\n            X[self.day_of_week_col]\n            .astype(str)\n            .str.zfill(2)\n            .str.cat(X[self.hour_col].astype(str).str.zfill(2), sep=\" \")\n        )\n\n        self.columns = list(X.columns)\n\n        return X\n\n    def get_feature_names_out(self, input_features=None):\n        return self.columns\n</code></pre>"},{"location":"modules/transformers/#latent_calendar.transformers.create_raw_to_vocab_transformer","title":"<code>create_raw_to_vocab_transformer(id_col, timestamp_col, minutes=60, additional_groups=None, as_multiindex=True)</code>","text":"<p>Wrapper to create the transformer from the configuration options.</p> <p>Parameters:</p> Name Type Description Default <code>id_col</code> <code>str</code> <p>The name of the id column.</p> required <code>timestamp_col</code> <code>str</code> <p>The name of the timestamp column.</p> required <code>minutes</code> <code>int</code> <p>The number of minutes to discretize by.</p> <code>60</code> <code>additional_groups</code> <code>list[str] | None</code> <p>Additional columns to group by.</p> <code>None</code> <code>as_multiindex</code> <code>bool</code> <p>Whether to return columns as a multiindex.</p> <code>True</code> <p>Returns:</p> Type Description <code>RawToVocab</code> <p>A transformer that transforms timestamp level data into id level data with vocab columns.</p> Source code in <code>latent_calendar/transformers.py</code> <pre><code>def create_raw_to_vocab_transformer(\n    id_col: str,\n    timestamp_col: str,\n    minutes: int = 60,\n    additional_groups: list[str] | None = None,\n    as_multiindex: bool = True,\n) -&gt; RawToVocab:\n    \"\"\"Wrapper to create the transformer from the configuration options.\n\n    Args:\n        id_col: The name of the id column.\n        timestamp_col: The name of the timestamp column.\n        minutes: The number of minutes to discretize by.\n        additional_groups: Additional columns to group by.\n        as_multiindex: Whether to return columns as a multiindex.\n\n    Returns:\n        A transformer that transforms timestamp level data into id level data with vocab columns.\n\n    \"\"\"\n    if not as_multiindex:\n        msg = (\n            \"columns will be returned as a MultiIndex by default and will \"\n            \"be behavior in future. Use as_multiindex=False for previous behavior\"\n        )\n        warnings.warn(msg, DeprecationWarning, stacklevel=2)\n\n    return RawToVocab(\n        id_col=id_col,\n        timestamp_col=timestamp_col,\n        minutes=minutes,\n        additional_groups=additional_groups,\n    )\n</code></pre>"},{"location":"modules/transformers/#latent_calendar.transformers.create_timestamp_feature_pipeline","title":"<code>create_timestamp_feature_pipeline(timestamp_col, discretize=True, minutes=60, create_vocab=True)</code>","text":"<p>Create a pipeline that creates features from the timestamp column.</p> <p>Parameters:</p> Name Type Description Default <code>timestamp_col</code> <code>str</code> <p>The name of the timestamp column.</p> required <code>discretize</code> <code>bool</code> <p>Whether to discretize the hour column.</p> <code>True</code> <code>minutes</code> <code>int</code> <p>The number of minutes to discretize by. Ignored if discretize is False.</p> <code>60</code> <code>create_vocab</code> <code>bool</code> <p>Whether to create the vocab column.</p> <code>True</code> <p>Returns:</p> Type Description <code>Pipeline</code> <p>A pipeline that creates features from the timestamp column.</p> Example <p>Create features for the online transactions dataset.</p> <pre><code>from latent_calendar.datasets import load_online_transactions\n\ndf = load_online_transactions()\n\ntransformers = create_timestamp_feature_pipeline(timestamp_col=\"InvoiceDate\")\n\ndf_features = transformers.fit_transform(df)\n</code></pre> Source code in <code>latent_calendar/transformers.py</code> <pre><code>def create_timestamp_feature_pipeline(\n    timestamp_col: str,\n    discretize: bool = True,\n    minutes: int = 60,\n    create_vocab: bool = True,\n) -&gt; Pipeline:\n    \"\"\"Create a pipeline that creates features from the timestamp column.\n\n    Args:\n        timestamp_col: The name of the timestamp column.\n        discretize: Whether to discretize the hour column.\n        minutes: The number of minutes to discretize by. Ignored if discretize is False.\n        create_vocab: Whether to create the vocab column.\n\n    Returns:\n        A pipeline that creates features from the timestamp column.\n\n    Example:\n        Create features for the online transactions dataset.\n\n        ```python\n        from latent_calendar.datasets import load_online_transactions\n\n        df = load_online_transactions()\n\n        transformers = create_timestamp_feature_pipeline(timestamp_col=\"InvoiceDate\")\n\n        df_features = transformers.fit_transform(df)\n        ```\n\n    \"\"\"\n    if create_vocab and not discretize:\n        raise ValueError(\"Cannot create vocab without discretizing.\")\n\n    vocab_col = \"hour\"\n    transformers = [\n        (\n            \"timestamp_features\",\n            CalandarTimestampFeatures(timestamp_col=timestamp_col),\n        ),\n    ]\n\n    if discretize:\n        transformers.append(\n            (\"binning\", HourDiscretizer(col=vocab_col, minutes=minutes))\n        )\n\n    if create_vocab:\n        transformers.append(\n            (\"vocab_creation\", VocabTransformer(hour_col=vocab_col)),\n        )\n\n    return Pipeline(\n        transformers,\n    ).set_output(transform=\"pandas\")\n</code></pre>"},{"location":"modules/transformers/#latent_calendar.transformers.prop_into_day","title":"<code>prop_into_day(dt)</code>","text":"<p>Returns the proportion into the day from datetime like object.</p> <p>0.0 is midnight and 1.0 is midnight again.</p> <p>Parameters:</p> Name Type Description Default <code>dt</code> <code>datetime | DatetimeProperties</code> <p>datetime like object</p> required <p>Returns:</p> Type Description <code>float | Series</code> <p>numeric value(s) between 0.0 and 1.0</p> Source code in <code>latent_calendar/transformers.py</code> <pre><code>def prop_into_day(dt: datetime | DatetimeProperties) -&gt; float | pd.Series:\n    \"\"\"Returns the proportion into the day from datetime like object.\n\n    0.0 is midnight and 1.0 is midnight again.\n\n    Args:\n        dt: datetime like object\n\n    Returns:\n        numeric value(s) between 0.0 and 1.0\n\n    \"\"\"\n    prop_hour = dt.hour / HOURS_IN_DAY\n    prop_minute = dt.minute / MINUTES_IN_DAY\n    prop_second = dt.second / SECONDS_IN_DAY\n    prop_microsecond = dt.microsecond / MICROSECONDS_IN_DAY\n\n    return prop_hour + prop_minute + prop_second + prop_microsecond\n</code></pre>"},{"location":"modules/vocab/","title":"Vocab","text":"<p>Operations and relationship with the \"vocab\" of the default time slots.</p>"},{"location":"modules/vocab/#latent_calendar.vocab.DOWHour","title":"<code>DOWHour</code>  <code>dataclass</code>","text":"<p>Day of week and hour of day class.</p> Source code in <code>latent_calendar/vocab.py</code> <pre><code>@dataclass\nclass DOWHour:\n    \"\"\"Day of week and hour of day class.\"\"\"\n\n    dow: int\n    hour: int\n\n    @classmethod\n    def from_vocab(cls, vocab: str) -&gt; \"DOWHour\":\n        \"\"\"Construct from a vocab string.\"\"\"\n        dow, hour = get_day_hour(vocab=vocab)\n\n        return cls(dow=dow, hour=hour)\n\n    def __post_init__(self) -&gt; None:\n        msg = \"Day of week goes from 0 to 6 and hour of day goes from 0 to 24.\"\n        if not 0 &lt;= self.dow &lt;= 6:\n            raise ValueError(msg)\n\n        if not 0 &lt;= self.hour &lt;= 24:\n            raise ValueError(msg)\n\n    def is_after(self, other: \"DOWHour\") -&gt; bool:\n        \"\"\"Check if self is after other.\"\"\"\n        if self.dow &gt; other.dow:\n            return True\n\n        if self.dow &lt; other.dow:\n            return False\n\n        return self.hour &gt; other.hour\n\n    @property\n    def vocab(self) -&gt; str:\n        \"\"\"Get the vocab string for an instance.\"\"\"\n        return format_dow_hour(self.dow, self.hour)\n\n    def __add__(self, hours: int) -&gt; \"DOWHour\":\n        \"\"\"Add a number of hours.\"\"\"\n        dow, hour = self.dow, self.hour\n\n        for _ in range(hours):\n            hour += 1\n            if hour &gt; 23:\n                dow += 1\n                dow = dow % 7\n\n            hour = hour % 24\n\n        return DOWHour(dow=dow, hour=hour)\n</code></pre>"},{"location":"modules/vocab/#latent_calendar.vocab.DOWHour.vocab","title":"<code>vocab</code>  <code>property</code>","text":"<p>Get the vocab string for an instance.</p>"},{"location":"modules/vocab/#latent_calendar.vocab.DOWHour.__add__","title":"<code>__add__(hours)</code>","text":"<p>Add a number of hours.</p> Source code in <code>latent_calendar/vocab.py</code> <pre><code>def __add__(self, hours: int) -&gt; \"DOWHour\":\n    \"\"\"Add a number of hours.\"\"\"\n    dow, hour = self.dow, self.hour\n\n    for _ in range(hours):\n        hour += 1\n        if hour &gt; 23:\n            dow += 1\n            dow = dow % 7\n\n        hour = hour % 24\n\n    return DOWHour(dow=dow, hour=hour)\n</code></pre>"},{"location":"modules/vocab/#latent_calendar.vocab.DOWHour.from_vocab","title":"<code>from_vocab(vocab)</code>  <code>classmethod</code>","text":"<p>Construct from a vocab string.</p> Source code in <code>latent_calendar/vocab.py</code> <pre><code>@classmethod\ndef from_vocab(cls, vocab: str) -&gt; \"DOWHour\":\n    \"\"\"Construct from a vocab string.\"\"\"\n    dow, hour = get_day_hour(vocab=vocab)\n\n    return cls(dow=dow, hour=hour)\n</code></pre>"},{"location":"modules/vocab/#latent_calendar.vocab.DOWHour.is_after","title":"<code>is_after(other)</code>","text":"<p>Check if self is after other.</p> Source code in <code>latent_calendar/vocab.py</code> <pre><code>def is_after(self, other: \"DOWHour\") -&gt; bool:\n    \"\"\"Check if self is after other.\"\"\"\n    if self.dow &gt; other.dow:\n        return True\n\n    if self.dow &lt; other.dow:\n        return False\n\n    return self.hour &gt; other.hour\n</code></pre>"},{"location":"modules/vocab/#latent_calendar.vocab.HourFormatter","title":"<code>HourFormatter</code>  <code>dataclass</code>","text":"<p>Class to format the hour that includes midnight and noon.</p> <p>Parameters:</p> Name Type Description Default <code>midnight</code> <code>str | None</code> <p>string to use for midnight</p> <code>'Midnight'</code> <code>noon</code> <code>str | None</code> <p>string to use for noon</p> <code>'Noon'</code> <code>format_hour</code> <code>HOUR_FORMATTER</code> <p>HOUR_FORMATTER to map hour int to string</p> <code>HOUR_FORMATTERS['12hr']</code> <p>Examples:</p> <p>Just return the number and add midnight and noon.</p> <pre><code>hour_formatter = HourFormatter(\n    midnight=\"Midnight\",\n    noon=\"Noon\",\n    format_hour=lambda hour: hour\n)\n\nhour_formatter(0) # \"Midnight\"\nhour_formatter(12) # \"Noon\"\nhour_formatter(1) # 1\nhour_formatter(13) # 13\nhour_formatter(24) # \"Midnight\"\n</code></pre> Source code in <code>latent_calendar/vocab.py</code> <pre><code>@dataclass\nclass HourFormatter:\n    \"\"\"Class to format the hour that includes midnight and noon.\n\n    Args:\n        midnight: string to use for midnight\n        noon: string to use for noon\n        format_hour: HOUR_FORMATTER to map hour int to string\n\n    Examples:\n        Just return the number and add midnight and noon.\n\n        ```python\n        hour_formatter = HourFormatter(\n            midnight=\"Midnight\",\n            noon=\"Noon\",\n            format_hour=lambda hour: hour\n        )\n\n        hour_formatter(0) # \"Midnight\"\n        hour_formatter(12) # \"Noon\"\n        hour_formatter(1) # 1\n        hour_formatter(13) # 13\n        hour_formatter(24) # \"Midnight\"\n\n        ```\n\n    \"\"\"\n\n    midnight: str | None = \"Midnight\"\n    noon: str | None = \"Noon\"\n    format_hour: HOUR_FORMATTER = HOUR_FORMATTERS[\"12hr\"]\n\n    def __call__(self, hr: int) -&gt; str:\n        if self.midnight is not None and hr in (0, HOURS_IN_DAY):\n            return self.midnight\n\n        if hr == 12:\n            return self.noon if self.noon is not None else self.format_hour(hr)\n\n        return self.format_hour(hr)\n</code></pre>"},{"location":"modules/vocab/#latent_calendar.vocab.am_pm_of_hour","title":"<code>am_pm_of_hour(hour)</code>","text":"<p>Get the am or pm of the hour.</p> <p>Parameters:</p> Name Type Description Default <code>hour</code> <code>int</code> <p>hour of the day</p> required <p>Returns:</p> Type Description <code>str</code> <p>am or pm</p> Source code in <code>latent_calendar/vocab.py</code> <pre><code>def am_pm_of_hour(hour: int) -&gt; str:\n    \"\"\"Get the am or pm of the hour.\n\n    Args:\n        hour: hour of the day\n\n    Returns:\n        am or pm\n\n    \"\"\"\n    return \"am\" if hour &lt; 12 else \"pm\"\n</code></pre>"},{"location":"modules/vocab/#latent_calendar.vocab.get_day_hour","title":"<code>get_day_hour(vocab)</code>","text":"<p>Get the day and hour from the vocab.</p> Source code in <code>latent_calendar/vocab.py</code> <pre><code>def get_day_hour(vocab: str) -&gt; tuple[int, int]:\n    \"\"\"Get the day and hour from the vocab.\"\"\"\n    day_str, hour_str = vocab.split(\" \")\n\n    return int(day_str), int(hour_str)\n</code></pre>"},{"location":"modules/vocab/#latent_calendar.vocab.make_human_readable","title":"<code>make_human_readable(vocab, hour_formatter=HOUR_FORMATTERS['12_am_pm'])</code>","text":"<p>Create a human readable string of the vocab.</p> <p>Parameters:</p> Name Type Description Default <code>vocab</code> <code>str</code> <p>string vocab. i.e. \"00 01\"</p> required <code>hour_formatter</code> <code>HOUR_FORMATTER</code> <p>HOUR_FORMATTER to map hour int to string</p> <code>HOUR_FORMATTERS['12_am_pm']</code> <p>Returns:</p> Type Description <code>str</code> <p>human readable string of the vocab</p> Source code in <code>latent_calendar/vocab.py</code> <pre><code>def make_human_readable(\n    vocab: str, hour_formatter: HOUR_FORMATTER = HOUR_FORMATTERS[\"12_am_pm\"]\n) -&gt; str:\n    \"\"\"Create a human readable string of the vocab.\n\n    Args:\n        vocab: string vocab. i.e. \"00 01\"\n        hour_formatter: HOUR_FORMATTER to map hour int to string\n\n    Returns:\n        human readable string of the vocab\n\n    \"\"\"\n    day, hour = get_day_hour(vocab=vocab)\n\n    human_day = calendar.day_name[day]\n    human_hour = hour_formatter(hour)\n\n    return f\"{human_day} {human_hour}\"\n</code></pre>"},{"location":"modules/vocab/#latent_calendar.vocab.map_to_12_hour","title":"<code>map_to_12_hour(hour)</code>","text":"<p>Map the hour to a 12 hour clock.</p> Source code in <code>latent_calendar/vocab.py</code> <pre><code>def map_to_12_hour(hour: int) -&gt; int:\n    \"\"\"Map the hour to a 12 hour clock.\"\"\"\n    if hour == 0:\n        return 12\n\n    if hour == 12:\n        return hour\n\n    return hour % 12\n</code></pre>"},{"location":"modules/vocab/#latent_calendar.vocab.split_vocab","title":"<code>split_vocab(ser)</code>","text":"<p>Split pandas series of vocab into day of week and hour of day DataFrame.</p> Source code in <code>latent_calendar/vocab.py</code> <pre><code>def split_vocab(ser: pd.Series) -&gt; pd.DataFrame:\n    \"\"\"Split pandas series of vocab into day of week and hour of day DataFrame.\"\"\"\n    df_split = ser.str.split(\" \", expand=True).astype(int)\n\n    df_split.columns = [\"dow\", \"hour\"]\n\n    return df_split\n</code></pre>"},{"location":"modules/plot/colors/","title":"Colors","text":"<p>Handling the colors in the calendar plots.</p> <p>This module provides some helper function and some defaults. However, they might not be the best of all purposes.</p> <p>Color maps here take floats to a color string. Usually a hex string.</p> Example <p>Create a color map for count data.</p> <pre><code>cmap = create_default_cmap(max_value=10)\n\ncmap(0)  # '#ffffe5'\ncmap(5)  # '#379e54'\ncmap(10) # '#004529'\n</code></pre>"},{"location":"modules/plot/colors/#latent_calendar.plot.colors.ColorMap","title":"<code>ColorMap</code>","text":"<p>               Bases: <code>ScalarMappable</code></p> <p>This supports colorbar for a figure from matplotlib.</p> <p>Parameters:</p> Name Type Description Default <code>norm</code> <p>matplotlib.colors.Normalize</p> required <code>cmap</code> <p>matplotlib.cm.ScalarMappable</p> required <code>default_cm</code> <code>CM</code> <p>matplotlib.cm.ScalarMappable</p> required Source code in <code>latent_calendar/plot/colors.py</code> <pre><code>class ColorMap(ScalarMappable):\n    \"\"\"This supports colorbar for a figure from matplotlib.\n\n    Args:\n        norm: matplotlib.colors.Normalize\n        cmap: matplotlib.cm.ScalarMappable\n        default_cm: matplotlib.cm.ScalarMappable\n\n    \"\"\"\n\n    def __init__(self, norm, cmap, default_cm: CM) -&gt; None:\n        cmap = cmap if cmap is not None else default_cm\n        super().__init__(norm=norm, cmap=cmap)\n\n    def __call__(self, x: float) -&gt; str:\n        return rgb2hex(self.cmap(self.norm(x)))\n\n    def add_colorbar(self, ax=None) -&gt; None:\n        \"\"\"Add the colorbar to axis or axes.\n\n        Args:\n            ax: single or np.ndarray of Axes\n\n        \"\"\"\n        fig = plt.gcf()\n\n        fig.colorbar(self, ax=ax, ticks=self.norm.ticks)\n</code></pre>"},{"location":"modules/plot/colors/#latent_calendar.plot.colors.ColorMap.add_colorbar","title":"<code>add_colorbar(ax=None)</code>","text":"<p>Add the colorbar to axis or axes.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <p>single or np.ndarray of Axes</p> <code>None</code> Source code in <code>latent_calendar/plot/colors.py</code> <pre><code>def add_colorbar(self, ax=None) -&gt; None:\n    \"\"\"Add the colorbar to axis or axes.\n\n    Args:\n        ax: single or np.ndarray of Axes\n\n    \"\"\"\n    fig = plt.gcf()\n\n    fig.colorbar(self, ax=ax, ticks=self.norm.ticks)\n</code></pre>"},{"location":"modules/plot/colors/#latent_calendar.plot.colors.create_cmap","title":"<code>create_cmap(max_value, min_value=0.0, cm=None)</code>","text":"<p>Create color map function.</p> <p>Parameters:</p> Name Type Description Default <code>max_value</code> <code>float</code> <p>maximum value for the color map</p> required <code>min_value</code> <code>float</code> <p>minimum value for the color map</p> <code>0.0</code> <code>cm</code> <code>CM | None</code> <p>function that takes a value and returns a color</p> <code>None</code> Source code in <code>latent_calendar/plot/colors.py</code> <pre><code>def create_cmap(max_value: float, min_value: float = 0.0, cm: CM | None = None) -&gt; CMAP:\n    \"\"\"Create color map function.\n\n    Args:\n        max_value: maximum value for the color map\n        min_value: minimum value for the color map\n        cm: function that takes a value and returns a color\n\n    \"\"\"\n    norm = Normalize(vmin=min_value, vmax=max_value)\n    norm.ticks = [norm.vmin, norm.vmax]\n    return ColorMap(norm=norm, cmap=cm, default_cm=plt.cm.YlGn)\n</code></pre>"},{"location":"modules/plot/colors/#latent_calendar.plot.colors.create_diverge_cmap","title":"<code>create_diverge_cmap(center_value, range, cm=None)</code>","text":"<p>Create color map function to emphasize a center value and deviation from that center.</p> <p>Might be good for values that are relative to some baseline</p> Source code in <code>latent_calendar/plot/colors.py</code> <pre><code>def create_diverge_cmap(\n    center_value: float, range: float, cm: CM | None = None\n) -&gt; CMAP:\n    \"\"\"Create color map function to emphasize a center value and deviation from that center.\n\n    Might be good for values that are relative to some baseline\n\n    \"\"\"\n    half_range = range / 2\n    norm = Normalize(vmin=center_value - half_range, vmax=center_value + half_range)\n    norm.ticks = [norm.vmin, 0, norm.vmax]\n    return ColorMap(norm=norm, cmap=cm, default_cm=plt.cm.coolwarm)\n</code></pre>"},{"location":"modules/plot/colors/#latent_calendar.plot.colors.create_relative_cmap","title":"<code>create_relative_cmap(range)</code>","text":"<p>Good for relative scales.</p> Source code in <code>latent_calendar/plot/colors.py</code> <pre><code>def create_relative_cmap(range: float) -&gt; CMAP:\n    \"\"\"Good for relative scales.\"\"\"\n    return create_diverge_cmap(center_value=1.0, range=range)\n</code></pre>"},{"location":"modules/plot/colors/#latent_calendar.plot.colors.settle_data_and_cmap","title":"<code>settle_data_and_cmap(data, divergent)</code>","text":"<p>Return a tuple of transformed data and cmap for displaying that data.</p> Source code in <code>latent_calendar/plot/colors.py</code> <pre><code>def settle_data_and_cmap(data, divergent: bool) -&gt; tuple[np.ndarray, CMAP]:\n    \"\"\"Return a tuple of transformed data and cmap for displaying that data.\"\"\"\n    if divergent:\n        # Comparing the values to random rate\n        EVEN_PROBABILITY = 1 / data.shape[0]\n        data = data / EVEN_PROBABILITY\n        return data, create_default_divergent_cmap()\n\n    return data, create_default_cmap(value=data.max())\n</code></pre>"},{"location":"modules/plot/config/","title":"Config","text":"<p>Configuration file for plotting.</p>"},{"location":"modules/plot/config/#latent_calendar.plot.config.Config","title":"<code>Config</code>  <code>dataclass</code>","text":"<p>Default configuration used in some of the plots.</p> <p>Parameters:</p> Name Type Description Default <code>divergent</code> <code>bool</code> <p>whether to show divergent calendar by default.</p> <code>True</code> <code>range</code> <code>float</code> <p>Where to a divergent plot</p> <code>3.0</code> <code>max_value_ratio</code> <code>float</code> <p>Where to clip the default cmap in the calendar view</p> <code>0.75</code> Source code in <code>latent_calendar/plot/config.py</code> <pre><code>@dataclass\nclass Config:\n    \"\"\"Default configuration used in some of the plots.\n\n    Args:\n        divergent: whether to show divergent calendar by default.\n        range: Where to a divergent plot\n        max_value_ratio: Where to clip the default cmap in the calendar view\n\n    \"\"\"\n\n    divergent: bool = True\n    range: float = 3.0\n    max_value_ratio: float = 0.75\n</code></pre>"},{"location":"modules/plot/core/","title":"Core","text":"<p>Plots including a model.</p>"},{"location":"modules/plot/core/#latent_calendar.plot.core.calendar.plot_blank_calendar","title":"<code>plot_blank_calendar(day_labeler=DayLabeler(), time_labeler=TimeLabeler(), display_settings=None, ax=None, grid_lines=GridLines(), monday_start=True)</code>","text":"<p>Create a blank calendar with no data</p> <p>Parameters:</p> Name Type Description Default <code>day_labeler</code> <code>DayLabeler</code> <p>instance in order to configure the day labels</p> <code>DayLabeler()</code> <code>time_labeler</code> <code>TimeLabeler</code> <p>instance in order to configure the time labels</p> <code>TimeLabeler()</code> <code>display_settings</code> <code>DisplaySettings | None</code> <p>override of the display settings in the calendar</p> <code>None</code> <code>ax</code> <code>Axes | None</code> <p>Optional axes to plot on</p> <code>None</code> <code>grid_lines</code> <code>GridLines</code> <p>GridLines instance</p> <code>GridLines()</code> <code>monday_start</code> <code>bool</code> <p>whether to start the week on Monday or Sunday</p> <code>True</code> <p>Returns:</p> Type Description <code>Axes</code> <p>Modified matplotlib axis</p> Source code in <code>latent_calendar/plot/core/calendar.py</code> <pre><code>def plot_blank_calendar(\n    day_labeler: DayLabeler = DayLabeler(),\n    time_labeler: TimeLabeler = TimeLabeler(),\n    display_settings: DisplaySettings | None = None,\n    ax: plt.Axes | None = None,\n    grid_lines: GridLines = GridLines(),\n    monday_start: bool = True,\n) -&gt; plt.Axes:\n    \"\"\"Create a blank calendar with no data\n\n    Args:\n        day_labeler: instance in order to configure the day labels\n        time_labeler: instance in order to configure the time labels\n        display_settings: override of the display settings in the calendar\n        ax: Optional axes to plot on\n        grid_lines: GridLines instance\n        monday_start: whether to start the week on Monday or Sunday\n\n    Returns:\n        Modified matplotlib axis\n\n    \"\"\"\n    update_start(day_labeler=day_labeler, monday_start=monday_start)\n\n    if display_settings is not None:\n        update_display_settings(\n            day_labeler=day_labeler,\n            time_labeler=time_labeler,\n            display_settings=display_settings,\n        )\n\n    ax = ax if ax is not None else plt.gca()\n\n    configure_axis(ax=ax, day_labeler=day_labeler, time_labeler=time_labeler)\n    grid_lines.configure_grid(ax=ax)\n\n    return ax\n</code></pre>"},{"location":"modules/plot/core/#latent_calendar.plot.core.calendar.plot_calendar","title":"<code>plot_calendar(calendar_iter, *, day_labeler=DayLabeler(), time_labeler=TimeLabeler(), display_settings=None, cmap=None, alpha=None, ax=None, grid_lines=GridLines(), monday_start=True)</code>","text":"<p>Plot a calendar from generator of values.</p> <p>This can plot both numpy matrix and DataFrame values as long as the iterable fits CALENDAR_ITERATION definition</p> <p>Parameters:</p> Name Type Description Default <code>calendar_iter</code> <code>CALENDAR_ITERATION</code> <p>CALENDAR_ITERATION</p> required <code>day_labeler</code> <code>DayLabeler</code> <p>instance in order to configure the day labels</p> <code>DayLabeler()</code> <code>time_labeler</code> <code>TimeLabeler</code> <p>instance in order to configure the time labels</p> <code>TimeLabeler()</code> <code>display_settings</code> <code>DisplaySettings | None</code> <p>override of the display settings in the calendar</p> <code>None</code> <code>cmap</code> <code>CMAP | None</code> <p>function that maps floats to string colors</p> <code>None</code> <code>ax</code> <code>Axes | None</code> <p>Optional axes to plot on</p> <code>None</code> <code>grid_lines</code> <code>GridLines</code> <p>GridLines instance</p> <code>GridLines()</code> <code>monday_start</code> <code>bool</code> <p>whether to start the week on Monday or Sunday</p> <code>True</code> <p>Returns:</p> Type Description <code>Axes</code> <p>Modified matplotlib axis</p> Source code in <code>latent_calendar/plot/core/calendar.py</code> <pre><code>def plot_calendar(\n    calendar_iter: CALENDAR_ITERATION,\n    *,\n    day_labeler: DayLabeler = DayLabeler(),\n    time_labeler: TimeLabeler = TimeLabeler(),\n    display_settings: DisplaySettings | None = None,\n    cmap: CMAP | None = None,\n    alpha: float | None = None,\n    ax: plt.Axes | None = None,\n    grid_lines: GridLines = GridLines(),\n    monday_start: bool = True,\n) -&gt; plt.Axes:\n    \"\"\"Plot a calendar from generator of values.\n\n    This can plot both numpy matrix and DataFrame values as long as the iterable fits CALENDAR_ITERATION definition\n\n    Args:\n        calendar_iter: CALENDAR_ITERATION\n        day_labeler: instance in order to configure the day labels\n        time_labeler: instance in order to configure the time labels\n        display_settings: override of the display settings in the calendar\n        cmap: function that maps floats to string colors\n        ax: Optional axes to plot on\n        grid_lines: GridLines instance\n        monday_start: whether to start the week on Monday or Sunday\n\n    Returns:\n        Modified matplotlib axis\n\n    \"\"\"\n    ax = plot_blank_calendar(\n        day_labeler=day_labeler,\n        time_labeler=time_labeler,\n        display_settings=display_settings,\n        ax=ax,\n        grid_lines=grid_lines,\n        monday_start=monday_start,\n    )\n\n    if cmap is None:\n\n        def cmap(x: float) -&gt; str:\n            return \"lightblue\"\n\n    for calendar_data in calendar_iter:\n        event = CalendarEvent.from_calendar_data(calendar_data=calendar_data)\n\n        event.plot(\n            ax=ax,\n            facecolor=cmap(calendar_data.value),\n            alpha=alpha,\n            monday_start=monday_start,\n        )\n\n    return ax\n</code></pre>"},{"location":"modules/plot/core/#latent_calendar.plot.core.calendar.plot_calendar_by_row","title":"<code>plot_calendar_by_row(df, max_cols=3, title_func=None, day_labeler=None, time_labeler=None, cmaps=None, grid_lines=GridLines(), monday_start=True)</code>","text":"<p>Iterate a DataFrame by row and plot calendar events.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>wide DataFrame where each column is the vocabulary</p> required <code>max_cols</code> <code>int</code> <p>max number of columns in the created grid.</p> <code>3</code> <code>title_func</code> <code>TITLE_FUNC | None</code> <p>function to make the title from DataFrame index and DataFrame row, default like '2020-01-01 n_trip(s) = 10'</p> <code>None</code> <code>day_labeler</code> <code>DayLabeler | None</code> <p>base day_labeler</p> <code>None</code> <code>time_labeler</code> <code>TimeLabeler | None</code> <p>base day_labeler</p> <code>None</code> <code>cmaps</code> <code>CMAP | ColorMap | CMAP_GENERATOR | None</code> <p>Colormapping function(s) to use for each row</p> <code>None</code> <code>grid_lines</code> <code>GridLines</code> <p>GridLines instance</p> <code>GridLines()</code> <code>monday_start</code> <code>bool</code> <p>whether to start the week on Monday or Sunday</p> <code>True</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>latent_calendar/plot/core/calendar.py</code> <pre><code>def plot_calendar_by_row(\n    df: pd.DataFrame,\n    max_cols: int = 3,\n    title_func: TITLE_FUNC | None = None,\n    day_labeler: DayLabeler | None = None,\n    time_labeler: TimeLabeler | None = None,\n    cmaps: CMAP | ColorMap | CMAP_GENERATOR | None = None,\n    grid_lines: GridLines = GridLines(),\n    monday_start: bool = True,\n) -&gt; None:\n    \"\"\"Iterate a DataFrame by row and plot calendar events.\n\n    Args:\n        df: wide DataFrame where each column is the vocabulary\n        max_cols: max number of columns in the created grid.\n        title_func: function to make the title from DataFrame index and DataFrame row, default like '2020-01-01 n_trip(s) = 10'\n        day_labeler: base day_labeler\n        time_labeler: base day_labeler\n        cmaps: Colormapping function(s) to use for each row\n        grid_lines: GridLines instance\n        monday_start: whether to start the week on Monday or Sunday\n\n    Returns:\n        None\n\n    \"\"\"\n    n_cols = len(df.columns)\n    if n_cols % 7 != 0:\n        raise CalendarFormatError(\n            f\"Number of columns must be a multiple of 7, got {n_cols} columns. Make sure DataFrame is in wide calendar format.\"\n        )\n\n    title_func = title_func if title_func is not None else default_title_func\n\n    if isinstance(cmaps, ColorMap):\n        cmaps = repeat(cmaps)\n\n    if cmaps is None:\n        cmaps = repeat(create_default_cmap(value=df.to_numpy().max()))\n\n    total = len(df)\n\n    for (ax, plot_axes), (idx, row), cmap in zip(\n        default_axes_and_grid_axes(\n            total=total,\n            max_cols=max_cols,\n            day_labeler=day_labeler,\n            time_labeler=time_labeler,\n        ),\n        df.iterrows(),\n        cmaps,\n    ):\n        calendar_data = row.to_numpy()\n        plot_calendar(\n            iterate_long_array(calendar_data),\n            day_labeler=day_labeler,\n            time_labeler=time_labeler,\n            grid_lines=grid_lines,\n            ax=ax,\n            cmap=cmap,\n            monday_start=monday_start,\n        )\n        title = title_func(idx, row)\n        ax.set_title(title)\n</code></pre>"},{"location":"modules/plot/core/#latent_calendar.plot.core.calendar.plot_dataframe_as_calendar","title":"<code>plot_dataframe_as_calendar(df, config, *, day_labeler=DayLabeler(), time_labeler=TimeLabeler(), grid_lines=GridLines(), cmap=None, alpha=None, ax=None, monday_start=True)</code>","text":"<p>Simple Wrapper about plot_calendar in order to plot DataFrame in various formats</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>DataFrame in format with columns in config instance</p> required <code>config</code> <code>DataFrameConfig</code> <p>DataFrameConfig</p> required <code>day_labeler</code> <code>DayLabeler</code> <p>instance in order to configure the day labels</p> <code>DayLabeler()</code> <code>time_labeler</code> <code>TimeLabeler</code> <p>instance in order to configure the time labels</p> <code>TimeLabeler()</code> <code>grid_lines</code> <code>GridLines</code> <p>GridLines instance</p> <code>GridLines()</code> <code>cmap</code> <code>CMAP | None</code> <p>function that maps floats to string colors</p> <code>None</code> <code>alpha</code> <code>float | None</code> <p>alpha level of each rectangle</p> <code>None</code> <code>ax</code> <code>Axes | None</code> <p>optional axis to plot on</p> <code>None</code> <code>monday_start</code> <code>bool</code> <p>whether to start the week on Monday or Sunday</p> <code>True</code> <p>Returns:</p> Type Description <code>Axes</code> <p>new or modified axes</p> Source code in <code>latent_calendar/plot/core/calendar.py</code> <pre><code>def plot_dataframe_as_calendar(\n    df: pd.DataFrame,\n    config: DataFrameConfig,\n    *,\n    day_labeler: DayLabeler = DayLabeler(),\n    time_labeler: TimeLabeler = TimeLabeler(),\n    grid_lines: GridLines = GridLines(),\n    cmap: CMAP | None = None,\n    alpha: float | None = None,\n    ax: plt.Axes | None = None,\n    monday_start: bool = True,\n) -&gt; plt.Axes:\n    \"\"\"Simple Wrapper about plot_calendar in order to plot DataFrame in various formats\n\n    Args:\n        df: DataFrame in format with columns in config instance\n        config: DataFrameConfig\n        day_labeler: instance in order to configure the day labels\n        time_labeler: instance in order to configure the time labels\n        grid_lines: GridLines instance\n        cmap: function that maps floats to string colors\n        alpha: alpha level of each rectangle\n        ax: optional axis to plot on\n        monday_start: whether to start the week on Monday or Sunday\n\n    Returns:\n        new or modified axes\n\n    \"\"\"\n    return plot_calendar(\n        iterate_dataframe(df, config),\n        day_labeler=day_labeler,\n        time_labeler=time_labeler,\n        cmap=cmap,\n        alpha=alpha,\n        ax=ax,\n        monday_start=monday_start,\n        grid_lines=grid_lines,\n    )\n</code></pre>"},{"location":"modules/plot/core/#latent_calendar.plot.core.calendar.plot_dataframe_grid_across_column","title":"<code>plot_dataframe_grid_across_column(df, grid_col, config=None, max_cols=3, *, alpha=None, monday_start=True, day_labeler=DayLabeler(), time_labeler=TimeLabeler(), grid_lines=GridLines())</code>","text":"<p>Plot the long DataFrame in a grid by some different column.</p> <p>Continuous version of the plot_calendar_by_row</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>DataFrame to plot. Requires all the columns in config</p> required <code>grid_col</code> <code>str</code> <p>column name of DataFrame to plot across</p> required <code>config</code> <code>DataFrameConfig | None</code> <p>DataFrameConfig instance of the column mapping. Default IterConfig</p> <code>None</code> <code>max_cols</code> <code>int</code> <p>max number of columns in the grid</p> <code>3</code> <code>alpha</code> <code>float | None</code> <p>alpha of each calendar event</p> <code>None</code> <code>monday_start</code> <code>bool</code> <p>whether to start the week on Monday or Sunday</p> <code>True</code> Source code in <code>latent_calendar/plot/core/calendar.py</code> <pre><code>def plot_dataframe_grid_across_column(\n    df: pd.DataFrame,\n    grid_col: str,\n    config: DataFrameConfig | None = None,\n    max_cols: int = 3,\n    *,\n    alpha: float | None = None,\n    monday_start: bool = True,\n    day_labeler: DayLabeler = DayLabeler(),\n    time_labeler: TimeLabeler = TimeLabeler(),\n    grid_lines: GridLines = GridLines(),\n) -&gt; None:\n    \"\"\"Plot the long DataFrame in a grid by some different column.\n\n    Continuous version of the plot_calendar_by_row\n\n    Args:\n        df: DataFrame to plot. Requires all the columns in config\n        grid_col: column name of DataFrame to plot across\n        config: DataFrameConfig instance of the column mapping. Default IterConfig\n        max_cols: max number of columns in the grid\n        alpha: alpha of each calendar event\n        monday_start: whether to start the week on Monday or Sunday\n\n    \"\"\"\n    if grid_col not in df.columns:\n        msg = f\"{grid_col} is not in the DataFrame.\"\n        raise KeyError(msg)\n\n    values = df.loc[:, grid_col].dropna().unique()\n    values.sort()\n\n    total = len(values)\n\n    for (ax, plot_axes), value in zip(\n        default_axes_and_grid_axes(\n            total=total,\n            max_cols=max_cols,\n            day_labeler=day_labeler,\n            time_labeler=time_labeler,\n        ),\n        values,\n    ):\n        idx = df[grid_col] == value\n        df_tmp = df.loc[idx, :]\n\n        day_labeler, time_labeler = plot_axes\n\n        plot_dataframe_as_calendar(\n            df=df_tmp,\n            config=config,\n            ax=ax,\n            day_labeler=day_labeler,\n            time_labeler=time_labeler,\n            alpha=alpha,\n            monday_start=monday_start,\n        )\n        ax.set_title(f\"{value}\")\n</code></pre>"},{"location":"modules/plot/core/#latent_calendar.plot.core.calendar.plot_series_as_calendar","title":"<code>plot_series_as_calendar(series, *, grid_lines=GridLines(), day_labeler=DayLabeler(), time_labeler=TimeLabeler(), cmap=None, alpha=None, ax=None, monday_start=True)</code>","text":"<p>Simple Wrapper about plot_calendar in order to plot Series in various formats</p> <p>Parameters:</p> Name Type Description Default <code>series</code> <code>Series</code> <p>Series in format with index as datetime and values as float</p> required <code>grid_lines</code> <code>GridLines</code> <p>GridLines instance</p> <code>GridLines()</code> <code>day_labeler</code> <code>DayLabeler</code> <p>instance in order to configure the day labels</p> <code>DayLabeler()</code> <code>time_labeler</code> <code>TimeLabeler</code> <p>instance in order to configure the time labels</p> <code>TimeLabeler()</code> <code>cmap</code> <code>CMAP | None</code> <p>function that maps floats to string colors</p> <code>None</code> <code>alpha</code> <code>float | None</code> <p>alpha level of each rectangle</p> <code>None</code> <code>ax</code> <code>Axes | None</code> <p>optional axis to plot on</p> <code>None</code> <code>monday_start</code> <code>bool</code> <p>whether to start the week on Monday or Sunday</p> <code>True</code> <p>Returns:</p> Type Description <code>Axes</code> <p>new or modified axes</p> Source code in <code>latent_calendar/plot/core/calendar.py</code> <pre><code>def plot_series_as_calendar(\n    series: pd.Series,\n    *,\n    grid_lines: GridLines = GridLines(),\n    day_labeler: DayLabeler = DayLabeler(),\n    time_labeler: TimeLabeler = TimeLabeler(),\n    cmap: CMAP | None = None,\n    alpha: float | None = None,\n    ax: plt.Axes | None = None,\n    monday_start: bool = True,\n) -&gt; plt.Axes:\n    \"\"\"Simple Wrapper about plot_calendar in order to plot Series in various formats\n\n    Args:\n        series: Series in format with index as datetime and values as float\n        grid_lines: GridLines instance\n        day_labeler: instance in order to configure the day labels\n        time_labeler: instance in order to configure the time labels\n        cmap: function that maps floats to string colors\n        alpha: alpha level of each rectangle\n        ax: optional axis to plot on\n        monday_start: whether to start the week on Monday or Sunday\n\n    Returns:\n        new or modified axes\n\n    \"\"\"\n    if cmap is None:\n        cmap = create_default_cmap(value=series.to_numpy().max())\n\n    return plot_calendar(\n        iterate_series(series),\n        day_labeler=day_labeler,\n        time_labeler=time_labeler,\n        cmap=cmap,\n        alpha=alpha,\n        ax=ax,\n        monday_start=monday_start,\n        grid_lines=grid_lines,\n    )\n</code></pre>"},{"location":"modules/plot/core/#latent_calendar.plot.core.model.plot_component_distribution","title":"<code>plot_component_distribution(X_latent, model, ax)</code>","text":"<p>Third profile plot.</p> Source code in <code>latent_calendar/plot/core/model.py</code> <pre><code>def plot_component_distribution(\n    X_latent: np.ndarray, model: LatentCalendar, ax: plt.Axes\n) -&gt; plt.Axes:\n    \"\"\"Third profile plot.\"\"\"\n    x = range(len(X_latent))\n    ax.bar(x, X_latent)\n    step = 1 if model.n_components &lt; 15 else 2\n    ax.set_xticks(np.arange(model.n_components, step=step))\n    ax.set_ylabel(\"P[L=l | Data]\")\n    ax.set_title(\"Latent Component Distribution\")\n\n    return ax\n</code></pre>"},{"location":"modules/plot/core/#latent_calendar.plot.core.model.plot_distribution","title":"<code>plot_distribution(X_probs, ax, display_y_axis=True, divergent=True, day_labeler=DayLabeler(), time_labeler=TimeLabeler())</code>","text":"<p>Second plot of the profile calendar probability distribution.</p> Source code in <code>latent_calendar/plot/core/model.py</code> <pre><code>def plot_distribution(\n    X_probs: np.ndarray,\n    ax: plt.Axes,\n    display_y_axis: bool = True,\n    divergent: bool = True,\n    day_labeler: DayLabeler = DayLabeler(),\n    time_labeler: TimeLabeler = TimeLabeler(),\n) -&gt; plt.Axes:\n    \"\"\"Second plot of the profile calendar probability distribution.\"\"\"\n    time_labeler.display = display_y_axis\n\n    data, cmap = settle_data_and_cmap(data=X_probs, divergent=divergent)\n\n    iter_data = iterate_long_array(data)\n\n    subtext = \"Comparison to random rate\" if divergent else \"Raw Probabilities\"\n    plot_calendar(\n        iter_data,\n        ax=ax,\n        cmap=cmap,\n        day_labeler=day_labeler,\n        time_labeler=time_labeler,\n    )\n    title = f\"Predicted Probability Distribution\\n{subtext}\"\n    ax.set_title(title)\n\n    return ax\n</code></pre>"},{"location":"modules/plot/core/#latent_calendar.plot.core.model.plot_model_components","title":"<code>plot_model_components(model, max_cols=5, divergent=True, components=None, day_labeler=DayLabeler(), time_labeler=TimeLabeler())</code>","text":"<p>Helper function to create plot of all the components of the LatentCalendar instance.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>LatentCalendar</code> <p>LatentCalendar instance</p> required <code>max_cols</code> <code>int</code> <p>maximum number of columns in the grid of calendar components.</p> <code>5</code> <code>divergent</code> <code>bool</code> <p>what data to plot</p> <code>True</code> <code>components</code> <code>Iterable[int] | None</code> <p>Specific subset of components to plot. Default is all</p> <code>None</code> <code>day_labeler</code> <code>DayLabeler</code> <p>DayLabeler instance</p> <code>DayLabeler()</code> <code>time_labeler</code> <code>TimeLabeler</code> <p>TimeLabeler instance</p> <code>TimeLabeler()</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>latent_calendar/plot/core/model.py</code> <pre><code>def plot_model_components(\n    model: LatentCalendar,\n    max_cols: int = 5,\n    divergent: bool = True,\n    components: Iterable[int] | None = None,\n    day_labeler: DayLabeler = DayLabeler(),\n    time_labeler: TimeLabeler = TimeLabeler(),\n) -&gt; None:\n    \"\"\"Helper function to create plot of all the components of the LatentCalendar instance.\n\n    Args:\n        model: LatentCalendar instance\n        max_cols: maximum number of columns in the grid of calendar components.\n        divergent: what data to plot\n        components: Specific subset of components to plot. Default is all\n        day_labeler: DayLabeler instance\n        time_labeler: TimeLabeler instance\n\n    Returns:\n        None\n\n    \"\"\"\n    if components is None:\n        components = list(range(model.n_components))\n\n    if any([component &gt; model.n_components - 1 for component in components]):\n        msg = f\"One of the listed components is greater than the total number {model.n_components}\"\n        raise ValueError(msg)\n\n    total = len(components)\n    normalized_components_to_plot = model.normalized_components_[components]\n\n    def get_title(component_idx: int) -&gt; str:\n        return f\"Component {component_idx}\"\n\n    # TOOD: refactor to just use the plot_calendar_by_row ?\n    values = zip(\n        components,\n        default_axes_and_grid_axes(\n            total=total,\n            max_cols=max_cols,\n            day_labeler=day_labeler,\n            time_labeler=time_labeler,\n        ),\n        normalized_components_to_plot,\n    )\n    for component_idx, (ax, plot_axes), latent in values:\n        data, cmap = settle_data_and_cmap(latent, divergent)\n\n        day_labeler, time_labeler = plot_axes\n        plot_calendar(\n            iterate_long_array(data),\n            cmap=cmap,\n            ax=ax,\n            day_labeler=day_labeler,\n            time_labeler=time_labeler,\n        )\n        title = get_title(component_idx=component_idx)\n        ax.set_title(title)\n</code></pre>"},{"location":"modules/plot/core/#latent_calendar.plot.core.model.plot_model_predictions","title":"<code>plot_model_predictions(X_to_predict, X_holdout, model, divergent=True, axes=None, day_labeler=DayLabeler(), time_labeler=TimeLabeler())</code>","text":"<p>Plot the model predictions compared to the test data.</p> <p>Parameters:</p> Name Type Description Default <code>X_to_predict</code> <code>ndarray</code> <p>Data for the model</p> required <code>X_holdout</code> <code>ndarray</code> <p>Holdout data for the model</p> required <code>model</code> <code>LatentCalendar</code> <p>LatentCalendar model instance</p> required <code>divergent</code> <code>bool</code> <p>Option to change the data displayed</p> <code>True</code> <code>axes</code> <code>Iterable[Axes]</code> <p>list of 3 axes to plot this data</p> <code>None</code> <p>Returns:</p> Type Description <code>Iterable[Axes]</code> <p>The axes used for plotting</p> Source code in <code>latent_calendar/plot/core/model.py</code> <pre><code>def plot_model_predictions(\n    X_to_predict: np.ndarray,\n    X_holdout: np.ndarray,\n    model: LatentCalendar,\n    divergent: bool = True,\n    axes: Iterable[plt.Axes] = None,\n    day_labeler: DayLabeler = DayLabeler(),\n    time_labeler: TimeLabeler = TimeLabeler(),\n) -&gt; Iterable[plt.Axes]:\n    \"\"\"Plot the model predictions compared to the test data.\n\n    Args:\n        X_to_predict: Data for the model\n        X_holdout: Holdout data for the model\n        model: LatentCalendar model instance\n        divergent: Option to change the data displayed\n        axes: list of 3 axes to plot this data\n\n    Returns:\n        The axes used for plotting\n\n    \"\"\"\n    X_to_predict = X_to_predict[np.newaxis, :]\n    X_holdout = X_holdout[np.newaxis, :]\n\n    if axes is None:\n        _, axes = plt.subplots(nrows=1, ncols=3)\n\n    X_to_predict_probs = model.predict(X_to_predict)[0]\n\n    ax = axes[0]\n    plot_raw_data(\n        array=X_to_predict, ax=ax, day_labeler=day_labeler, time_labeler=time_labeler\n    )\n    ax.set_title(\"Raw Data for Prediction\")\n\n    ax = axes[1]\n    plot_distribution(\n        X_probs=X_to_predict_probs,\n        ax=ax,\n        display_y_axis=False,\n        divergent=divergent,\n        day_labeler=day_labeler,\n        time_labeler=time_labeler,\n    )\n    ax.set_title(\"Distribution from Prediction\")\n\n    ax = axes[2]\n    plot_raw_data(\n        array=X_holdout,\n        ax=ax,\n        display_y_axis=False,\n        day_labeler=day_labeler,\n        time_labeler=time_labeler,\n    )\n    ax.set_title(\"Raw Data in Future\")\n\n    return axes\n</code></pre>"},{"location":"modules/plot/core/#latent_calendar.plot.core.model.plot_profile","title":"<code>plot_profile(array, model, divergent=True, axes=None, include_components=True, day_labeler=DayLabeler(), time_labeler=TimeLabeler())</code>","text":"<p>Create a profile plot with 3 different plots.</p> <p>Displays the raw data, predicted probability distribution, and latent breakdown.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>long array (n_timeslots, )</p> required <code>model</code> <code>LatentCalendar</code> <p>LatentCalendar model instance</p> required <code>divergent</code> <code>bool</code> <p>Option to change the data displayed</p> <code>True</code> <code>axes</code> <code>Iterable[Axes]</code> <p>list of 3 axes to plot this data</p> <code>None</code> <code>include_components</code> <code>bool</code> <p>If the last component plot should be included</p> <code>True</code> <code>day_labeler</code> <code>DayLabeler</code> <p>DayLabeler instance</p> <code>DayLabeler()</code> <code>time_labeler</code> <code>TimeLabeler</code> <p>TimeLabeler instance</p> <code>TimeLabeler()</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>None</p> Source code in <code>latent_calendar/plot/core/model.py</code> <pre><code>def plot_profile(\n    array: np.ndarray,\n    model: LatentCalendar,\n    divergent: bool = True,\n    axes: Iterable[plt.Axes] = None,\n    include_components: bool = True,\n    day_labeler: DayLabeler = DayLabeler(),\n    time_labeler: TimeLabeler = TimeLabeler(),\n) -&gt; np.ndarray:\n    \"\"\"Create a profile plot with 3 different plots.\n\n    Displays the raw data, predicted probability distribution, and latent breakdown.\n\n    Args:\n        array: long array (n_timeslots, )\n        model: LatentCalendar model instance\n        divergent: Option to change the data displayed\n        axes: list of 3 axes to plot this data\n        include_components: If the last component plot should be included\n        day_labeler: DayLabeler instance\n        time_labeler: TimeLabeler instance\n\n    Returns:\n        None\n\n    \"\"\"\n    ncols = 3 if include_components else 2\n    if axes is None:\n        _, axes = plt.subplots(nrows=1, ncols=ncols)\n\n    if len(axes) != ncols:\n        msg = \"The axes do not equal the number of plots required.\"\n        raise ValueError(msg)\n\n    # Data under model\n    X_new = array[np.newaxis, :]\n    X_probs = model.predict(X_new)[0]\n\n    # Raw Data\n    ax = axes[0]\n    plot_raw_data(\n        array=array, ax=ax, day_labeler=day_labeler, time_labeler=time_labeler\n    )\n\n    # Under Model\n    ax = axes[1]\n    plot_distribution(\n        X_probs=X_probs,\n        ax=ax,\n        display_y_axis=False,\n        divergent=divergent,\n        day_labeler=day_labeler,\n        time_labeler=time_labeler,\n    )\n\n    # Component distribution\n    if include_components:\n        ax = axes[2]\n        X_latent = model.transform(X_new)[0]\n        plot_component_distribution(X_latent=X_latent, model=model, ax=ax)\n\n    return axes\n</code></pre>"},{"location":"modules/plot/core/#latent_calendar.plot.core.model.plot_raw_data","title":"<code>plot_raw_data(array, ax, display_y_axis=True, day_labeler=DayLabeler(), time_labeler=TimeLabeler())</code>","text":"<p>First plot of raw data.</p> Source code in <code>latent_calendar/plot/core/model.py</code> <pre><code>def plot_raw_data(\n    array: np.ndarray,\n    ax: plt.Axes,\n    display_y_axis: bool = True,\n    day_labeler: DayLabeler = DayLabeler(),\n    time_labeler: TimeLabeler = TimeLabeler(),\n) -&gt; plt.Axes:\n    \"\"\"First plot of raw data.\"\"\"\n    try:\n        max_value = np.quantile(array[array &gt; 0], 0.95)\n    except IndexError:\n        max_value = 1\n\n    time_labeler.display = display_y_axis\n\n    cmap = create_default_cmap(value=max_value)\n\n    plot_calendar(\n        iterate_long_array(array),\n        ax=ax,\n        cmap=cmap,\n        time_labeler=time_labeler,\n        day_labeler=day_labeler,\n    )\n    ax.set_title(\"Raw Data\")\n\n    return ax\n</code></pre>"},{"location":"modules/plot/elements/","title":"Elements","text":"<p>The specific elements on the calendar plot.</p> <p>Includes x-axis, y-axis, and their settings, as well as the calendar events.</p>"},{"location":"modules/plot/elements/#latent_calendar.plot.elements.CalendarEvent","title":"<code>CalendarEvent</code>  <code>dataclass</code>","text":"<p>Something on the calendar.</p> <p>Plots rectangles on matplotlib axis.</p> <p>Parameters:</p> Name Type Description Default <code>day</code> <code>int</code> <p>The day of the week. 0 is Monday.</p> required <code>start</code> <code>float</code> <p>The start hour of the event.</p> required <code>end</code> <code>float | None</code> <p>The end hour of the event.</p> <code>None</code> <code>duration</code> <code>float | None</code> <p>The duration of the event. Only used if end is None.</p> <code>None</code> <code>days</code> <code>int</code> <p>The number of days the event spans. Default is 1.</p> <code>1</code> <p>Examples:</p> <p>Plot event from calendar data</p> <pre><code>calendar_data = CalendarData(day=0, start=0, end=2.5)\nevent = CalendarEvent.from_calendar_data(calendar_data=calendar_data, cmap=...)\nevent.plot(ax=ax)\n</code></pre> <p>Plot a single calendar event from vocab</p> <pre><code>event = CalendarEvent.from_vocab(\"00 01\")\nevent.plot(ax=ax)\n</code></pre> Source code in <code>latent_calendar/plot/elements.py</code> <pre><code>@dataclass\nclass CalendarEvent:\n    \"\"\"Something on the calendar.\n\n    Plots rectangles on matplotlib axis.\n\n    Args:\n        day: The day of the week. 0 is Monday.\n        start: The start hour of the event.\n        end: The end hour of the event.\n        duration: The duration of the event. Only used if end is None.\n        days: The number of days the event spans. Default is 1.\n\n    Examples:\n        Plot event from calendar data\n\n        ```python\n        calendar_data = CalendarData(day=0, start=0, end=2.5)\n        event = CalendarEvent.from_calendar_data(calendar_data=calendar_data, cmap=...)\n        event.plot(ax=ax)\n        ```\n\n        Plot a single calendar event from vocab\n\n        ```python\n        event = CalendarEvent.from_vocab(\"00 01\")\n        event.plot(ax=ax)\n        ```\n\n    \"\"\"\n\n    day: int\n    start: float\n    end: float | None = None\n    duration: float | None = None\n    days: int = 1\n\n    def __post_init__(self) -&gt; None:\n        if self.day not in range(DAYS_IN_WEEK):\n            raise ValueError(\"Day must be between 0 and 6\")\n\n        if self.end is None and self.duration is None:\n            raise ValueError(\"Either end or duration must be provided\")\n\n        if self.end is not None and self.duration is not None:\n            raise ValueError(\"Only one of end or duration can be provided\")\n\n        if self.end is None:\n            self.end = self.start + (self.duration / 60)\n            self.duration = None\n\n        if self.days not in range(1, DAYS_IN_WEEK + 1):\n            raise ValueError(\"Days must be between 1 and 7\")\n\n    @classmethod\n    def from_calendar_data(\n        cls,\n        calendar_data: CalendarData,\n    ) -&gt; \"CalendarEvent\":\n        return cls(\n            day=calendar_data.day,\n            start=calendar_data.start,\n            end=calendar_data.end,\n        )\n\n    @classmethod\n    def from_vocab(\n        cls,\n        vocab: str,\n        duration: float = 60.0,\n    ) -&gt; \"CalendarEvent\":\n        \"\"\"Constructor from vocab string in order to plot on an axis.\n\n        Args:\n            vocab: The vocab string.\n            duration: The duration of the event.\n\n        Example:\n            Plot on an axis\n\n            ```python\n            event = CalendarEvent.from_vocab(\"00 01\")\n            event.plot(ax=ax)\n            ```\n\n            Plot a two and half hour window\n\n            ```python\n            event = CalendarEvent.from_vocab(\"00 01\", hours=2.5)\n            event.plot(ax=ax)\n            ```\n\n        \"\"\"\n        day, hour = get_day_hour(vocab=vocab)\n\n        return cls(\n            day=day,\n            start=hour,\n            end=hour + (duration / 60),\n        )\n\n    @property\n    def multiday_tour(self) -&gt; bool:\n        if self.end == HOURS_IN_DAY:\n            return False\n\n        return self.end % HOURS_IN_DAY &lt; self.start\n\n    @property\n    def multiweek_tour(self) -&gt; bool:\n        return self.day + self.days &gt; DAYS_IN_WEEK\n\n    def _cap_event_at_week_end(self) -&gt; None:\n        self.days = DAYS_IN_WEEK - self.day\n\n    def _create_next_week_event(self) -&gt; \"CalendarEvent\":\n        return CalendarEvent(\n            day=0,\n            start=self.start,\n            end=self.end,\n            days=self.days - DAYS_IN_WEEK + self.day,\n        )\n\n    def _cap_event_at_midnight(self) -&gt; None:\n        self.end = min(HOURS_IN_DAY, self.end)\n\n    def _create_next_day_event(self) -&gt; \"CalendarEvent\":\n        \"\"\"In the case of tour going into the next day, this is the next item.\"\"\"\n        return CalendarEvent(\n            day=(self.day + 1) % DAYS_IN_WEEK,\n            start=0,\n            end=self.end % HOURS_IN_DAY,\n            days=self.days,\n        )\n\n    def separate_events(self) -&gt; list[\"CalendarEvent\"]:\n        \"\"\"Return list of events that represent the one event across different days.\n\n        Examples:\n            A single event that goes from 23:00 to 01:00 will be split into two events.\n\n            ```python\n            event = CalendarEvent(day=0, start=23, duration=2 * 60)\n\n            events = event.separate_events()\n            ```\n\n        \"\"\"\n        event = replace(self)\n        events = [event]\n\n        if event.multiday_tour:\n            events.append(event._create_next_day_event())\n            event._cap_event_at_midnight()\n\n        for event in events:\n            if not event.multiweek_tour:\n                continue\n\n            events.append(event._create_next_week_event())\n            event._cap_event_at_week_end()\n\n        return events\n\n    def _create_matplotlib_rectangle(\n        self, monday_start: bool, lw, fill: bool, linestyle, fillcolor, alpha, **kwargs\n    ) -&gt; plt.Rectangle:\n        \"\"\"Create a rectangle matplotlib instance from the event.\"\"\"\n        height = self.end - self.start\n        assert (\n            height &gt; 0.0\n        ), f\"The rectangle doesn't have positive height. Hour start {self.start} &gt; Hour end {self.end}\"\n\n        x = self.day if monday_start else (self.day + 1) % DAYS_IN_WEEK\n        rect_kwargs = {\n            \"xy\": [x, self.start],\n            \"width\": self.days,\n            \"height\": height,\n        }\n\n        rect_kwargs[\"edgecolor\"] = \"black\"\n        rect_kwargs[\"lw\"] = lw\n        rect_kwargs[\"fill\"] = fill\n        rect_kwargs[\"linestyle\"] = linestyle\n        rect_kwargs[\"facecolor\"] = fillcolor\n        rect_kwargs[\"alpha\"] = alpha\n\n        rect_kwargs.update(kwargs)\n\n        return plt.Rectangle(**rect_kwargs)\n\n    def plot(\n        self,\n        ax: plt.Axes,\n        monday_start: bool = True,\n        lw: float = 0.1,\n        fill: bool = True,\n        linestyle=None,\n        fillcolor=None,\n        alpha=None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Put the CalendarEvent instance onto an axis.\n\n        Options for kwargs [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.patches.Rectangle.html).\n\n        Args:\n            ax: Axis to plot on\n            monday_start: Whether to start the week on Monday or Sunday.\n            lw: The line width of the event.\n            fill: Whether to fill the event.\n            linestyle: The line style of the event.\n            fillcolor: The color of the event.\n            alpha: The alpha of the event.\n            kwargs: Addtional kwargs for the Patch instances or to override.\n\n        \"\"\"\n        for event in self.separate_events():\n            rectangle = event._create_matplotlib_rectangle(\n                monday_start=monday_start,\n                lw=lw,\n                fill=fill,\n                linestyle=linestyle,\n                fillcolor=fillcolor,\n                alpha=alpha,\n                **kwargs,\n            )\n            if \"label\" in kwargs:\n                kwargs.pop(\"label\")\n\n            ax.add_patch(rectangle)\n</code></pre>"},{"location":"modules/plot/elements/#latent_calendar.plot.elements.CalendarEvent.from_vocab","title":"<code>from_vocab(vocab, duration=60.0)</code>  <code>classmethod</code>","text":"<p>Constructor from vocab string in order to plot on an axis.</p> <p>Parameters:</p> Name Type Description Default <code>vocab</code> <code>str</code> <p>The vocab string.</p> required <code>duration</code> <code>float</code> <p>The duration of the event.</p> <code>60.0</code> Example <p>Plot on an axis</p> <pre><code>event = CalendarEvent.from_vocab(\"00 01\")\nevent.plot(ax=ax)\n</code></pre> <p>Plot a two and half hour window</p> <pre><code>event = CalendarEvent.from_vocab(\"00 01\", hours=2.5)\nevent.plot(ax=ax)\n</code></pre> Source code in <code>latent_calendar/plot/elements.py</code> <pre><code>@classmethod\ndef from_vocab(\n    cls,\n    vocab: str,\n    duration: float = 60.0,\n) -&gt; \"CalendarEvent\":\n    \"\"\"Constructor from vocab string in order to plot on an axis.\n\n    Args:\n        vocab: The vocab string.\n        duration: The duration of the event.\n\n    Example:\n        Plot on an axis\n\n        ```python\n        event = CalendarEvent.from_vocab(\"00 01\")\n        event.plot(ax=ax)\n        ```\n\n        Plot a two and half hour window\n\n        ```python\n        event = CalendarEvent.from_vocab(\"00 01\", hours=2.5)\n        event.plot(ax=ax)\n        ```\n\n    \"\"\"\n    day, hour = get_day_hour(vocab=vocab)\n\n    return cls(\n        day=day,\n        start=hour,\n        end=hour + (duration / 60),\n    )\n</code></pre>"},{"location":"modules/plot/elements/#latent_calendar.plot.elements.CalendarEvent.plot","title":"<code>plot(ax, monday_start=True, lw=0.1, fill=True, linestyle=None, fillcolor=None, alpha=None, **kwargs)</code>","text":"<p>Put the CalendarEvent instance onto an axis.</p> <p>Options for kwargs here.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>Axis to plot on</p> required <code>monday_start</code> <code>bool</code> <p>Whether to start the week on Monday or Sunday.</p> <code>True</code> <code>lw</code> <code>float</code> <p>The line width of the event.</p> <code>0.1</code> <code>fill</code> <code>bool</code> <p>Whether to fill the event.</p> <code>True</code> <code>linestyle</code> <p>The line style of the event.</p> <code>None</code> <code>fillcolor</code> <p>The color of the event.</p> <code>None</code> <code>alpha</code> <p>The alpha of the event.</p> <code>None</code> <code>kwargs</code> <p>Addtional kwargs for the Patch instances or to override.</p> <code>{}</code> Source code in <code>latent_calendar/plot/elements.py</code> <pre><code>def plot(\n    self,\n    ax: plt.Axes,\n    monday_start: bool = True,\n    lw: float = 0.1,\n    fill: bool = True,\n    linestyle=None,\n    fillcolor=None,\n    alpha=None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Put the CalendarEvent instance onto an axis.\n\n    Options for kwargs [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.patches.Rectangle.html).\n\n    Args:\n        ax: Axis to plot on\n        monday_start: Whether to start the week on Monday or Sunday.\n        lw: The line width of the event.\n        fill: Whether to fill the event.\n        linestyle: The line style of the event.\n        fillcolor: The color of the event.\n        alpha: The alpha of the event.\n        kwargs: Addtional kwargs for the Patch instances or to override.\n\n    \"\"\"\n    for event in self.separate_events():\n        rectangle = event._create_matplotlib_rectangle(\n            monday_start=monday_start,\n            lw=lw,\n            fill=fill,\n            linestyle=linestyle,\n            fillcolor=fillcolor,\n            alpha=alpha,\n            **kwargs,\n        )\n        if \"label\" in kwargs:\n            kwargs.pop(\"label\")\n\n        ax.add_patch(rectangle)\n</code></pre>"},{"location":"modules/plot/elements/#latent_calendar.plot.elements.CalendarEvent.separate_events","title":"<code>separate_events()</code>","text":"<p>Return list of events that represent the one event across different days.</p> <p>Examples:</p> <p>A single event that goes from 23:00 to 01:00 will be split into two events.</p> <pre><code>event = CalendarEvent(day=0, start=23, duration=2 * 60)\n\nevents = event.separate_events()\n</code></pre> Source code in <code>latent_calendar/plot/elements.py</code> <pre><code>def separate_events(self) -&gt; list[\"CalendarEvent\"]:\n    \"\"\"Return list of events that represent the one event across different days.\n\n    Examples:\n        A single event that goes from 23:00 to 01:00 will be split into two events.\n\n        ```python\n        event = CalendarEvent(day=0, start=23, duration=2 * 60)\n\n        events = event.separate_events()\n        ```\n\n    \"\"\"\n    event = replace(self)\n    events = [event]\n\n    if event.multiday_tour:\n        events.append(event._create_next_day_event())\n        event._cap_event_at_midnight()\n\n    for event in events:\n        if not event.multiweek_tour:\n            continue\n\n        events.append(event._create_next_week_event())\n        event._cap_event_at_week_end()\n\n    return events\n</code></pre>"},{"location":"modules/plot/elements/#latent_calendar.plot.elements.DayLabeler","title":"<code>DayLabeler</code>  <code>dataclass</code>","text":"<p>Day of the week axis.</p> <p>This is typically the x-axis.</p> <p>Parameters:</p> Name Type Description Default <code>day_start</code> <code>int</code> <p>The day to start the plot at.</p> <code>0</code> <code>days_of_week</code> <code>list[str]</code> <p>The names of the days of the week.</p> <code>create_default_days()</code> <code>rotation</code> <code>float | None</code> <p>The rotation of the day labels.</p> <code>45</code> <code>display</code> <code>bool</code> <p>Whether to display the day labels.</p> <code>True</code> Source code in <code>latent_calendar/plot/elements.py</code> <pre><code>@dataclass\nclass DayLabeler:\n    \"\"\"Day of the week axis.\n\n    This is typically the x-axis.\n\n    Args:\n        day_start: The day to start the plot at.\n        days_of_week: The names of the days of the week.\n        rotation: The rotation of the day labels.\n        display: Whether to display the day labels.\n\n    \"\"\"\n\n    day_start: int = 0\n    days_of_week: list[str] = field(default_factory=create_default_days)\n    rotation: float | None = 45\n    display: bool = True\n\n    def __post_init__(self) -&gt; None:\n        if self.day_start not in range(DAYS_IN_WEEK):\n            msg = \"'day_start' value must be 0: Monday or 6: Sunday\"\n            raise ValueError(msg)\n\n    @property\n    def day_labels(self) -&gt; list[str]:\n        \"\"\"What is added to the plot. If this is display, empty ticks.\"\"\"\n        if not self.display:\n            return [\"\" for _ in range(DAYS_IN_WEEK)]\n\n        return self.days_of_week[self.day_start :] + self.days_of_week[: self.day_start]\n\n    def create_labels(self, ax: plt.Axes, axis: str = \"x\") -&gt; None:\n        \"\"\"Create the labels for the plot.\"\"\"\n        getattr(ax, f\"set_{axis}lim\")(0, DAYS_IN_WEEK)\n        getattr(ax, f\"set_{axis}ticks\")(\n            [i + 0.5 for i in range(DAYS_IN_WEEK)],\n            self.day_labels,\n            rotation=self.rotation,\n        )\n\n        if axis == \"y\":\n            ax.invert_yaxis()\n</code></pre>"},{"location":"modules/plot/elements/#latent_calendar.plot.elements.DayLabeler.day_labels","title":"<code>day_labels</code>  <code>property</code>","text":"<p>What is added to the plot. If this is display, empty ticks.</p>"},{"location":"modules/plot/elements/#latent_calendar.plot.elements.DayLabeler.create_labels","title":"<code>create_labels(ax, axis='x')</code>","text":"<p>Create the labels for the plot.</p> Source code in <code>latent_calendar/plot/elements.py</code> <pre><code>def create_labels(self, ax: plt.Axes, axis: str = \"x\") -&gt; None:\n    \"\"\"Create the labels for the plot.\"\"\"\n    getattr(ax, f\"set_{axis}lim\")(0, DAYS_IN_WEEK)\n    getattr(ax, f\"set_{axis}ticks\")(\n        [i + 0.5 for i in range(DAYS_IN_WEEK)],\n        self.day_labels,\n        rotation=self.rotation,\n    )\n\n    if axis == \"y\":\n        ax.invert_yaxis()\n</code></pre>"},{"location":"modules/plot/elements/#latent_calendar.plot.elements.DisplaySettings","title":"<code>DisplaySettings</code>  <code>dataclass</code>","text":"<p>Small wrapper to hold the display settings in the plots.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>bool</code> <p>Whether to x axis the plot.</p> <code>True</code> <code>y</code> <code>bool</code> <p>Whether to y axis the plot.</p> <code>True</code> Source code in <code>latent_calendar/plot/elements.py</code> <pre><code>@dataclass\nclass DisplaySettings:\n    \"\"\"Small wrapper to hold the display settings in the plots.\n\n    Args:\n        x: Whether to x axis the plot.\n        y: Whether to y axis the plot.\n\n    \"\"\"\n\n    x: bool = True\n    y: bool = True\n</code></pre>"},{"location":"modules/plot/elements/#latent_calendar.plot.elements.GridLines","title":"<code>GridLines</code>  <code>dataclass</code>","text":"<p>Grid lines between the calendar for the plot.</p> <p>Parameters:</p> Name Type Description Default <code>dow</code> <code>bool</code> <p>Whether to add day of week grid lines.</p> <code>False</code> <code>hour</code> <code>bool</code> <p>Whether to add hour grid lines.</p> <code>False</code> <code>color</code> <code>str</code> <p>The color of the grid lines.</p> <code>'black'</code> <code>linestyle</code> <code>str</code> <p>The style of the grid lines.</p> <code>'--'</code> <code>alpha</code> <code>float</code> <p>The alpha of the grid lines.</p> <code>0.2</code> Source code in <code>latent_calendar/plot/elements.py</code> <pre><code>@dataclass\nclass GridLines:\n    \"\"\"Grid lines between the calendar for the plot.\n\n    Args:\n        dow: Whether to add day of week grid lines.\n        hour: Whether to add hour grid lines.\n        color: The color of the grid lines.\n        linestyle: The style of the grid lines.\n        alpha: The alpha of the grid lines.\n\n    \"\"\"\n\n    dow: bool = False\n    hour: bool = False\n    color: str = \"black\"\n    linestyle: str = \"--\"\n    alpha: float = 0.2\n\n    def configure_grid(self, ax: plt.Axes) -&gt; None:\n        if self.dow:\n            for dow in range(DAYS_IN_WEEK):\n                ax.axvline(\n                    x=dow + 1,\n                    color=self.color,\n                    linestyle=self.linestyle,\n                    alpha=self.alpha,\n                )\n\n        if self.hour:\n            for hour in range(HOURS_IN_DAY):\n                ax.axhline(\n                    y=hour + 1,\n                    color=self.color,\n                    linestyle=self.linestyle,\n                    alpha=self.alpha,\n                )\n</code></pre>"},{"location":"modules/plot/elements/#latent_calendar.plot.elements.TimeLabeler","title":"<code>TimeLabeler</code>  <code>dataclass</code>","text":"<p>This is time of day and all its settings in the plot.</p> <p>This is typically the y-axis.</p> <p>Parameters:</p> Name Type Description Default <code>hour_formatter</code> <code>HourFormatter</code> <p>The formatter for the hour labels.</p> <code>HourFormatter()</code> <code>start</code> <code>int</code> <p>The hour to start the plot at.</p> <code>0</code> <code>stride</code> <code>int</code> <p>The number of hours to skip between ticks.</p> <code>2</code> <code>display</code> <code>bool</code> <p>Whether to display the hour labels.</p> <code>True</code> <code>rotation</code> <code>float | None</code> <p>The rotation of the hour labels.</p> <code>0</code> Source code in <code>latent_calendar/plot/elements.py</code> <pre><code>@dataclass\nclass TimeLabeler:\n    \"\"\"This is time of day and all its settings in the plot.\n\n    This is typically the y-axis.\n\n    Args:\n        hour_formatter: The formatter for the hour labels.\n        start: The hour to start the plot at.\n        stride: The number of hours to skip between ticks.\n        display: Whether to display the hour labels.\n        rotation: The rotation of the hour labels.\n\n    \"\"\"\n\n    hour_formatter: HourFormatter = field(default_factory=HourFormatter)\n    start: int = 0\n    stride: int = 2\n    display: bool = True\n    rotation: float | None = 0\n\n    def get_hours(self) -&gt; tuple[list[int], list[str]]:\n        return range(HOURS_IN_DAY + 1)[:: self.stride]\n\n    def create_labels(self, ax: plt.Axes, axis: str = \"y\") -&gt; None:\n        \"\"\"Create the hour labels on the plot ax.\"\"\"\n        if axis not in {\"x\", \"y\"}:\n            raise ValueError(\"Only supported for the x and y.\")\n\n        hours = self.get_hours()\n        hour_name_func = self.label if self.display else self.empty_label\n        hour_names = hour_name_func(hours)\n\n        getattr(ax, f\"set_{axis}ticks\")(hours, hour_names, rotation=self.rotation)\n        getattr(ax, f\"set_{axis}lim\")(0, HOURS_IN_DAY)\n\n        if axis == \"y\":\n            ax.invert_yaxis()\n\n    def label(self, hrs: list[int]) -&gt; list[str]:\n        return [self.hour_formatter(hr) for hr in hrs]\n\n    def empty_label(self, hrs: list[int]) -&gt; list[str]:\n        return [\"\" for _ in range(len(hrs))]\n</code></pre>"},{"location":"modules/plot/elements/#latent_calendar.plot.elements.TimeLabeler.create_labels","title":"<code>create_labels(ax, axis='y')</code>","text":"<p>Create the hour labels on the plot ax.</p> Source code in <code>latent_calendar/plot/elements.py</code> <pre><code>def create_labels(self, ax: plt.Axes, axis: str = \"y\") -&gt; None:\n    \"\"\"Create the hour labels on the plot ax.\"\"\"\n    if axis not in {\"x\", \"y\"}:\n        raise ValueError(\"Only supported for the x and y.\")\n\n    hours = self.get_hours()\n    hour_name_func = self.label if self.display else self.empty_label\n    hour_names = hour_name_func(hours)\n\n    getattr(ax, f\"set_{axis}ticks\")(hours, hour_names, rotation=self.rotation)\n    getattr(ax, f\"set_{axis}lim\")(0, HOURS_IN_DAY)\n\n    if axis == \"y\":\n        ax.invert_yaxis()\n</code></pre>"},{"location":"modules/plot/grid_settings/","title":"Grid settings","text":""},{"location":"modules/plot/grid_settings/#latent_calendar.plot.grid_settings.default_plot_axes_in_grid","title":"<code>default_plot_axes_in_grid(nrows, ncols, total=None, day_labeler=None, time_labeler=None)</code>","text":"<p>Additional layer on the display_settings_in_grid in order to modify the settings.</p> <p>Yields:</p> Type Description <code>PlotAxes</code> <p>PlotAxes instance with appropriate display settings based on the position in the grid.</p> Source code in <code>latent_calendar/plot/grid_settings.py</code> <pre><code>def default_plot_axes_in_grid(\n    nrows: int,\n    ncols: int,\n    total: int | None = None,\n    day_labeler: DayLabeler | None = None,\n    time_labeler: TimeLabeler | None = None,\n) -&gt; Generator[PlotAxes, None, None]:\n    \"\"\"Additional layer on the display_settings_in_grid in order to modify the settings.\n\n    Yields:\n        PlotAxes instance with appropriate display settings based on the position in the grid.\n\n    \"\"\"\n    day_labeler = day_labeler if day_labeler is not None else DayLabeler()\n    default_stride = 2 if nrows &lt;= 2 else 4\n    time_labeler = (\n        time_labeler if time_labeler is not None else TimeLabeler(stride=default_stride)\n    )\n\n    for display_settings in display_settings_in_grid(\n        nrows=nrows, ncols=ncols, total=total\n    ):\n        day_labeler.display = display_settings.x\n        time_labeler.display = display_settings.y\n\n        yield day_labeler, time_labeler\n</code></pre>"},{"location":"modules/plot/grid_settings/#latent_calendar.plot.grid_settings.display_settings_in_grid","title":"<code>display_settings_in_grid(nrows, ncols, total=None)</code>","text":"<p>Helper for display logic in a grid.</p> <p>Can be used with zip since zip function will stop at the shorts of the iterators</p> <p>Yields:</p> Type Description <code>DisplaySettings</code> <p>DisplaySettings instance with the appropriate settings based on position in the grid.</p> Source code in <code>latent_calendar/plot/grid_settings.py</code> <pre><code>def display_settings_in_grid(\n    nrows: int,\n    ncols: int,\n    total: int | None = None,\n) -&gt; Generator[DisplaySettings, None, None]:\n    \"\"\"Helper for display logic in a grid.\n\n    Can be used with zip since zip function will stop at the shorts of the iterators\n\n    Yields:\n        DisplaySettings instance with the appropriate settings based on position in the grid.\n\n    \"\"\"\n    total = total if total is not None else nrows * ncols\n\n    yield from (\n        DisplaySettings(\n            x=last_in_column(i, nrows, ncols, total), y=is_left_edge(i, ncols)\n        )\n        for i in range(total)\n    )\n</code></pre>"},{"location":"modules/plot/grid_settings/#latent_calendar.plot.grid_settings.get_rows_and_cols","title":"<code>get_rows_and_cols(n, max_cols)</code>","text":"<p>Return the number of rows and cols.</p> Source code in <code>latent_calendar/plot/grid_settings.py</code> <pre><code>def get_rows_and_cols(n: int, max_cols: int) -&gt; tuple[int, int]:\n    \"\"\"Return the number of rows and cols.\"\"\"\n    nrows = max((n // max_cols) + 1, 1)\n    ncols = min(n, max_cols)\n\n    if n % max_cols == 0:\n        nrows -= 1\n\n    return nrows, ncols\n</code></pre>"},{"location":"modules/plot/grid_settings/#latent_calendar.plot.grid_settings.grid_axes","title":"<code>grid_axes(nrows, ncols, total)</code>","text":"<p>Yields a grid of size nrow, ncols with total cap.</p> <p>Using this instead of plt.subplots(ncols, nrows) and deleting</p> Source code in <code>latent_calendar/plot/grid_settings.py</code> <pre><code>def grid_axes(nrows: int, ncols: int, total: int) -&gt; Generator[plt.Axes, None, None]:\n    \"\"\"Yields a grid of size nrow, ncols with total cap.\n\n    Using this instead of plt.subplots(ncols, nrows) and deleting\n\n    \"\"\"\n    gs = gridspec.GridSpec(nrows, ncols)\n\n    fig = plt.figure()\n\n    yield from (fig.add_subplot(gs[i]) for i in range(total))\n</code></pre>"},{"location":"modules/plot/iterate/","title":"Iterate","text":"<p>Generalize the iteration to support different data formats. Namely,</p> <ul> <li>2d numpy array</li> <li>1d numpy array (long format)</li> <li>pandas Series</li> <li>pandas DataFrame with various columns</li> </ul> <p>This powers the calendar plot and is passed into the <code>plot_calendar</code> function.</p> <p>Examples:</p> <p>Plot calendar based on 1d numpy array.</p> <pre><code>import numpy as np\n\nfrom latent_calendar.plot import plot_calendar\nfrom latent_calendar.plot.iterate import iterate_long_array\n\ndata = np.ones(7 * 24)\nplot_calendar(\n    iterate_long_array(data),\n)\n</code></pre> <p>Plot calendar based on 2d numpy array.</p> <pre><code>from latent_calendar.plot import plot_calendar\n\ndata = np.ones((7, 24))\nplot_calendar(\n    iterate_matrix(data),\n)\n</code></pre> <p>Plot calendar for every half hour instead of every hour. NOTE: This happens automatically!</p> <pre><code>from latent_calendar.plot import plot_calendar\n\ndata = np.ones((7, 24 * 2))\nplot_calendar(\n    iterate_matrix(data),\n)\n</code></pre>"},{"location":"modules/plot/iterate/#latent_calendar.plot.iterate.CalendarData","title":"<code>CalendarData</code>  <code>dataclass</code>","text":"<p>All the data that goes into calendar plot.</p> Source code in <code>latent_calendar/plot/iterate.py</code> <pre><code>@dataclass\nclass CalendarData:\n    \"\"\"All the data that goes into calendar plot.\"\"\"\n\n    day: int\n    start: float\n    end: float\n    value: float\n</code></pre>"},{"location":"modules/plot/iterate/#latent_calendar.plot.iterate.IterConfig","title":"<code>IterConfig</code>  <code>dataclass</code>","text":"<p>               Bases: <code>DataFrameConfig</code></p> <p>Small wrapper to hold the column mapping in DataFrame.</p> Source code in <code>latent_calendar/plot/iterate.py</code> <pre><code>@dataclass\nclass IterConfig(DataFrameConfig):\n    \"\"\"Small wrapper to hold the column mapping in DataFrame.\"\"\"\n\n    day: str = \"day_of_week\"\n    start: str = \"hour_start\"\n    end: str = \"hour_end\"\n    value: str = \"value\"\n\n    @property\n    def columns(self) -&gt; list[str]:\n        return [self.day, self.start, self.end]\n\n    def extract_columns(self, df: pd.DataFrame) -&gt; FRAME_ITER:\n        self._check_columns(df)\n        return (\n            df[self.day],\n            df[self.start],\n            df[self.end],\n            self._default_repeat(df, self.value, VALUE_DEFAULT),\n        )\n</code></pre>"},{"location":"modules/plot/iterate/#latent_calendar.plot.iterate.VocabIterConfig","title":"<code>VocabIterConfig</code>  <code>dataclass</code>","text":"<p>               Bases: <code>DataFrameConfig</code></p> <p>Small wrapper to hold the column mapping in the DataFrame.</p> Source code in <code>latent_calendar/plot/iterate.py</code> <pre><code>@dataclass\nclass VocabIterConfig(DataFrameConfig):\n    \"\"\"Small wrapper to hold the column mapping in the DataFrame.\"\"\"\n\n    vocab: str = \"vocab\"\n    value: str = \"value\"\n\n    @property\n    def columns(self) -&gt; list[str]:\n        return [self.vocab]\n\n    def extract_columns(self, df: pd.DataFrame) -&gt; FRAME_ITER:\n        self._check_columns(df)\n\n        day = df[self.vocab].str.split(\" \").apply(lambda x: int(x[0]))\n        start = df[self.vocab].str.split(\" \").apply(lambda x: int(x[1]))\n\n        return (\n            day,\n            start,\n            start + 1,\n            self._default_repeat(df, self.value, VALUE_DEFAULT),\n        )\n</code></pre>"},{"location":"modules/plot/iterate/#latent_calendar.plot.iterate.iterate_dataframe","title":"<code>iterate_dataframe(df, config)</code>","text":"<p>Iterate the calendar data in DataFrame form based on config.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>DataFrame with calendar data.</p> required <code>config</code> <code>DataFrameConfig</code> <p>Configuration to describe what columns to use.</p> required Source code in <code>latent_calendar/plot/iterate.py</code> <pre><code>def iterate_dataframe(\n    df: pd.DataFrame,\n    config: DataFrameConfig,\n) -&gt; CALENDAR_ITERATION:\n    \"\"\"Iterate the calendar data in DataFrame form based on config.\n\n    Args:\n        df: DataFrame with calendar data.\n        config: Configuration to describe what columns to use.\n\n    \"\"\"\n    for values in zip(*config.extract_columns(df)):\n        yield CalendarData(*values)\n</code></pre>"},{"location":"modules/plot/iterate/#latent_calendar.plot.iterate.iterate_matrix","title":"<code>iterate_matrix(calendar_data)</code>","text":"<p>Iterates the calendar matrix of values.</p> Source code in <code>latent_calendar/plot/iterate.py</code> <pre><code>def iterate_matrix(calendar_data: np.ndarray) -&gt; CALENDAR_ITERATION:\n    \"\"\"Iterates the calendar matrix of values.\"\"\"\n    if calendar_data.ndim != 2:\n        raise ValueError(f\"Data must be 2d not of shape {calendar_data.shape}\")\n\n    n_days, n_hours = calendar_data.shape\n\n    if n_days != DAYS_IN_WEEK:\n        raise ValueError(f\"Data must have {DAYS_IN_WEEK} days not {n_days}\")\n\n    step_size = HOURS_IN_DAY / n_hours\n\n    for day, hours in enumerate(calendar_data):\n        for hour, value in enumerate(hours):\n            start = hour * step_size\n            end = start + step_size\n            yield CalendarData(day, start, end, value)\n</code></pre>"}]}