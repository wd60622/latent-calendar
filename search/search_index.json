{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Latent Calendar","text":"<p>Analyze and model data on a weekly calendar</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install latent-calendar\n</code></pre>"},{"location":"#features","title":"Features","text":"<ul> <li>Integrated automatically into <code>pandas</code> with <code>cal</code> attribute on DataFrames and Series </li> <li>Compatibility with <code>scikit-learn</code> pipelines</li> <li>Transform and visualize data on a weekly calendar</li> <li>Model weekly calendar data with a mixture of calendars</li> <li>Create lower dimensional representations of calendar data</li> </ul>"},{"location":"draft/","title":"Draft","text":""},{"location":"draft/#1-transform-and-visualize","title":"1. Transform and visualize","text":"<p>Transform and visualize data on a weekly calendar with the <code>cal</code> attribute of DataFrames.</p> <pre><code>import matplotlib.pyplot as plt\nfrom latent_calendar.datasets import load_chicago_bikes\ndf = load_chicago_bikes()\ndf_member_casual = df.cal.aggregate_events(\"member_casual\", timestamp_col=\"started_at\")\n(\ndf_member_casual\n.cal.normalize(\"max\")\n.cal.plot_by_row()\n)\nfig = plt.gcf()\nfig.suptitle(\"Bike Rentals by Member Type\")\nplt.show()\n</code></pre> <p></p>"},{"location":"draft/#2-find-latent-structure","title":"2. Find latent structure","text":"<p>The <code>LatentCalendar</code> models calendar data by breaking down each calendar into a mixture of <code>n_components</code> calendars. Read more on the methodology here.</p> <pre><code>from latent_calendar import LatentCalendar\nfrom latent_calendar.plot import plot_model_components\ndf_stations = df.cal.aggregate_events(\"start_station_name\", timestamp_col=\"started_at\")\nmodel = LatentCalendar(n_components=3, random_state=42)\nmodel.fit(df_wide)\nplot_model_components(model)\nfig = plt.gcf()\nfig.suptitle(\"Chicago Bike Rental Model Components\")\nplt.show()\n</code></pre> <p></p>"},{"location":"draft/#3-recover-components-and-distributions","title":"3. Recover components and distributions","text":"<p>The <code>LatentCalendar</code> provides soft clusters for each row which can be recovered with the <code>transform</code> method.</p> <pre><code>df_component_probs = df_stations.cal.transform(model=model)\nhist_kwargs = dict(bins=10, edgecolor=\"black\", grid=False, layout=(1, 3))\naxes = df_component_probs.hist(**hist_kwargs)\naxes = axes.ravel()\nfor ax in axes: \nax.set_xlabel(\"Probability\")\ntitle = ax.get_title()\nax.set_title(f\"Component {title}\")\naxes[0].set_ylabel(\"# Stations\")\nfig = plt.gcf()\nfig.suptitle(\"Station Component Distributions\")\nplt.show()\n</code></pre> <p></p> <p>The <code>predict</code> method recovers the joint distribution of the calendar data using the latent calendar components. </p> <pre><code>stations = [\"Wood St &amp; Milwaukee Ave\", \"Theater on the Lake\", \"Wabash Ave &amp; Grand Ave\"]\ndf_stations.loc[stations].cal.plot_profile()\nplt.show()\n</code></pre> <p></p>"},{"location":"methodology/","title":"Methodology","text":"<p>The methodology comes from the generation process of the data and realization that discretized times of day can be modeled with a multinomial distribution. More details to come.</p>"},{"location":"examples/cal-attribute/","title":"Pandas Extensions","text":"<p>Transform and visualize data on a weekly calendar with the <code>cal</code> attribute of DataFrames.</p>"},{"location":"examples/cal-attribute/#event-level-data","title":"Event Level Data","text":"<pre><code>import matplotlib.pyplot as plt\nfrom latent_calendar.datasets import load_chicago_bikes\ndf = load_chicago_bikes()\ndf.head()\n</code></pre> <pre><code>                 start_station_name end_station_name  rideable_type          started_at            ended_at member_casual\nride_id\nABF4F851DE485B76                NaN              NaN  electric_bike 2023-06-30 18:56:13 2023-06-30 19:30:40        member\nF123B5D34B002CDB                NaN              NaN  electric_bike 2023-06-30 06:12:31 2023-06-30 06:23:05        member\nCA8E2C38AF641DFB                NaN              NaN  electric_bike 2023-06-30 08:28:51 2023-06-30 08:37:45        member\n93CCE4EA48CFDB69                NaN              NaN  electric_bike 2023-06-30 09:09:24 2023-06-30 09:17:41        member\nFDBCEFE7890F7262                NaN              NaN  electric_bike 2023-06-30 16:29:48 2023-06-30 16:38:51        member\n</code></pre>"},{"location":"examples/cal-attribute/#calendar-data","title":"Calendar Data","text":"<p>Aggregate event level data into wide format calendar data with the <code>cal.aggregate_events</code> method. This results in 7 * 24 = 168 columns, one for each hour of the week.</p> <pre><code>df_member_casual = df.cal.aggregate_events(\"member_casual\", \"started_at\")\n</code></pre> <pre><code>vocab          00 00  00 01  00 02  00 03  00 04  00 05  ...  06 18  06 19  06 20  06 21  06 22  06 23\nmember_casual                                            ...\ncasual           250    137    102     55     47     99  ...   1195   1165    980    774    488    331\nmember           165     89     74     52     59    273  ...   1355   1251   1137    800    505    294\n\n[2 rows x 168 columns]\n</code></pre>"},{"location":"examples/cal-attribute/#visualize-calendar-data","title":"Visualize Calendar Data","text":"<p>Various plot methods are available on the <code>cal</code> attribute of DataFrames. For instance, the <code>plot_by_row</code> plots each row of the wide format calendar data as a separate calendar.</p> <p>Custom color maps can be passed, but normalizing each row by the maximum value also does the trick.</p> <pre><code>(\ndf_member_casual\n.cal.normalize(\"max\")\n.cal.plot_by_row()\n)\nfig = plt.gcf()\nfig.suptitle(\"Bike Rentals by Member Type\")\nplt.show()\n</code></pre> <p></p>"},{"location":"examples/create-segments/","title":"Create segments","text":"<p>Create some segments for a calendar: </p> <pre><code>import pandas as pd\nimport numpy as np\nfrom latent_calendar.segments import create_box_segment, stack_segments\nmornings = create_box_segment(\nday_start=0, day_end=7, hour_start=6, hour_end=11, name=\"Mornings\"\n) \nafternoons = create_box_segment(\nday_start=0, day_end=7, hour_start=11, hour_end=16, name=\"Afternoons\"\n)\nevenings = create_box_segment(\nday_start=0, day_end=7, hour_start=16, hour_end=21, name=\"Evenings\"\n)\ndf_segments = stack_segments([\nmornings,\nafternoons,\nevenings,\n])\ndf_segments.cal.plot_by_row()\n</code></pre> <p></p> <p>These can be used to sum over for analysis of counts or probabilities by segment.</p> <pre><code>nrows = 10\nncols = len(df_segments.columns)\ndf = pd.DataFrame(np.ones((nrows, ncols)))\ndf_summed = df.cal.sum_over_segments(df_segments)\ndf_summed\n</code></pre> <pre><code>   Mornings  Afternoons  Evenings\n0      35.0        35.0      35.0\n1      35.0        35.0      35.0\n2      35.0        35.0      35.0\n3      35.0        35.0      35.0\n4      35.0        35.0      35.0\n5      35.0        35.0      35.0\n6      35.0        35.0      35.0\n7      35.0        35.0      35.0\n8      35.0        35.0      35.0\n9      35.0        35.0      35.0\n</code></pre>"},{"location":"examples/generation-process/","title":"Generation process","text":"<p>Some sample data can be generated with the <code>sample_from_lda</code> function. More to come!</p>"},{"location":"examples/plotting-dataframes/","title":"Plotting dataframes","text":"<p>DataFrames can be plotted in various ways with the <code>cal</code> attribute. </p> <p>Event level data with the <code>cal.plot_calendar</code> or <code>cal.plot_calendar_across_column</code></p> <p>``````</p>"},{"location":"examples/datasets/bikes-in-chicago/","title":"Bikes in Chicago","text":"<p>The Chicago dataset is bike trips in the city of Chicago.</p> <pre><code>import pandas as pd\nimport matplotlib.pyplot as plt\nfrom latent_calendar.datasets import load_chicago_bikes\nfrom latent_calendar.plot.elements import CalendarEvent\ndf = load_chicago_bikes()\ndf.head()\n</code></pre> <pre><code>                 start_station_name end_station_name  rideable_type          started_at            ended_at member_casual\nride_id\nABF4F851DE485B76                NaN              NaN  electric_bike 2023-06-30 18:56:13 2023-06-30 19:30:40        member\nF123B5D34B002CDB                NaN              NaN  electric_bike 2023-06-30 06:12:31 2023-06-30 06:23:05        member\nCA8E2C38AF641DFB                NaN              NaN  electric_bike 2023-06-30 08:28:51 2023-06-30 08:37:45        member\n93CCE4EA48CFDB69                NaN              NaN  electric_bike 2023-06-30 09:09:24 2023-06-30 09:17:41        member\nFDBCEFE7890F7262                NaN              NaN  electric_bike 2023-06-30 16:29:48 2023-06-30 16:38:51        member\n</code></pre> <p>This dataset is two weeks of data starting at the end of June 2023. We can easily see this by plotting it as a calendar grouped by the week of year. </p> <pre><code># Map the week number to a human readable label\ndf[\"week_number\"] = df[\"started_at\"].dt.isocalendar().week\n# Bit scary but just trying to make a nice label\ndef create_label(df: pd.DataFrame) -&gt; pd.Series:\nfirst_date = df[\"first_date\"]\nlast_date = df[\"last_date\"]\nreturn first_date.dt.date.astype(str).str.cat(\nlast_date.dt.date.astype(str), sep=\" until \"\n)\nlabel = (\ndf.groupby(\"week_number\")\n.agg(first_date=(\"started_at\", \"min\"), last_date=(\"started_at\", \"max\"))\n.pipe(create_label)\n)\ndf[\"week_of_year\"] = df[\"week_number\"].map(label.to_dict())\ndf_wide = df.cal.aggregate_events(\"week_of_year\", \"started_at\")\n(\ndf_wide\n.cal.normalize(\"max\")\n.cal.plot_by_row()\n)\nfig = plt.gcf()\nfig.suptitle(\"Two week of bike rides in Chicago\")\nplt.show()\n</code></pre> <p>We are able to understand that the data is two weeks of data starting at the end of June 2023, but also see that there is heavy influence from the July 4 holiday weekend. People have off work and this is reflected in the data.</p> <p></p> <p>Though the holiday effect around the 4th, there seems to be a lower volume the Sunday before and after work the day after. Interestingly enough, there was a rain storm on the weekend and  another storm the Wednesday the 4th. We can mark this on the calendar for reference.</p> <pre><code>def create_plot_storms_func(first_storm: CalendarEvent, second_storm: CalendarEvent):\ndef plot_storms(first_week_ax: plt.Axes, second_week_ax: plt.Axes):\nalpha = 0.15\nfirst_storm.plot(ax=first_week_ax, facecolor=\"blue\", alpha=alpha, label=\"rain storm\")\nsecond_storm.plot(ax=second_week_ax, facecolor=\"blue\", alpha=alpha, label=\"rain storm\")\nfirst_week_ax.legend()\nsecond_week_ax.legend()\nreturn plot_storms\nfirst_storm = CalendarEvent(day=6, start=7, end=18)\nsecond_storm = CalendarEvent(day=2, start=17, end=22)\nplot_storms = create_plot_storms_func(first_storm, second_storm)\n(\ndf_wide\n.cal.normalize(\"max\")\n.cal.plot_by_row()\n)\nfig = plt.gcf()\nfig.suptitle(\"Two week of bike rides in Chicago\")\nplot_storms(fig.axes[0], fig.axes[1])\nplt.show()\n</code></pre> <p></p> <p>Let's break it down further by adding the <code>member_casual</code> column to the aggregation.</p> <pre><code>df_wide = df.cal.aggregate_events([\"member_casual\", \"week_of_year\"], \"started_at\")\ndef title_func(idx, row) -&gt; str:\ngroup, week = idx\nreturn f\"{group} - {week}\"\n(\ndf_wide\n.cal.normalize(\"max\")\n.cal.plot_by_row(max_cols=2, title_func=title_func)\n)\nfig = plt.gcf()\nfig.suptitle(\"Two week of bike rides in Chicago\")\naxes = fig.axes\nplot_storms(axes[0], axes[1])\nplot_storms(axes[2], axes[3])\nplt.show()\n</code></pre> <p>We can see that the holiday weekend has heavy volume from the casual riders showing on the Monday and Tuesday of the holiday weekend. Not only that, but the members that use the bikes heavily to commute shift their usage with this holiday too. </p> <p></p> <p>The effect of rain can be investigated by sum the trips that happen during the day time. We can do this by creating a segment for each day of the week between the hours of 7am and 6pm, the time of the Sunday storm. </p> <pre><code>from latent_calendar.vocab import DOWHour\nfrom latent_calendar.segments.hand_picked import create_series_for_range, stack_segments\nall_daytime_rain = stack_segments([\ncreate_series_for_range(\nstart=DOWHour(dow=dow, hour=7), end=DOWHour(dow=dow, hour=18)\n).rename(f\"all_daytime_{dow}\")\nfor dow in range(7)\n])\ndf_volume = df_wide.cal.sum_over_segments(all_daytime_rain)\n</code></pre> <p>These are the row totals between the hours of 7am and 6pm for each day of the week at the same index level as before.</p> <pre><code>                                           all_daytime_0  all_daytime_1  all_daytime_2  all_daytime_3  all_daytime_4  all_daytime_5  all_daytime_6\nmember_casual week_of_year\ncasual        2023-06-26 until 2023-07-02           3887           4086           4634           4012           6647           8213            481\n              2023-07-03 until 2023-07-09           8946          10868           4523           5616           6920           6802           9643\nmember        2023-06-26 until 2023-07-02           7949           8960           9043           7852           9242           7663            822\n              2023-07-03 until 2023-07-09           9105           8239           8511           9989           9873           7846           9573\n</code></pre> <p>Visualizing this data, we can see the heavy impact of the Sunday weather for casual riders and members alike but not enough to ruin the holiday weekend.</p> <pre><code>def replace_index(ser: pd.Series, index: pd.Index) -&gt; pd.Series: \nser.index = index \nreturn ser\nstart_date = df[\"started_at\"].min().date()\nend_date = df[\"started_at\"].max().date()\ndates = pd.date_range(start_date, end_date, freq=\"D\")\nax = (\ndf_volume\n.stack()\n.unstack(0)\n.pipe(replace_index, index=dates)\n.plot()\n)\nax.set(\nylabel=\"# trips\",\ntitle=\"Trips between 7am and 6pm\",\nylim=(0, None),\n)\nax.legend(title=\"customer type\")\nplt.show()\n</code></pre> <p></p>"},{"location":"examples/datasets/store-transactions/","title":"Store transactions","text":"<pre><code>import matplotlib.pyplot as plt\nfrom latent_calendar.datasets import load_online_transactions\ndf = load_online_transactions()\ndf.head()\n</code></pre> <pre><code>        StockCode                          Description  Quantity         InvoiceDate  Price  Customer ID         Country\nInvoice                                                                                                                 \n489434      85048  15CM CHRISTMAS GLASS BALL 20 LIGHTS        12 2009-12-01 07:45:00   6.95      13085.0  United Kingdom\n489434     79323P                   PINK CHERRY LIGHTS        12 2009-12-01 07:45:00   6.75      13085.0  United Kingdom\n489434     79323W                  WHITE CHERRY LIGHTS        12 2009-12-01 07:45:00   6.75      13085.0  United Kingdom\n489434      22041         RECORD FRAME 7\" SINGLE SIZE         48 2009-12-01 07:45:00   2.10      13085.0  United Kingdom\n489434      21232       STRAWBERRY CERAMIC TRINKET BOX        24 2009-12-01 07:45:00   1.25      13085.0  United Kingdom\n</code></pre> <p>By default, a new <code>cal</code> attribute will be added to DataFrames given access to module functionality.</p> <pre><code>df_wide = df.cal.aggregate_events(\"Country\", \"InvoiceDate\")\ndf_wide.head()\n</code></pre> <pre><code>vocab      00 00  00 01  00 02  00 03  00 04  00 05  00 06  00 07  00 08  ...  06 15  06 16  06 17  06 18  06 19  06 20  06 21  06 22  06 23\nCountry                                                                   ...                                                               \nAustralia      0      0      0      0      0      0      0      0      0  ...      0      0      0      0      0      0      0      0      0\nAustria        0      0      0      0      0      0      0      0      9  ...      0      0      0      0      0      0      0      0      0\nBahrain        0      0      0      0      0      0      0      0      0  ...      0      0      0      0      0      0      0      0      0\nBelgium        0      0      0      0      0      0      0      0     15  ...    131      0      0      0      0      0      0      0      0\nBermuda        0      0      0      0      0      0      0      0      0  ...      0      0      0      0      0      0      0      0      0\n\n[5 rows x 168 columns]\n</code></pre> <p>We can clearly see the weekly hours of operation for these countries. Even though these are online transactions, these hours affect the transaction times.</p> <p>The slight shift in hours for the UK might be the difference in time zones between the UK and the other countries. Maybe it could be difference in buying patterns of these populations. Not sure but this visual gives us a good glance at the data and starting point to ask questions</p> <pre><code>countries = [\"United Kingdom\", \"Germany\", \"France\"]\n(\ndf_wide\n.loc[countries]\n.cal.normalize(\"max\")\n.cal.plot_by_row()\n)\nfig = plt.gcf()\nfig.suptitle(\"Store Transactions by Country\")\nplt.show()\n</code></pre> <p></p>"},{"location":"examples/datasets/ufo-sightings/","title":"UFO Sightings","text":"<pre><code>import matplotlib.pyplot as plt\nfrom latent_calendar.datasets import load_ufo_sightings\ndf = load_ufo_sightings()\n</code></pre> <p>Each row of the dataset is a UFO sighting somewhere around the world.</p> <pre><code>            Date_time                  city state/province country  ...                                        description date_documented    latitude   longitude\n0 1949-10-10 20:30:00            san marcos             tx      us  ...  This event took place in early fall around 194...       4/27/2004  29.8830556  -97.941111\n1 1949-10-10 21:00:00          lackland afb             tx     NaN  ...  1949 Lackland AFB&amp;#44 TX.  Lights racing acros...      12/16/2005    29.38421  -98.581082\n2 1955-10-10 17:00:00  chester (uk/england)            NaN      gb  ...  Green/Orange circular disc over Chester&amp;#44 En...       1/21/2008        53.2   -2.916667\n3 1956-10-10 21:00:00                  edna             tx      us  ...  My older brother and twin sister were leaving ...       1/17/2004  28.9783333  -96.645833\n4 1960-10-10 20:00:00               kaneohe             hi      us  ...  AS a Marine 1st Lt. flying an FJ4B fighter/att...       1/22/2004  21.4180556 -157.803611\n\n[5 rows x 11 columns]\n</code></pre> <pre><code>df[\"year\"] = df[\"Date_time\"].dt.year\ndf_wide = df.cal.aggregate_events(\"year\", \"Date_time\")\ndf_5_year = df_wide.tail(5)\n</code></pre> <p>which has the data in the wide format where each row is a weekly calendar. </p> <pre><code>vocab  00 00  00 01  00 02  00 03  00 04  00 05  00 06  00 07  00 08  00 09  00 10  00 11  ...  06 12  06 13  06 14  06 15  06 16  06 17  06 18  06 19  06 20  06 21  06 22  06 23\nyear                                                                                       ...\n2010      18     25     15     10     13     16      8      6      2      5      7     11  ...     14     10      6     14     22     13     29     37     50     86     84     64\n2011      38     27     18     20     14     13      9      6      9      7     11      8  ...     10     11      9     12     13     19     33     56     93     92     97     82\n2012      46     29     20     16     19     17     14     18     12     13     16     16  ...     13      7     17     20     15     18     43     74    142    186    147    103\n2013      38     33     15     11      9     14     13     11     11      3     10      8  ...      8      6      6      6     16     24     58     83    131    231    194    109\n2014      12      9      7      8      6      5      6      4      6      3      2      6  ...      6      0      6      6      5      7     17     28     52     57     39     31\n\n[5 rows x 168 columns]\n</code></pre> <p>We can make use the <code>cal</code> attribute further to plot an aggregate of the data and plots of the data by day of week and hour of day.</p> <pre><code>fig, axes = plt.subplots(ncols=3)\ndf_5_year.sum().cal.plot_row(ax=axes[0])\naxes[0].set(\ntitle=\"Weekly UFO sightings\",\n)\nfor aggregation, ax in zip([\"dow\", \"hour\"], axes.ravel()[1:]): \n(\ndf_5_year\n.cal.sum_over_vocab(aggregation=aggregation)\n.cal.normalize(\"probs\")\n.mul(100)\n.T.plot(ax=ax)\n)\nymax = ax.get_ylim()[1]\nax.set_ylim(0, ymax * 1.1)\naxes[1].set_xticks(axes[0].get_xticks())\naxes[1].set(\ntitle=\"Chance of UFO sighting by day of week\",\nxlabel=\"Day of week\",\nylabel=\"Chance of UFO sighting (%)\",\n)\naxes[2].set(\ntitle=\"Chance of UFO sighting by hour of day\",\nxlabel=\"Hour of day\",\nylabel=\"\", \n)\nfig.suptitle(\"UFO sightings over 5 years\")\nplt.show()\n</code></pre> <p></p>"},{"location":"examples/plotting/add-calendar-events/","title":"Add calendar events","text":"<p>Can use the <code>CalendarEvent</code> class to add arbitrary events to calendar. </p> <p>The constructor takes a day of week, start time, and an end time or duration.</p> <pre><code>import matplotlib.pyplot as plt\nfrom latent_calendar.plot import plot_blank_calendar\nfrom latent_calendar.plot.elements import CalendarEvent\nax = plot_blank_calendar()\nevent = CalendarEvent(\nday=0, start=12, duration=15\n)\nevent.plot(ax=ax, label=\"15 minute event\", linestyle=\"--\", alpha=0.25)\nevent = CalendarEvent(\nday=0, start=23.5, end=24.5, \n)\nevent.plot(ax=ax, label=\"Two day event\", facecolor=\"red\", linestyle=\"dashed\", lw=1.5)\nevent = CalendarEvent(\nday=5, start=11, end=17, \n)\nevent.plot(ax=ax, label=\"Friday event\", facecolor=\"green\", alpha=0.25)\nax.legend()\nplt.show()\n</code></pre> <p></p>"},{"location":"examples/plotting/calendar-customization/","title":"Calendar customization","text":"<p>Each calendar plot is made up of the following components:</p> <ul> <li>X axis (Day of week)</li> <li>Y axis (Time of the day)</li> <li>Grid Lines</li> <li>Events (Rectangles)</li> </ul> <p>The X axis and Y axis have default values but can be customized </p> <pre><code>import matplotlib.pyplot as plt\nfrom latent_calendar.plot import plot_blank_calendar\nfrom latent_calendar.plot.elements import DayLabeler, TimeLabeler, GridLines\nfig, axes = plt.subplots(ncols=2, nrows=2)\nfig.suptitle(\"Calendar Customization\")\nax = axes[0, 0]\nplot_blank_calendar(ax=ax)\nax.set_title(\"Default\")\nax = axes[0, 1]\nplot_blank_calendar(\nax=ax, monday_start=False\n)\nax.set_title(\"Monday Start\")\nax = axes[1, 0]\nday_labeler = DayLabeler(days_of_week=[\"M\", \"T\", \"W\", \"Th\", \"F\", \"Sa\", \"Su\"], rotation=0)\nhour_formatter = lambda hour: f\"{hour}h\"\ntime_labeler = TimeLabeler(hour_formatter=hour_formatter, stride=4)\nplot_blank_calendar(\nax=ax, \nday_labeler=day_labeler, \ntime_labeler=time_labeler, \n)\nax.set_title(\"Custom Labels\")\nax = axes[1, 1]\ngrid_lines = GridLines(dow=True, hour=True)\nplot_blank_calendar(\nax=ax, grid_lines=grid_lines\n)\nax.set_title(\"Adding Grid Lines\")\nplt.show()\n</code></pre> <p></p> <p>Additionally, the labels can be turned off completely. This is done automatically with functions that plot multiple calendars.</p> <pre><code>fig, axes = plt.subplots(ncols=2, nrows=1)\nax = axes[0]\nday_labeler = DayLabeler(days_of_week=[\"M\", \"T\", \"W\", \"Th\", \"F\", \"Sa\", \"Su\"], rotation=0, display=False)\nplot_blank_calendar(\nday_labeler=day_labeler, \nax=axes[0]\n)\nax.set(title=\"No Day Labels\")\nax = axes[1]\nhour_formatter = lambda hour: f\"{hour}h\"\ntime_labeler = TimeLabeler(hour_formatter=hour_formatter, stride=4, display=False)\nplot_blank_calendar(\ntime_labeler=time_labeler,\nax=ax\n)\nax.set(title=\"No Time Labels\")\nplt.show()\n</code></pre> <p></p> <p>This customization is available through the other plotting functions and methods as well. Access them with through the same parameter names.</p> <pre><code>from latent_calendar.segments.hand_picked import create_box_segment, stack_segments\nmornings = create_box_segment(\nhour_start=6,\nhour_end=11,\nday_start=0, day_end=7, \nname=\"mornings\"\n)\nevenings = create_box_segment(\nhour_start=18,\nhour_end=21,\nday_start=0, day_end=7,\nname=\"evenings\"\n)\nweekend_daytimes = create_box_segment(\nhour_start=11, \nhour_end=18,\nday_start=5, day_end=7,\nname=\"weekend daytimes\"\n)\ndf_segments = stack_segments([mornings, evenings, weekend_daytimes])\n# Plotting\n(\ndf_segments\n.cal.plot_by_row(\nday_labeler=day_labeler, \ntime_labeler=time_labeler\n)\n)\nplt.show()\n</code></pre> <p></p>"},{"location":"examples/plotting/event-frequency/","title":"Event frequency","text":"<p>All number of time slots divisible by 7 (days of the week) are supported for plotting. This is thanks to the <code>plot_calendar</code> function taking an iterable. </p> <pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nfrom latent_calendar.plot import plot_calendar\nfrom latent_calendar.plot.iterate import iterate_matrix\nfrom latent_calendar.plot.colors import create_default_cmap\ntime_slots = [12, 24, 48]\nfig, axes = plt.subplots(ncols=len(time_slots))\nrng = np.random.default_rng(0)\nfor ts, ax in zip(time_slots, axes.ravel()): \ndata = rng.poisson(lam=1, size=(7, ts))\ncmap = create_default_cmap(data.max())\nplot_calendar(\niterate_matrix(data),\ncmap=cmap, \nax=ax, \n)\nax.set_title(f\"{ts} Time Slots\")\nfig.suptitle(\"Calendar Plot with Different # Time Slots\")\nplt.show()\n</code></pre> <p></p>"},{"location":"modules/const/","title":"Const","text":""},{"location":"modules/datasets/","title":"Datasets","text":"<p>Example datasets for latent_calendar. </p> <p>All datasets are loaded from the web and cached locally if desired with the <code>local_save</code> argument.</p> <p>The datasets all include one or more columns that represent a datetime that can be used for calendar analysis.</p> <p>Examples:</p> <p>Load the chicago bikes dataset:</p> <pre><code>from latent_calendar.datasets import load_chicago_bikes\ndf = load_chicago_bikes()\ndf.head()\n</code></pre> <pre><code>                start_station_name end_station_name  rideable_type          started_at            ended_at member_casual\nride_id\nABF4F851DE485B76                NaN              NaN  electric_bike 2023-06-30 18:56:13 2023-06-30 19:30:40        member\nF123B5D34B002CDB                NaN              NaN  electric_bike 2023-06-30 06:12:31 2023-06-30 06:23:05        member\nCA8E2C38AF641DFB                NaN              NaN  electric_bike 2023-06-30 08:28:51 2023-06-30 08:37:45        member\n93CCE4EA48CFDB69                NaN              NaN  electric_bike 2023-06-30 09:09:24 2023-06-30 09:17:41        member\nFDBCEFE7890F7262                NaN              NaN  electric_bike 2023-06-30 16:29:48 2023-06-30 16:38:51        member\n</code></pre>"},{"location":"modules/datasets/#latent_calendar.datasets.load_chicago_bikes","title":"<code>load_chicago_bikes(local_save=False)</code>","text":"<p>Bikesharing trip level data from Chicago's Divvy system.</p> <p>Read more about the data source here.</p> <p>The data is two weeks of trips starting June 26th, 2023 until July 9th, 2023.</p> <p>Parameters:</p> Name Type Description Default <code>local_save</code> <code>bool</code> <p>Whether to save the data locally if it doesn't exists.</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Trips data from Chicago's Divvy system.</p> Source code in <code>latent_calendar/datasets/__init__.py</code> <pre><code>def load_chicago_bikes(local_save: bool = False) -&gt; pd.DataFrame:\n\"\"\"Bikesharing trip level data from Chicago's Divvy system.\n    Read more about the data source [here](https://data.cityofchicago.org/Transportation/Divvy-Trips/fg6s-gzvg).\n    The data is two weeks of trips starting June 26th, 2023 until July 9th, 2023.\n    Args:\n        local_save: Whether to save the data locally if it doesn't exists.\n    Returns:\n        Trips data from Chicago's Divvy system.\n    \"\"\"\nname = \"chicago-bikes\"\nread_kwargs = {\n\"parse_dates\": [\"started_at\", \"ended_at\"],\n\"index_col\": [\"ride_id\"],\n}\nreturn _load_data(name, read_kwargs=read_kwargs, local_save=local_save)\n</code></pre>"},{"location":"modules/datasets/#latent_calendar.datasets.load_online_transactions","title":"<code>load_online_transactions(local_save=False)</code>","text":"<p>Kaggle Data for an non-store online retailer in UK. More information here.</p> <p>Parameters:</p> Name Type Description Default <code>local_save</code> <code>bool</code> <p>Whether to save the data locally if it doesn't exists.</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Online transactions data from a non-store online retailer in UK.</p> Source code in <code>latent_calendar/datasets/__init__.py</code> <pre><code>def load_online_transactions(local_save: bool = False) -&gt; pd.DataFrame:\n\"\"\"Kaggle Data for an non-store online retailer in UK. More information [here](https://www.kaggle.com/datasets/mashlyn/online-retail-ii-uci).\n    Args:\n        local_save: Whether to save the data locally if it doesn't exists.\n    Returns:\n        Online transactions data from a non-store online retailer in UK.\n    \"\"\"\nname = \"online_retail_II\"\nread_kwargs = {\n\"parse_dates\": [\"InvoiceDate\"],\n\"index_col\": [\"Invoice\"],\n}\nreturn _load_data(name, read_kwargs=read_kwargs, local_save=local_save)\n</code></pre>"},{"location":"modules/datasets/#latent_calendar.datasets.load_ufo_sightings","title":"<code>load_ufo_sightings(local_save=False)</code>","text":"<p>UFO sightings over time around the world. More info here.</p> <p>Parameters:</p> Name Type Description Default <code>local_save</code> <code>bool</code> <p>Whether to save the data locally if it doesn't exists.</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Sighting level data for UFOs.</p> Source code in <code>latent_calendar/datasets/__init__.py</code> <pre><code>def load_ufo_sightings(local_save: bool = False) -&gt; pd.DataFrame:\n\"\"\"UFO sightings over time around the world. More info [here](https://www.kaggle.com/datasets/camnugent/ufo-sightings-around-the-world).\n    Args:\n        local_save: Whether to save the data locally if it doesn't exists.\n    Returns:\n        Sighting level data for UFOs.\n    \"\"\"\nname = \"ufo_sighting_data\"\nread_kwargs = {\"low_memory\": False}\nsave_kwargs = {\"index\": False}\ndf = _load_data(\nname, read_kwargs=read_kwargs, save_kwargs=save_kwargs, local_save=local_save\n)\ndf[\"Date_time\"] = pd.to_datetime(\ndf[\"Date_time\"]\n.str.replace(\" 24:00\", \" 23:59\")\n.pipe(pd.to_datetime, format=\"mixed\", dayfirst=True)\n)\nreturn df\n</code></pre>"},{"location":"modules/extensions/","title":"Extensions","text":"<p>Pandas extensions for <code>latent-calendar</code> and primary interface for the package.</p> <p>Provides a <code>cal</code> accessor to <code>DataFrame</code> and <code>Series</code> instances for easy transformation and plotting after import of <code>latent_calendar</code>.</p> <p>Functionality includes: </p> <ul> <li>aggregation of events to wide format</li> <li>convolutions of wide formats</li> <li>making transformations and predictions with models</li> <li>plotting of events, predictions, and comparisons as calendars</li> </ul> <p>Each <code>DataFrame</code> will be either at event level or an aggregated wide format. </p> <p>Methods that end in <code>row</code> or <code>by_row</code> will be for wide format DataFrames and will plot each row as a calendar. </p> <p>Examples:</p> <p>Plotting an event level Series as a calendar </p> <pre><code>import pandas as pd\nimport latent_calendar\ndates = pd.date_range(\"2023-01-01\", \"2023-01-14\", freq=\"H\")\nser = (\npd.Series(dates)\n.sample(10, random_state=42)\n)\nser.cal.plot()\n</code></pre> <p></p> <p>Transform event level DataFrame to wide format and plot</p> <pre><code>from latent_calendar.datasets import load_online_transactions\ndf = load_online_transactions()\n# (n_customer, n_timeslots)\ndf_wide = (\ndf\n.cal.aggregate_events(\"Customer ID\", timestamp_col=\"InvoiceDate\")\n)\n(\ndf_wide\n.sample(n=12, random_state=42)\n.cal.plot_by_row(max_cols=4)\n)\n</code></pre> <p></p> <p>Train a model and plot predictions </p> <pre><code>from latent_calendar import LatentCalendar\nmodel = LatentCalendar(n_components=5, random_state=42)\nmodel.fit(df_wide.to_numpy())\n(\ndf_wide\n.head(2)\n.cal.plot_profile_by_row(model=model)\n)\n</code></pre> <p></p>"},{"location":"modules/extensions/#latent_calendar.extensions.DataFrameAccessor","title":"<code>DataFrameAccessor</code>","text":"<p>DataFrame accessor for latent_calendar accessed through <code>cal</code> attribute of DataFrames.</p> Source code in <code>latent_calendar/extensions.py</code> <pre><code>@pd.api.extensions.register_dataframe_accessor(\"cal\")\nclass DataFrameAccessor:\n\"\"\"DataFrame accessor for latent_calendar accessed through `cal` attribute of DataFrames.\"\"\"\ndef __init__(self, pandas_obj: pd.DataFrame):\nself._obj = pandas_obj\ndef normalize(self, kind: str) -&gt; pd.DataFrame:\n\"\"\"Row-wise operations on DataFrame.\n        Args:\n            kind: one of ['max', 'probs', 'even_rate']\n        Returns:\n            DataFrame with row-wise operations applied\n        \"\"\"\nif kind == \"max\":\nreturn self._obj.div(self._obj.max(axis=1), axis=0)\nelif kind == \"probs\":\nreturn self._obj.div(self._obj.sum(axis=1), axis=0)\nelif kind == \"even_rate\":\nvalue = self._obj.shape[1]\nreturn self._obj.div(value)\nraise ValueError(f\"kind must be one of ['max', 'probs'], got {kind}\")\ndef aggregate_events(\nself,\nby: Union[str, List[str]],\ntimestamp_col: str,\n) -&gt; pd.DataFrame:\n\"\"\"Transform DataFrame to wide format with groups as index.\n        Wrapper around `create_raw_to_vocab_transformer` to transform to wide format.\n        Args:\n            by: column(s) to use as index\n            timestamp_col: column to use as timestamp\n        Returns:\n            DataFrame in wide format\n        \"\"\"\nif not isinstance(by, list):\nid_col = by\nadditional_groups = None\nelse:\nid_col, *additional_groups = by\ntransformer = create_raw_to_vocab_transformer(\nid_col=id_col,\ntimestamp_col=timestamp_col,\nadditional_groups=additional_groups,\n)\nreturn transformer.fit_transform(self._obj)\ndef sum_over_vocab(self, aggregation: str = \"dow\") -&gt; pd.DataFrame:\n\"\"\"Sum the wide format to day of week or hour of day.\n        Args:\n            aggregation: one of ['dow', 'hour']\n        Returns:\n            DataFrame with summed values\n        Examples:\n            Sum to day of week\n            ```python\n            df_dow = df_wide.cal.sum_over_vocab(aggregation='dow')\n            ```\n        \"\"\"\nreturn sum_over_vocab(self._obj, aggregation=aggregation)\ndef sum_next_hours(self, hours: int) -&gt; pd.DataFrame:\n\"\"\"Sum the wide format over next hours.\n        Args:\n            hours: number of hours to sum over\n        Returns:\n            DataFrame with summed values\n        \"\"\"\nreturn sum_next_hours(self._obj, hours=hours)\ndef sum_over_segments(self, df_segments: pd.DataFrame) -&gt; pd.DataFrame:\n\"\"\"Sum the wide format over user defined segments.\n        Args:\n            df_segments: DataFrame in wide format with segments as index\n        Returns:\n            DataFrame with columns as the segments and summed values\n        \"\"\"\nreturn sum_over_segments(self._obj, df_segments=df_segments)\ndef transform(self, *, model) -&gt; pd.DataFrame:\n\"\"\"Transform DataFrame with model.\n        Applies the dimensionality reduction to each row of the DataFrame.\n        Args:\n            model: model to use for transformation\n        Returns:\n            DataFrame with transformed values\n        \"\"\"\nreturn transform_on_dataframe(self._obj, model=model)\ndef predict(self, *, model) -&gt; pd.DataFrame:\n\"\"\"Predict DataFrame with model.\n        Args:\n            model: model to use for prediction\n        Returns:\n            DataFrame with predicted values (wide format)\n        \"\"\"\nreturn predict_on_dataframe(self._obj, model=model)\ndef plot(\nself,\nstart_col: str,\n*,\nend_col: Optional[str] = None,\nduration: Optional[int] = None,\nalpha: float = None,\ncmap=None,\nday_labeler: DayLabeler = DayLabeler(),\ntime_labeler: TimeLabeler = TimeLabeler(),\ngrid_lines: GridLines = GridLines(),\nmonday_start: bool = True,\nax: Optional[plt.Axes] = None,\n) -&gt; plt.Axes:\n\"\"\"Plot DataFrame of timestamps as a calendar.\n        Args:\n            start_col: column with start timestamp\n            end_col: column with end timestamp\n            minutes: length of event in minutes. Alternative to end_col\n            alpha: alpha value for the color\n            cmap: function that maps floats to string colors\n            monday_start: whether to start the week on Monday or Sunday\n            ax: optional matplotlib axis to plot on\n        Returns:\n            Modified matplotlib axis\n        \"\"\"\nconfig = StartEndConfig(start=start_col, end=end_col, minutes=duration)\nreturn plot_dataframe_as_calendar(\nself._obj,\nconfig=config,\nalpha=alpha,\ncmap=cmap,\nday_labeler=day_labeler,\ntime_labeler=time_labeler,\ngrid_lines=grid_lines,\nmonday_start=monday_start,\nax=ax,\n)\ndef plot_across_column(\nself,\nstart_col: str,\ngrid_col: str,\n*,\nend_col: Optional[str] = None,\nduration: Optional[int] = None,\nday_labeler: DayLabeler = DayLabeler(),\ntime_labeler: TimeLabeler = TimeLabeler(),\ngrid_lines: GridLines = GridLines(),\nmax_cols: int = 3,\nalpha: float = None,\n) -&gt; None:\n\"\"\"Plot DataFrame of timestamps as a calendar as grid across column values.\n        NA values are excluded\n        Args:\n            start_col: column with start timestamp\n            grid_col: column of values to use as grid\n            end_col: column with end timestamp\n            length: length of event in minutes. Alternative to end_col\n            max_cols: max number of columns per row\n            alpha: alpha value for the color\n        Returns:\n            None\n        \"\"\"\nconfig = StartEndConfig(start=start_col, end=end_col, minutes=duration)\nplot_dataframe_grid_across_column(\nself._obj, grid_col=grid_col, config=config, max_cols=max_cols, alpha=alpha, \nday_labeler=day_labeler,\ntime_labeler=time_labeler,\ngrid_lines=grid_lines,\n)\ndef plot_by_row(\nself,\n*,\nmax_cols: int = 3,\ntitle_func: Optional[TITLE_FUNC] = None,\ncmaps: Optional[Union[CMAP, ColorMap, CMAP_GENERATOR]] = None,\nday_labeler: DayLabeler = DayLabeler(),\ntime_labeler: TimeLabeler = TimeLabeler(),\ngrid_lines: GridLines = GridLines(),\nmonday_start: bool = True,\n) -&gt; None:\n\"\"\"Plot each row of the DataFrame as a calendar plot. Data must have been transformed to wide format first.\n        Wrapper around `latent_calendar.plot.plot_calendar_by_row`.\n        Args:\n            max_cols: max number of columns per row of grid\n            title_func: function to generate title for each row\n            day_labeler: function to generate day labels\n            time_labeler: function to generate time labels\n            cmaps: optional generator of colormaps\n            grid_lines: optional grid lines\n            monday_start: whether to start the week on Monday or Sunday\n        Returns:\n            None\n        \"\"\"\nreturn plot_calendar_by_row(\nself._obj,\nmax_cols=max_cols,\ntitle_func=title_func,\nday_labeler=day_labeler,\ntime_labeler=time_labeler,\ncmaps=cmaps,\ngrid_lines=grid_lines,\nmonday_start=monday_start,\n)\ndef plot_profile_by_row(\nself,\n*,\nmodel: LatentCalendar,\nindex_func=lambda idx: idx,\ninclude_components: bool = True,\n) -&gt; np.ndarray:\n\"\"\"Plot each row of the DataFrame as a profile plot. Data must have been transformed to wide format first.\n        Args:\n            model: model to use for prediction and transform\n            index_func: function to generate title for each row\n            include_components: whether to include components in the plot\n        Returns:\n            grid of axes\n        \"\"\"\nreturn plot_profile_by_row(\nself._obj,\nmodel=model,\nindex_func=index_func,\ninclude_components=include_components,\n)\ndef plot_raw_and_predicted_by_row(\nself, *, model: LatentCalendar, index_func=lambda idx: idx\n) -&gt; np.ndarray:\n\"\"\"Plot raw and predicted values for a model. Data must have been transformed to wide format first.\n        Args:\n            model: model to use for prediction\n            index_func: function to generate title for each row\n        Returns:\n            grid of axes\n        \"\"\"\nreturn plot_profile_by_row(\nself._obj, model=model, index_func=index_func, include_components=False\n)\ndef plot_model_predictions_by_row(\nself,\ndf_holdout: pd.DataFrame,\n*,\nmodel: LatentCalendar,\nindex_func=lambda idx: idx,\ndivergent: bool = True,\n) -&gt; np.ndarray:\n\"\"\"Plot model predictions for each row of the DataFrame. Data must have been transformed to wide format first.\n        Args:\n            df_holdout: holdout DataFrame for comparison\n            model: model to use for prediction\n            index_func: function to generate title for each row\n            divergent: whether to use divergent colormap\n        Returns:\n            grid of axes\n        \"\"\"\nreturn plot_model_predictions_by_row(\nself._obj,\ndf_holdout=df_holdout,\nmodel=model,\nindex_func=index_func,\ndivergent=divergent,\n)\n</code></pre>"},{"location":"modules/extensions/#latent_calendar.extensions.DataFrameAccessor.aggregate_events","title":"<code>aggregate_events(by, timestamp_col)</code>","text":"<p>Transform DataFrame to wide format with groups as index.</p> <p>Wrapper around <code>create_raw_to_vocab_transformer</code> to transform to wide format.</p> <p>Parameters:</p> Name Type Description Default <code>by</code> <code>Union[str, List[str]]</code> <p>column(s) to use as index</p> required <code>timestamp_col</code> <code>str</code> <p>column to use as timestamp</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame in wide format</p> Source code in <code>latent_calendar/extensions.py</code> <pre><code>def aggregate_events(\nself,\nby: Union[str, List[str]],\ntimestamp_col: str,\n) -&gt; pd.DataFrame:\n\"\"\"Transform DataFrame to wide format with groups as index.\n    Wrapper around `create_raw_to_vocab_transformer` to transform to wide format.\n    Args:\n        by: column(s) to use as index\n        timestamp_col: column to use as timestamp\n    Returns:\n        DataFrame in wide format\n    \"\"\"\nif not isinstance(by, list):\nid_col = by\nadditional_groups = None\nelse:\nid_col, *additional_groups = by\ntransformer = create_raw_to_vocab_transformer(\nid_col=id_col,\ntimestamp_col=timestamp_col,\nadditional_groups=additional_groups,\n)\nreturn transformer.fit_transform(self._obj)\n</code></pre>"},{"location":"modules/extensions/#latent_calendar.extensions.DataFrameAccessor.normalize","title":"<code>normalize(kind)</code>","text":"<p>Row-wise operations on DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>kind</code> <code>str</code> <p>one of ['max', 'probs', 'even_rate']</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with row-wise operations applied</p> Source code in <code>latent_calendar/extensions.py</code> <pre><code>def normalize(self, kind: str) -&gt; pd.DataFrame:\n\"\"\"Row-wise operations on DataFrame.\n    Args:\n        kind: one of ['max', 'probs', 'even_rate']\n    Returns:\n        DataFrame with row-wise operations applied\n    \"\"\"\nif kind == \"max\":\nreturn self._obj.div(self._obj.max(axis=1), axis=0)\nelif kind == \"probs\":\nreturn self._obj.div(self._obj.sum(axis=1), axis=0)\nelif kind == \"even_rate\":\nvalue = self._obj.shape[1]\nreturn self._obj.div(value)\nraise ValueError(f\"kind must be one of ['max', 'probs'], got {kind}\")\n</code></pre>"},{"location":"modules/extensions/#latent_calendar.extensions.DataFrameAccessor.plot","title":"<code>plot(start_col, *, end_col=None, duration=None, alpha=None, cmap=None, day_labeler=DayLabeler(), time_labeler=TimeLabeler(), grid_lines=GridLines(), monday_start=True, ax=None)</code>","text":"<p>Plot DataFrame of timestamps as a calendar.</p> <p>Parameters:</p> Name Type Description Default <code>start_col</code> <code>str</code> <p>column with start timestamp</p> required <code>end_col</code> <code>Optional[str]</code> <p>column with end timestamp</p> <code>None</code> <code>minutes</code> <p>length of event in minutes. Alternative to end_col</p> required <code>alpha</code> <code>float</code> <p>alpha value for the color</p> <code>None</code> <code>cmap</code> <p>function that maps floats to string colors</p> <code>None</code> <code>monday_start</code> <code>bool</code> <p>whether to start the week on Monday or Sunday</p> <code>True</code> <code>ax</code> <code>Optional[matplotlib.Axes]</code> <p>optional matplotlib axis to plot on</p> <code>None</code> <p>Returns:</p> Type Description <code>Axes</code> <p>Modified matplotlib axis</p> Source code in <code>latent_calendar/extensions.py</code> <pre><code>def plot(\nself,\nstart_col: str,\n*,\nend_col: Optional[str] = None,\nduration: Optional[int] = None,\nalpha: float = None,\ncmap=None,\nday_labeler: DayLabeler = DayLabeler(),\ntime_labeler: TimeLabeler = TimeLabeler(),\ngrid_lines: GridLines = GridLines(),\nmonday_start: bool = True,\nax: Optional[plt.Axes] = None,\n) -&gt; plt.Axes:\n\"\"\"Plot DataFrame of timestamps as a calendar.\n    Args:\n        start_col: column with start timestamp\n        end_col: column with end timestamp\n        minutes: length of event in minutes. Alternative to end_col\n        alpha: alpha value for the color\n        cmap: function that maps floats to string colors\n        monday_start: whether to start the week on Monday or Sunday\n        ax: optional matplotlib axis to plot on\n    Returns:\n        Modified matplotlib axis\n    \"\"\"\nconfig = StartEndConfig(start=start_col, end=end_col, minutes=duration)\nreturn plot_dataframe_as_calendar(\nself._obj,\nconfig=config,\nalpha=alpha,\ncmap=cmap,\nday_labeler=day_labeler,\ntime_labeler=time_labeler,\ngrid_lines=grid_lines,\nmonday_start=monday_start,\nax=ax,\n)\n</code></pre>"},{"location":"modules/extensions/#latent_calendar.extensions.DataFrameAccessor.plot_across_column","title":"<code>plot_across_column(start_col, grid_col, *, end_col=None, duration=None, day_labeler=DayLabeler(), time_labeler=TimeLabeler(), grid_lines=GridLines(), max_cols=3, alpha=None)</code>","text":"<p>Plot DataFrame of timestamps as a calendar as grid across column values.</p> <p>NA values are excluded</p> <p>Parameters:</p> Name Type Description Default <code>start_col</code> <code>str</code> <p>column with start timestamp</p> required <code>grid_col</code> <code>str</code> <p>column of values to use as grid</p> required <code>end_col</code> <code>Optional[str]</code> <p>column with end timestamp</p> <code>None</code> <code>length</code> <p>length of event in minutes. Alternative to end_col</p> required <code>max_cols</code> <code>int</code> <p>max number of columns per row</p> <code>3</code> <code>alpha</code> <code>float</code> <p>alpha value for the color</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>latent_calendar/extensions.py</code> <pre><code>def plot_across_column(\nself,\nstart_col: str,\ngrid_col: str,\n*,\nend_col: Optional[str] = None,\nduration: Optional[int] = None,\nday_labeler: DayLabeler = DayLabeler(),\ntime_labeler: TimeLabeler = TimeLabeler(),\ngrid_lines: GridLines = GridLines(),\nmax_cols: int = 3,\nalpha: float = None,\n) -&gt; None:\n\"\"\"Plot DataFrame of timestamps as a calendar as grid across column values.\n    NA values are excluded\n    Args:\n        start_col: column with start timestamp\n        grid_col: column of values to use as grid\n        end_col: column with end timestamp\n        length: length of event in minutes. Alternative to end_col\n        max_cols: max number of columns per row\n        alpha: alpha value for the color\n    Returns:\n        None\n    \"\"\"\nconfig = StartEndConfig(start=start_col, end=end_col, minutes=duration)\nplot_dataframe_grid_across_column(\nself._obj, grid_col=grid_col, config=config, max_cols=max_cols, alpha=alpha, \nday_labeler=day_labeler,\ntime_labeler=time_labeler,\ngrid_lines=grid_lines,\n)\n</code></pre>"},{"location":"modules/extensions/#latent_calendar.extensions.DataFrameAccessor.plot_by_row","title":"<code>plot_by_row(*, max_cols=3, title_func=None, cmaps=None, day_labeler=DayLabeler(), time_labeler=TimeLabeler(), grid_lines=GridLines(), monday_start=True)</code>","text":"<p>Plot each row of the DataFrame as a calendar plot. Data must have been transformed to wide format first.</p> <p>Wrapper around <code>latent_calendar.plot.plot_calendar_by_row</code>.</p> <p>Parameters:</p> Name Type Description Default <code>max_cols</code> <code>int</code> <p>max number of columns per row of grid</p> <code>3</code> <code>title_func</code> <code>Optional[TITLE_FUNC]</code> <p>function to generate title for each row</p> <code>None</code> <code>day_labeler</code> <code>DayLabeler</code> <p>function to generate day labels</p> <code>DayLabeler()</code> <code>time_labeler</code> <code>TimeLabeler</code> <p>function to generate time labels</p> <code>TimeLabeler()</code> <code>cmaps</code> <code>Optional[Union[CMAP, ColorMap, CMAP_GENERATOR]]</code> <p>optional generator of colormaps</p> <code>None</code> <code>grid_lines</code> <code>GridLines</code> <p>optional grid lines</p> <code>GridLines()</code> <code>monday_start</code> <code>bool</code> <p>whether to start the week on Monday or Sunday</p> <code>True</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>latent_calendar/extensions.py</code> <pre><code>def plot_by_row(\nself,\n*,\nmax_cols: int = 3,\ntitle_func: Optional[TITLE_FUNC] = None,\ncmaps: Optional[Union[CMAP, ColorMap, CMAP_GENERATOR]] = None,\nday_labeler: DayLabeler = DayLabeler(),\ntime_labeler: TimeLabeler = TimeLabeler(),\ngrid_lines: GridLines = GridLines(),\nmonday_start: bool = True,\n) -&gt; None:\n\"\"\"Plot each row of the DataFrame as a calendar plot. Data must have been transformed to wide format first.\n    Wrapper around `latent_calendar.plot.plot_calendar_by_row`.\n    Args:\n        max_cols: max number of columns per row of grid\n        title_func: function to generate title for each row\n        day_labeler: function to generate day labels\n        time_labeler: function to generate time labels\n        cmaps: optional generator of colormaps\n        grid_lines: optional grid lines\n        monday_start: whether to start the week on Monday or Sunday\n    Returns:\n        None\n    \"\"\"\nreturn plot_calendar_by_row(\nself._obj,\nmax_cols=max_cols,\ntitle_func=title_func,\nday_labeler=day_labeler,\ntime_labeler=time_labeler,\ncmaps=cmaps,\ngrid_lines=grid_lines,\nmonday_start=monday_start,\n)\n</code></pre>"},{"location":"modules/extensions/#latent_calendar.extensions.DataFrameAccessor.plot_model_predictions_by_row","title":"<code>plot_model_predictions_by_row(df_holdout, *, model, index_func=lambda : idx, divergent=True)</code>","text":"<p>Plot model predictions for each row of the DataFrame. Data must have been transformed to wide format first.</p> <p>Parameters:</p> Name Type Description Default <code>df_holdout</code> <code>DataFrame</code> <p>holdout DataFrame for comparison</p> required <code>model</code> <code>LatentCalendar</code> <p>model to use for prediction</p> required <code>index_func</code> <p>function to generate title for each row</p> <code>lambda : idx</code> <code>divergent</code> <code>bool</code> <p>whether to use divergent colormap</p> <code>True</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>grid of axes</p> Source code in <code>latent_calendar/extensions.py</code> <pre><code>def plot_model_predictions_by_row(\nself,\ndf_holdout: pd.DataFrame,\n*,\nmodel: LatentCalendar,\nindex_func=lambda idx: idx,\ndivergent: bool = True,\n) -&gt; np.ndarray:\n\"\"\"Plot model predictions for each row of the DataFrame. Data must have been transformed to wide format first.\n    Args:\n        df_holdout: holdout DataFrame for comparison\n        model: model to use for prediction\n        index_func: function to generate title for each row\n        divergent: whether to use divergent colormap\n    Returns:\n        grid of axes\n    \"\"\"\nreturn plot_model_predictions_by_row(\nself._obj,\ndf_holdout=df_holdout,\nmodel=model,\nindex_func=index_func,\ndivergent=divergent,\n)\n</code></pre>"},{"location":"modules/extensions/#latent_calendar.extensions.DataFrameAccessor.plot_profile_by_row","title":"<code>plot_profile_by_row(*, model, index_func=lambda : idx, include_components=True)</code>","text":"<p>Plot each row of the DataFrame as a profile plot. Data must have been transformed to wide format first.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>LatentCalendar</code> <p>model to use for prediction and transform</p> required <code>index_func</code> <p>function to generate title for each row</p> <code>lambda : idx</code> <code>include_components</code> <code>bool</code> <p>whether to include components in the plot</p> <code>True</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>grid of axes</p> Source code in <code>latent_calendar/extensions.py</code> <pre><code>def plot_profile_by_row(\nself,\n*,\nmodel: LatentCalendar,\nindex_func=lambda idx: idx,\ninclude_components: bool = True,\n) -&gt; np.ndarray:\n\"\"\"Plot each row of the DataFrame as a profile plot. Data must have been transformed to wide format first.\n    Args:\n        model: model to use for prediction and transform\n        index_func: function to generate title for each row\n        include_components: whether to include components in the plot\n    Returns:\n        grid of axes\n    \"\"\"\nreturn plot_profile_by_row(\nself._obj,\nmodel=model,\nindex_func=index_func,\ninclude_components=include_components,\n)\n</code></pre>"},{"location":"modules/extensions/#latent_calendar.extensions.DataFrameAccessor.plot_raw_and_predicted_by_row","title":"<code>plot_raw_and_predicted_by_row(*, model, index_func=lambda : idx)</code>","text":"<p>Plot raw and predicted values for a model. Data must have been transformed to wide format first.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>LatentCalendar</code> <p>model to use for prediction</p> required <code>index_func</code> <p>function to generate title for each row</p> <code>lambda : idx</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>grid of axes</p> Source code in <code>latent_calendar/extensions.py</code> <pre><code>def plot_raw_and_predicted_by_row(\nself, *, model: LatentCalendar, index_func=lambda idx: idx\n) -&gt; np.ndarray:\n\"\"\"Plot raw and predicted values for a model. Data must have been transformed to wide format first.\n    Args:\n        model: model to use for prediction\n        index_func: function to generate title for each row\n    Returns:\n        grid of axes\n    \"\"\"\nreturn plot_profile_by_row(\nself._obj, model=model, index_func=index_func, include_components=False\n)\n</code></pre>"},{"location":"modules/extensions/#latent_calendar.extensions.DataFrameAccessor.predict","title":"<code>predict(*, model)</code>","text":"<p>Predict DataFrame with model.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <p>model to use for prediction</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with predicted values (wide format)</p> Source code in <code>latent_calendar/extensions.py</code> <pre><code>def predict(self, *, model) -&gt; pd.DataFrame:\n\"\"\"Predict DataFrame with model.\n    Args:\n        model: model to use for prediction\n    Returns:\n        DataFrame with predicted values (wide format)\n    \"\"\"\nreturn predict_on_dataframe(self._obj, model=model)\n</code></pre>"},{"location":"modules/extensions/#latent_calendar.extensions.DataFrameAccessor.sum_next_hours","title":"<code>sum_next_hours(hours)</code>","text":"<p>Sum the wide format over next hours.</p> <p>Parameters:</p> Name Type Description Default <code>hours</code> <code>int</code> <p>number of hours to sum over</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with summed values</p> Source code in <code>latent_calendar/extensions.py</code> <pre><code>def sum_next_hours(self, hours: int) -&gt; pd.DataFrame:\n\"\"\"Sum the wide format over next hours.\n    Args:\n        hours: number of hours to sum over\n    Returns:\n        DataFrame with summed values\n    \"\"\"\nreturn sum_next_hours(self._obj, hours=hours)\n</code></pre>"},{"location":"modules/extensions/#latent_calendar.extensions.DataFrameAccessor.sum_over_segments","title":"<code>sum_over_segments(df_segments)</code>","text":"<p>Sum the wide format over user defined segments.</p> <p>Parameters:</p> Name Type Description Default <code>df_segments</code> <code>DataFrame</code> <p>DataFrame in wide format with segments as index</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with columns as the segments and summed values</p> Source code in <code>latent_calendar/extensions.py</code> <pre><code>def sum_over_segments(self, df_segments: pd.DataFrame) -&gt; pd.DataFrame:\n\"\"\"Sum the wide format over user defined segments.\n    Args:\n        df_segments: DataFrame in wide format with segments as index\n    Returns:\n        DataFrame with columns as the segments and summed values\n    \"\"\"\nreturn sum_over_segments(self._obj, df_segments=df_segments)\n</code></pre>"},{"location":"modules/extensions/#latent_calendar.extensions.DataFrameAccessor.sum_over_vocab","title":"<code>sum_over_vocab(aggregation='dow')</code>","text":"<p>Sum the wide format to day of week or hour of day.</p> <p>Parameters:</p> Name Type Description Default <code>aggregation</code> <code>str</code> <p>one of ['dow', 'hour']</p> <code>'dow'</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with summed values</p> <p>Examples:</p> <p>Sum to day of week</p> <pre><code>df_dow = df_wide.cal.sum_over_vocab(aggregation='dow')\n</code></pre> Source code in <code>latent_calendar/extensions.py</code> <pre><code>def sum_over_vocab(self, aggregation: str = \"dow\") -&gt; pd.DataFrame:\n\"\"\"Sum the wide format to day of week or hour of day.\n    Args:\n        aggregation: one of ['dow', 'hour']\n    Returns:\n        DataFrame with summed values\n    Examples:\n        Sum to day of week\n        ```python\n        df_dow = df_wide.cal.sum_over_vocab(aggregation='dow')\n        ```\n    \"\"\"\nreturn sum_over_vocab(self._obj, aggregation=aggregation)\n</code></pre>"},{"location":"modules/extensions/#latent_calendar.extensions.DataFrameAccessor.transform","title":"<code>transform(*, model)</code>","text":"<p>Transform DataFrame with model.</p> <p>Applies the dimensionality reduction to each row of the DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <p>model to use for transformation</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with transformed values</p> Source code in <code>latent_calendar/extensions.py</code> <pre><code>def transform(self, *, model) -&gt; pd.DataFrame:\n\"\"\"Transform DataFrame with model.\n    Applies the dimensionality reduction to each row of the DataFrame.\n    Args:\n        model: model to use for transformation\n    Returns:\n        DataFrame with transformed values\n    \"\"\"\nreturn transform_on_dataframe(self._obj, model=model)\n</code></pre>"},{"location":"modules/extensions/#latent_calendar.extensions.SeriesAccessor","title":"<code>SeriesAccessor</code>","text":"<p>Series accessor for latent_calendar accessed through <code>cal</code> attribute of Series.</p> Source code in <code>latent_calendar/extensions.py</code> <pre><code>@pd.api.extensions.register_series_accessor(\"cal\")\nclass SeriesAccessor:\n\"\"\"Series accessor for latent_calendar accessed through `cal` attribute of Series.\"\"\"\ndef __init__(self, pandas_obj: pd.Series):\nself._obj = pandas_obj\ndef plot(\nself,\n*,\nduration: int = 5,\nalpha: float = None,\ncmap=None,\nday_labeler: DayLabeler = DayLabeler(),\ntime_labeler: TimeLabeler = TimeLabeler(),\ngrid_lines: GridLines = GridLines(),\nmonday_start: bool = True,\nax: Optional[plt.Axes] = None,\n) -&gt; plt.Axes:\n\"\"\"Plot Series of timestamps as a calendar.\n        Args:\n            duration: duration of each event in minutes\n            alpha: alpha value for the color\n            cmap: function that maps floats to string colors\n            day_labeler: DayLabeler instance\n            time_labeler: TimeLabeler instance\n            grid_lines: GridLines instance\n            monday_start: whether to start the week on Monday or Sunday\n            ax: matplotlib axis to plot on\n        Returns:\n            Modified matplotlib axis\n        \"\"\"\ntmp_name = \"tmp_name\"\nconfig = StartEndConfig(start=tmp_name, end=None, minutes=duration)\nreturn plot_dataframe_as_calendar(\nself._obj.rename(tmp_name).to_frame(),\nconfig=config,\nalpha=alpha,\ncmap=cmap,\nmonday_start=monday_start,\nday_labeler=day_labeler,\ntime_labeler=time_labeler,\ngrid_lines=grid_lines,\nax=ax,\n)\ndef plot_row(\nself,\n*,\nalpha: float = None,\ncmap=None,\nday_labeler: DayLabeler = DayLabeler(),\ntime_labeler: TimeLabeler = TimeLabeler(),\ngrid_lines: GridLines = GridLines(),\nmonday_start: bool = True,\nax: Optional[plt.Axes] = None,\n) -&gt; plt.Axes:\n\"\"\"Plot Series of timestamps as a calendar.\n        Args:\n            alpha: alpha value for the color\n            cmap: function that maps floats to string colors\n            monday_start: whether to start the week on Monday or Sunday\n            ax: matplotlib axis to plot on\n        Returns:\n            Modified matplotlib axis\n        \"\"\"\nreturn plot_series_as_calendar(\nself._obj,\nalpha=alpha,\ncmap=cmap,\nax=ax,\nmonday_start=monday_start,\nday_labeler=day_labeler,\ntime_labeler=time_labeler,\ngrid_lines=grid_lines,\n)\n</code></pre>"},{"location":"modules/extensions/#latent_calendar.extensions.SeriesAccessor.plot","title":"<code>plot(*, duration=5, alpha=None, cmap=None, day_labeler=DayLabeler(), time_labeler=TimeLabeler(), grid_lines=GridLines(), monday_start=True, ax=None)</code>","text":"<p>Plot Series of timestamps as a calendar.</p> <p>Parameters:</p> Name Type Description Default <code>duration</code> <code>int</code> <p>duration of each event in minutes</p> <code>5</code> <code>alpha</code> <code>float</code> <p>alpha value for the color</p> <code>None</code> <code>cmap</code> <p>function that maps floats to string colors</p> <code>None</code> <code>day_labeler</code> <code>DayLabeler</code> <p>DayLabeler instance</p> <code>DayLabeler()</code> <code>time_labeler</code> <code>TimeLabeler</code> <p>TimeLabeler instance</p> <code>TimeLabeler()</code> <code>grid_lines</code> <code>GridLines</code> <p>GridLines instance</p> <code>GridLines()</code> <code>monday_start</code> <code>bool</code> <p>whether to start the week on Monday or Sunday</p> <code>True</code> <code>ax</code> <code>Optional[matplotlib.Axes]</code> <p>matplotlib axis to plot on</p> <code>None</code> <p>Returns:</p> Type Description <code>Axes</code> <p>Modified matplotlib axis</p> Source code in <code>latent_calendar/extensions.py</code> <pre><code>def plot(\nself,\n*,\nduration: int = 5,\nalpha: float = None,\ncmap=None,\nday_labeler: DayLabeler = DayLabeler(),\ntime_labeler: TimeLabeler = TimeLabeler(),\ngrid_lines: GridLines = GridLines(),\nmonday_start: bool = True,\nax: Optional[plt.Axes] = None,\n) -&gt; plt.Axes:\n\"\"\"Plot Series of timestamps as a calendar.\n    Args:\n        duration: duration of each event in minutes\n        alpha: alpha value for the color\n        cmap: function that maps floats to string colors\n        day_labeler: DayLabeler instance\n        time_labeler: TimeLabeler instance\n        grid_lines: GridLines instance\n        monday_start: whether to start the week on Monday or Sunday\n        ax: matplotlib axis to plot on\n    Returns:\n        Modified matplotlib axis\n    \"\"\"\ntmp_name = \"tmp_name\"\nconfig = StartEndConfig(start=tmp_name, end=None, minutes=duration)\nreturn plot_dataframe_as_calendar(\nself._obj.rename(tmp_name).to_frame(),\nconfig=config,\nalpha=alpha,\ncmap=cmap,\nmonday_start=monday_start,\nday_labeler=day_labeler,\ntime_labeler=time_labeler,\ngrid_lines=grid_lines,\nax=ax,\n)\n</code></pre>"},{"location":"modules/extensions/#latent_calendar.extensions.SeriesAccessor.plot_row","title":"<code>plot_row(*, alpha=None, cmap=None, day_labeler=DayLabeler(), time_labeler=TimeLabeler(), grid_lines=GridLines(), monday_start=True, ax=None)</code>","text":"<p>Plot Series of timestamps as a calendar.</p> <p>Parameters:</p> Name Type Description Default <code>alpha</code> <code>float</code> <p>alpha value for the color</p> <code>None</code> <code>cmap</code> <p>function that maps floats to string colors</p> <code>None</code> <code>monday_start</code> <code>bool</code> <p>whether to start the week on Monday or Sunday</p> <code>True</code> <code>ax</code> <code>Optional[matplotlib.Axes]</code> <p>matplotlib axis to plot on</p> <code>None</code> <p>Returns:</p> Type Description <code>Axes</code> <p>Modified matplotlib axis</p> Source code in <code>latent_calendar/extensions.py</code> <pre><code>def plot_row(\nself,\n*,\nalpha: float = None,\ncmap=None,\nday_labeler: DayLabeler = DayLabeler(),\ntime_labeler: TimeLabeler = TimeLabeler(),\ngrid_lines: GridLines = GridLines(),\nmonday_start: bool = True,\nax: Optional[plt.Axes] = None,\n) -&gt; plt.Axes:\n\"\"\"Plot Series of timestamps as a calendar.\n    Args:\n        alpha: alpha value for the color\n        cmap: function that maps floats to string colors\n        monday_start: whether to start the week on Monday or Sunday\n        ax: matplotlib axis to plot on\n    Returns:\n        Modified matplotlib axis\n    \"\"\"\nreturn plot_series_as_calendar(\nself._obj,\nalpha=alpha,\ncmap=cmap,\nax=ax,\nmonday_start=monday_start,\nday_labeler=day_labeler,\ntime_labeler=time_labeler,\ngrid_lines=grid_lines,\n)\n</code></pre>"},{"location":"modules/generate/","title":"Generate","text":"<p>Generate some fake data for various purposes.</p>"},{"location":"modules/generate/#latent_calendar.generate.sample_from_lda","title":"<code>sample_from_lda(components_prior, components_time_slots_prior, n_samples, random_state=None)</code>","text":"<p>Sample from LDA model.</p> <p>Parameters:</p> Name Type Description Default <code>components_prior</code> <code>Union[ndarray, TensorVariable]</code> <p>prior probability of each component (n_components, )</p> required <code>components_time_slots_prior</code> <code>Union[ndarray, TensorVariable]</code> <p>prior for time slots (n_components, n_time_slots)</p> required <code>n_samples</code> <code>ndarray</code> <p>number of samples for each user (n_user, )</p> required <code>random_state</code> <code>Optional[int]</code> <p>random state for sampling</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[DataFrame, DataFrame]</code> <p>probability DataFrame (n_user, n_components) and event count DataFrame with (n_user, n_time_slots) with each row summing up to <code>n</code></p> Source code in <code>latent_calendar/generate.py</code> <pre><code>def sample_from_lda(\ncomponents_prior: Union[np.ndarray, TensorVariable],\ncomponents_time_slots_prior: Union[np.ndarray, TensorVariable],\nn_samples: np.ndarray,\nrandom_state: Optional[int] = None,\n) -&gt; Tuple[pd.DataFrame, pd.DataFrame]:\n\"\"\"Sample from LDA model.\n    Args:\n        components_prior: prior probability of each component (n_components, )\n        components_time_slots_prior: prior for time slots (n_components, n_time_slots)\n        n_samples: number of samples for each user (n_user, )\n        random_state: random state for sampling\n    Returns:\n        probability DataFrame (n_user, n_components) and event count DataFrame with (n_user, n_time_slots) with each row summing up to `n`\n    \"\"\"\nrng = np.random.default_rng(random_state)\nuser_travel_style_data = []\nuser_time_slot_data = []\ntravel_style = pm.Dirichlet.dist(components_prior)\ntime_slot_styles = pm.Dirichlet.dist(components_time_slots_prior)\nfor n in n_samples:\n_, user_time_slots = define_single_user_samples(\ntravel_style, time_slot_styles, n_samples=int(n)\n)\nuser_travel_style_samples, user_time_slot_samples = pm.draw(\n[travel_style, user_time_slots.sum(axis=0)], draws=1, random_seed=rng\n)\nuser_travel_style_data.append(user_travel_style_samples)\nuser_time_slot_data.append(user_time_slot_samples)\ndf_user_travel_style = pd.DataFrame(user_travel_style_data)\ndf_user_time_slots = pd.DataFrame(user_time_slot_data)\nreturn df_user_travel_style, df_user_time_slots\n</code></pre>"},{"location":"modules/generate/#latent_calendar.generate.wide_format_dataframe","title":"<code>wide_format_dataframe(n_rows, rate=1.0, random_state=None)</code>","text":"<p>Generate some data from Poisson distribution.</p> <p>Parameters:</p> Name Type Description Default <code>n_rows</code> <code>int</code> <p>number of rows to generate</p> required <code>rate</code> <code>float</code> <p>rate parameter for Poisson distribution</p> <code>1.0</code> <code>random_state</code> <code>Optional[int]</code> <p>random state for reproducibility</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with columns from FULL_VOCAB and n_rows rows</p> Source code in <code>latent_calendar/generate.py</code> <pre><code>def wide_format_dataframe(\nn_rows: int, rate: float = 1.0, random_state: Optional[int] = None\n) -&gt; pd.DataFrame:\n\"\"\"Generate some data from Poisson distribution.\n    Args:\n        n_rows: number of rows to generate\n        rate: rate parameter for Poisson distribution\n        random_state: random state for reproducibility\n    Returns:\n        DataFrame with columns from FULL_VOCAB and n_rows rows\n    \"\"\"\nif random_state is not None:\nnp.random.seed(random_state)\ndata = np.random.poisson(lam=rate, size=(n_rows, len(FULL_VOCAB)))\nreturn pd.DataFrame(data, columns=FULL_VOCAB)\n</code></pre>"},{"location":"modules/model/","title":"Model","text":"<p>Models for the joint distribution of weekly calendar data.</p> <pre><code>model = LatentCalendar(n_components=3, random_state=42)\nX = df_wide.to_numpy()\nmodel.fit(X)\nX_latent = model.transform(X)\nX_pred = model.predict(X)\n</code></pre>"},{"location":"modules/model/#latent_calendar.model.latent_calendar.ConjugateModel","title":"<code>ConjugateModel</code>","text":"<p>             Bases: <code>BaseEstimator</code>, <code>TransformerMixin</code></p> <p>Conjugate model for the calendar joint distribution.</p> <p>This is a wrapper around the conjugate model for the multinomial distribution. It is a wrapper around the Dirichlet distribution.</p> <p>This doesn't use dimensionality reduction, but it does use the conjugate model.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>Optional[numpy.ndarray]</code> <p>(n_times,) prior for each hour of the day. If None, then the prior is the average of the data.</p> <code>None</code> Source code in <code>latent_calendar/model/latent_calendar.py</code> <pre><code>class ConjugateModel(BaseEstimator, TransformerMixin):\n\"\"\"Conjugate model for the calendar joint distribution.\n    This is a wrapper around the conjugate model for the multinomial\n    distribution. It is a wrapper around the Dirichlet distribution.\n    This doesn't use dimensionality reduction, but it does use the\n    conjugate model.\n    Args:\n        a: (n_times,) prior for each hour of the day. If None, then\n            the prior is the average of the data.\n    \"\"\"\ndef __init__(self, a: Optional[np.ndarray] = None) -&gt; None:\nself.a = a\ndef fit(self, X, y=None) -&gt; \"ConjugateModel\":\n\"\"\"Fit the conjugate model.\"\"\"\nif self.a is None:\nself.a = hourly_prior(X)\nself.prior = Dirichlet(alpha=self.a)\nreturn self\ndef transform(self, X, y=None) -&gt; np.ndarray:\nreturn multinomial_dirichlet(X, self.prior).dist.mean()\ndef predict(self, X, y=None) -&gt; np.ndarray:\nreturn self.transform(X, y=y)\n</code></pre>"},{"location":"modules/model/#latent_calendar.model.latent_calendar.ConjugateModel.fit","title":"<code>fit(X, y=None)</code>","text":"<p>Fit the conjugate model.</p> Source code in <code>latent_calendar/model/latent_calendar.py</code> <pre><code>def fit(self, X, y=None) -&gt; \"ConjugateModel\":\n\"\"\"Fit the conjugate model.\"\"\"\nif self.a is None:\nself.a = hourly_prior(X)\nself.prior = Dirichlet(alpha=self.a)\nreturn self\n</code></pre>"},{"location":"modules/model/#latent_calendar.model.latent_calendar.DummyModel","title":"<code>DummyModel</code>","text":"<p>             Bases: <code>LatentCalendar</code></p> <p>Return even probability of a latent.</p> <p>This can be used as the worse possible baseline.</p> Source code in <code>latent_calendar/model/latent_calendar.py</code> <pre><code>class DummyModel(LatentCalendar):\n\"\"\"Return even probability of a latent.\n    This can be used as the worse possible baseline.\n    \"\"\"\ndef fit(self, X, y=None) -&gt; \"DummyModel\":\n\"\"\"All components are equal probabilty of every hour.\"\"\"\n# Even probabilty for every thing\nself.n_components = 1\nself.components_ = np.ones((self.n_components, TIME_SLOTS)) * EVEN_PROBABILITY\nreturn self\ndef transform(self, X, y=None) -&gt; np.ndarray:\n\"\"\"Everyone has equal probability of being in each group.\"\"\"\nnrows = len(X)\nreturn np.ones((nrows, self.n_components)) / self.n_components\n@classmethod\ndef create(cls) -&gt; \"DummyModel\":\n\"\"\"Return a dummy model ready for transforming and predicting.\"\"\"\nmodel = cls()\nmodel.fit(X=None)\nreturn model\n@classmethod\ndef from_prior(cls, prior: np.ndarray) -&gt; \"DummyModel\":\n\"\"\"Return a dummy model from a prior.\"\"\"\nmodel = cls()\nmodel.components_ = prior[np.newaxis, :]\nmodel.n_components = 1\nreturn model\n</code></pre>"},{"location":"modules/model/#latent_calendar.model.latent_calendar.DummyModel.create","title":"<code>create()</code>  <code>classmethod</code>","text":"<p>Return a dummy model ready for transforming and predicting.</p> Source code in <code>latent_calendar/model/latent_calendar.py</code> <pre><code>@classmethod\ndef create(cls) -&gt; \"DummyModel\":\n\"\"\"Return a dummy model ready for transforming and predicting.\"\"\"\nmodel = cls()\nmodel.fit(X=None)\nreturn model\n</code></pre>"},{"location":"modules/model/#latent_calendar.model.latent_calendar.DummyModel.fit","title":"<code>fit(X, y=None)</code>","text":"<p>All components are equal probabilty of every hour.</p> Source code in <code>latent_calendar/model/latent_calendar.py</code> <pre><code>def fit(self, X, y=None) -&gt; \"DummyModel\":\n\"\"\"All components are equal probabilty of every hour.\"\"\"\n# Even probabilty for every thing\nself.n_components = 1\nself.components_ = np.ones((self.n_components, TIME_SLOTS)) * EVEN_PROBABILITY\nreturn self\n</code></pre>"},{"location":"modules/model/#latent_calendar.model.latent_calendar.DummyModel.from_prior","title":"<code>from_prior(prior)</code>  <code>classmethod</code>","text":"<p>Return a dummy model from a prior.</p> Source code in <code>latent_calendar/model/latent_calendar.py</code> <pre><code>@classmethod\ndef from_prior(cls, prior: np.ndarray) -&gt; \"DummyModel\":\n\"\"\"Return a dummy model from a prior.\"\"\"\nmodel = cls()\nmodel.components_ = prior[np.newaxis, :]\nmodel.n_components = 1\nreturn model\n</code></pre>"},{"location":"modules/model/#latent_calendar.model.latent_calendar.DummyModel.transform","title":"<code>transform(X, y=None)</code>","text":"<p>Everyone has equal probability of being in each group.</p> Source code in <code>latent_calendar/model/latent_calendar.py</code> <pre><code>def transform(self, X, y=None) -&gt; np.ndarray:\n\"\"\"Everyone has equal probability of being in each group.\"\"\"\nnrows = len(X)\nreturn np.ones((nrows, self.n_components)) / self.n_components\n</code></pre>"},{"location":"modules/model/#latent_calendar.model.latent_calendar.LatentCalendar","title":"<code>LatentCalendar</code>","text":"<p>             Bases: <code>LatentDirichletAllocation</code></p> <p>Model weekly calendar data as a mixture of multinomial distributions.</p> <p>Adapted from sklearn's Latent Dirichlet Allocation model.</p> <p>Provides a <code>predict</code> method that returns the marginal probability of each time slot for a given row and a <code>transform</code> method that returns the latent representation of each row.</p> Source code in <code>latent_calendar/model/latent_calendar.py</code> <pre><code>class LatentCalendar(BaseLDA):\n\"\"\"Model weekly calendar data as a mixture of multinomial distributions.\n    Adapted from sklearn's [Latent Dirichlet Allocation](https://scikit-learn.org/stable/modules/generated/sklearn.decomposition.LatentDirichletAllocation.html) model.\n    Provides a `predict` method that returns the marginal probability of each time slot for a given row and\n    a `transform` method that returns the latent representation of each row.\n    \"\"\"\n@property\ndef normalized_components_(self) -&gt; np.ndarray:\nreturn self.components_ / self.components_.sum(axis=1)[:, np.newaxis]\ndef joint_distribution(self, X_latent: np.ndarray) -&gt; np.ndarray:\n\"\"\"Marginalize out the components.\"\"\"\nreturn joint_distribution(\nX_latent=X_latent, components=self.normalized_components_\n)\ndef predict(self, X: np.ndarray, y=None) -&gt; np.ndarray:\n\"\"\"Return the marginal probabilities for a given row.\n        Marginalize out the loads via law of total probability\n        P[time=t | Row=r] = sum P[time=t | L=l, Row=r] * P[L=l | Row=r]\n        \"\"\"\n# (n, n_components)\nX_latent = self.transform(X)\nreturn self.joint_distribution(X_latent=X_latent)\n</code></pre>"},{"location":"modules/model/#latent_calendar.model.latent_calendar.LatentCalendar.joint_distribution","title":"<code>joint_distribution(X_latent)</code>","text":"<p>Marginalize out the components.</p> Source code in <code>latent_calendar/model/latent_calendar.py</code> <pre><code>def joint_distribution(self, X_latent: np.ndarray) -&gt; np.ndarray:\n\"\"\"Marginalize out the components.\"\"\"\nreturn joint_distribution(\nX_latent=X_latent, components=self.normalized_components_\n)\n</code></pre>"},{"location":"modules/model/#latent_calendar.model.latent_calendar.LatentCalendar.predict","title":"<code>predict(X, y=None)</code>","text":"<p>Return the marginal probabilities for a given row.</p> <p>Marginalize out the loads via law of total probability P[time=t | Row=r] = sum P[time=t | L=l, Row=r] * P[L=l | Row=r]</p> Source code in <code>latent_calendar/model/latent_calendar.py</code> <pre><code>def predict(self, X: np.ndarray, y=None) -&gt; np.ndarray:\n\"\"\"Return the marginal probabilities for a given row.\n    Marginalize out the loads via law of total probability\n    P[time=t | Row=r] = sum P[time=t | L=l, Row=r] * P[L=l | Row=r]\n    \"\"\"\n# (n, n_components)\nX_latent = self.transform(X)\nreturn self.joint_distribution(X_latent=X_latent)\n</code></pre>"},{"location":"modules/model/#latent_calendar.model.latent_calendar.MarginalModel","title":"<code>MarginalModel</code>","text":"<p>             Bases: <code>LatentCalendar</code></p> Source code in <code>latent_calendar/model/latent_calendar.py</code> <pre><code>class MarginalModel(LatentCalendar):\ndef fit(self, X, y=None) -&gt; \"MarginalModel\":\n\"\"\"Just sum over all the rows.\"\"\"\nself.n_components = 1\n# (1, n_times)\nself.components_ = X.sum(axis=0)[np.newaxis, :]\nreturn self\ndef transform(self, X, y=None) -&gt; np.ndarray:\n\"\"\"There is only one component to be a part of.\"\"\"\nnrows = len(X)\n# (nrows, 1)\nreturn np.repeat(1, nrows)[:, np.newaxis]\n</code></pre>"},{"location":"modules/model/#latent_calendar.model.latent_calendar.MarginalModel.fit","title":"<code>fit(X, y=None)</code>","text":"<p>Just sum over all the rows.</p> Source code in <code>latent_calendar/model/latent_calendar.py</code> <pre><code>def fit(self, X, y=None) -&gt; \"MarginalModel\":\n\"\"\"Just sum over all the rows.\"\"\"\nself.n_components = 1\n# (1, n_times)\nself.components_ = X.sum(axis=0)[np.newaxis, :]\nreturn self\n</code></pre>"},{"location":"modules/model/#latent_calendar.model.latent_calendar.MarginalModel.transform","title":"<code>transform(X, y=None)</code>","text":"<p>There is only one component to be a part of.</p> Source code in <code>latent_calendar/model/latent_calendar.py</code> <pre><code>def transform(self, X, y=None) -&gt; np.ndarray:\n\"\"\"There is only one component to be a part of.\"\"\"\nnrows = len(X)\n# (nrows, 1)\nreturn np.repeat(1, nrows)[:, np.newaxis]\n</code></pre>"},{"location":"modules/model/#latent_calendar.model.latent_calendar.constant_prior","title":"<code>constant_prior(X, value=1.0)</code>","text":"<p>Return the prior for each hour of the day.</p> <p>This is the average of all the rows.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>ndarray</code> <p>(nrows, n_times)</p> required Source code in <code>latent_calendar/model/latent_calendar.py</code> <pre><code>def constant_prior(X: np.ndarray, value: float = 1.0) -&gt; np.ndarray:\n\"\"\"Return the prior for each hour of the day.\n    This is the average of all the rows.\n    Args:\n        X: (nrows, n_times)\n    \"\"\"\nreturn np.repeat(value, TIME_SLOTS)\n</code></pre>"},{"location":"modules/model/#latent_calendar.model.latent_calendar.hourly_prior","title":"<code>hourly_prior(X)</code>","text":"<p>Return the prior for each hour of the day.</p> <p>This is the average of all the rows.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>ndarray</code> <p>(nrows, n_times)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>(n_times,)</p> Source code in <code>latent_calendar/model/latent_calendar.py</code> <pre><code>def hourly_prior(X: np.ndarray) -&gt; np.ndarray:\n\"\"\"Return the prior for each hour of the day.\n    This is the average of all the rows.\n    Args:\n        X: (nrows, n_times)\n    Returns:\n        (n_times,)\n    \"\"\"\nreturn (X &gt; 0).sum(axis=0) / len(X)\n</code></pre>"},{"location":"modules/model/#latent_calendar.model.latent_calendar.joint_distribution","title":"<code>joint_distribution(X_latent, components)</code>","text":"<p>Marginalize out the components.</p> Source code in <code>latent_calendar/model/latent_calendar.py</code> <pre><code>def joint_distribution(X_latent: np.ndarray, components: np.ndarray) -&gt; np.ndarray:\n\"\"\"Marginalize out the components.\"\"\"\nreturn X_latent @ components\n</code></pre>"},{"location":"modules/model/#latent_calendar.model.utils.predict_on_dataframe","title":"<code>predict_on_dataframe(df, model)</code>","text":"<p>Small wrapper to predict on DataFrame and keep same columns and index.</p> Source code in <code>latent_calendar/model/utils.py</code> <pre><code>def predict_on_dataframe(df: pd.DataFrame, model: LatentCalendar) -&gt; pd.DataFrame:\n\"\"\"Small wrapper to predict on DataFrame and keep same columns and index.\"\"\"\nreturn pd.DataFrame(\nmodel.predict(df.to_numpy()), columns=df.columns, index=df.index\n)\n</code></pre>"},{"location":"modules/model/#latent_calendar.model.utils.transform_on_dataframe","title":"<code>transform_on_dataframe(df, model)</code>","text":"<p>Small wrapper to transform on DataFrame and keep index.</p> Source code in <code>latent_calendar/model/utils.py</code> <pre><code>def transform_on_dataframe(df: pd.DataFrame, model: LatentCalendar) -&gt; pd.DataFrame:\n\"\"\"Small wrapper to transform on DataFrame and keep index.\"\"\"\nreturn pd.DataFrame(model.transform(df.to_numpy()), index=df.index)\n</code></pre>"},{"location":"modules/plot/","title":"Plot","text":"<p>Plotting functions for latent calendar. </p> <p>These functions and classes build every calendar plot.</p>"},{"location":"modules/segments/","title":"Segments","text":"<p>Create hand picked segments on the calendar.</p> <p>Examples:</p> <p>Create some segments for a calendar: </p> <pre><code>mornings = create_box_segment(\nday_start=0, day_end=7, hour_start=6, hour_end=11, name=\"Mornings\"\n) \nafternoons = create_box_segment(\nday_start=0, day_end=7, hour_start=11, hour_end=16, name=\"Afternoons\"\n)\nevenings = create_box_segment(\nday_start=0, day_end=7, hour_start=16, hour_end=21, name=\"Evenings\"\n)\ndf_segments = stack_segments([\nmornings,\nafternoons,\nevenings,\n])\ndf_segments.cal.plot_by_row()\n</code></pre> <p></p> <p>Processing off calendar distribution.</p>"},{"location":"modules/segments/#latent_calendar.segments.hand_picked.create_blank_segment_series","title":"<code>create_blank_segment_series()</code>","text":"<p>Helper for making segments programatically.</p> Source code in <code>latent_calendar/segments/hand_picked.py</code> <pre><code>def create_blank_segment_series() -&gt; pd.Series:\n\"\"\"Helper for making segments programatically.\"\"\"\nreturn pd.Series(0, index=FULL_VOCAB)\n</code></pre>"},{"location":"modules/segments/#latent_calendar.segments.hand_picked.create_box_segment","title":"<code>create_box_segment(day_start, day_end, hour_start, hour_end, name=None)</code>","text":"<p>Programmatically make segment of box described by inputs.</p> Source code in <code>latent_calendar/segments/hand_picked.py</code> <pre><code>def create_box_segment(\nday_start: int,\nday_end: int,\nhour_start: int,\nhour_end: int,\nname: Optional[str] = None,\n) -&gt; pd.Series:\n\"\"\"Programmatically make segment of box described by inputs.\"\"\"\nser = create_blank_segment_series()\nfor dow in range(day_start, day_end):\nstart = DOWHour(dow=dow, hour=hour_start)\nend = DOWHour(dow=dow, hour=hour_end)\nser += create_series_for_range(start=start, end=end)\nname = name or f\"{day_start}-{day_end} {hour_start}-{hour_end}\"\nreturn ser.rename(name)\n</code></pre>"},{"location":"modules/segments/#latent_calendar.segments.hand_picked.create_dow_segments","title":"<code>create_dow_segments()</code>","text":"<p>Programmatically make the DOW segments.</p> <p>Each row is just each day of the week.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame in the df_segments wide format</p> Source code in <code>latent_calendar/segments/hand_picked.py</code> <pre><code>def create_dow_segments() -&gt; pd.DataFrame:\n\"\"\"Programmatically make the DOW segments.\n    Each row is just each day of the week.\n    Returns:\n        DataFrame in the df_segments wide format\n    \"\"\"\nsegments = []\nfor i, day in enumerate(create_default_days()):\nday_number = str(i).zfill(2)\nname = f\"{day_number}-{day}\"\nstart = DOWHour(dow=i, hour=0)\nend = DOWHour(dow=i, hour=24)\nsegments.append(create_hourly_segment(start=start, end=end, name=name))\nreturn stack_segments(segments)\n</code></pre>"},{"location":"modules/segments/#latent_calendar.segments.hand_picked.create_empty_template","title":"<code>create_empty_template()</code>","text":"<p>Create blank template in order</p> Source code in <code>latent_calendar/segments/hand_picked.py</code> <pre><code>def create_empty_template() -&gt; pd.DataFrame:\n\"\"\"Create blank template in order\"\"\"\nindex = pd.Index(range(HOURS_IN_DAY), name=\"hour_start\")\nreturn pd.DataFrame(\nnp.nan,\nindex=index,\ncolumns=create_default_days(),\n)\n</code></pre>"},{"location":"modules/segments/#latent_calendar.segments.hand_picked.create_every_hour_segments","title":"<code>create_every_hour_segments()</code>","text":"<p>Programmatically segments for every hour</p> <p>Each row is just each time slot</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame in the df_segments wide format</p> Source code in <code>latent_calendar/segments/hand_picked.py</code> <pre><code>def create_every_hour_segments() -&gt; pd.DataFrame:\n\"\"\"Programmatically segments for every hour\n    Each row is just each time slot\n    Returns:\n        DataFrame in the df_segments wide format\n    \"\"\"\nsegments = []\nfor dow, hour in itertools.product(range(DAYS_IN_WEEK), range(HOURS_IN_DAY)):\nname = format_dow_hour(dow, hour)\nstart = DOWHour(dow=dow, hour=hour)\nend = DOWHour(dow=dow, hour=hour + 1)\nsegments.append(create_hourly_segment(start=start, end=end, name=name))\nreturn stack_segments(segments)\n</code></pre>"},{"location":"modules/segments/#latent_calendar.segments.hand_picked.create_hourly_segment","title":"<code>create_hourly_segment(start, end, name)</code>","text":"<p>Highlight from start until end.</p> Source code in <code>latent_calendar/segments/hand_picked.py</code> <pre><code>def create_hourly_segment(start: DOWHour, end: DOWHour, name: str) -&gt; pd.Series:\n\"\"\"Highlight from start until end.\"\"\"\nreturn create_series_for_range(start=start, end=end).rename(name)\n</code></pre>"},{"location":"modules/segments/#latent_calendar.segments.hand_picked.create_series_for_range","title":"<code>create_series_for_range(start, end)</code>","text":"<p>Create a series for a range of hours with ones for those in range.</p> Source code in <code>latent_calendar/segments/hand_picked.py</code> <pre><code>def create_series_for_range(start: DOWHour, end: DOWHour) -&gt; pd.Series:\n\"\"\"Create a series for a range of hours with ones for those in range.\"\"\"\nser = create_blank_segment_series()\nif start.is_after(end):\nend, start = start, end\nnegate = True\nelse:\nnegate = False\nstart_idx = format_dow_hour(start.dow, start.hour)\nend_idx = format_dow_hour(end.dow, end.hour - 1)\nser.loc[start_idx:end_idx] = 1\nif negate:\nser = (ser - 1) * -1\nreturn ser.astype(int)\n</code></pre>"},{"location":"modules/segments/#latent_calendar.segments.hand_picked.get_vocab_for_range","title":"<code>get_vocab_for_range(start, end)</code>","text":"<p>Get the vocab for a range of hours.</p> Source code in <code>latent_calendar/segments/hand_picked.py</code> <pre><code>def get_vocab_for_range(start: DOWHour, end: DOWHour) -&gt; List[str]:\n\"\"\"Get the vocab for a range of hours.\"\"\"\nreturn (\ncreate_series_for_range(start=start, end=end)\n.loc[lambda x: x == 1]\n.index.tolist()\n)\n</code></pre>"},{"location":"modules/segments/#latent_calendar.segments.hand_picked.stack_segments","title":"<code>stack_segments(segments)</code>","text":"<p>Stack segments into a single dataframe.</p> Source code in <code>latent_calendar/segments/hand_picked.py</code> <pre><code>def stack_segments(segments: List[pd.Series]) -&gt; pd.DataFrame:\n\"\"\"Stack segments into a single dataframe.\"\"\"\nreturn pd.concat(segments, axis=1).T\n</code></pre>"},{"location":"modules/segments/#latent_calendar.segments.convolution.sum_array_over_segments","title":"<code>sum_array_over_segments(X_pred, X_segment)</code>","text":"<p>Get the probability of the mask for the probabilities.</p> <p>Parameters:</p> Name Type Description Default <code>X_pred</code> <code>ndarray</code> <p>(nrows, n_times)</p> required <code>X_segment</code> <code>ndarray</code> <p>(n_segments, n_times)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Matrix of (nrows, n_segments) defining the probabilities of each segments</p> Source code in <code>latent_calendar/segments/convolution.py</code> <pre><code>def sum_array_over_segments(X_pred: np.ndarray, X_segment: np.ndarray) -&gt; np.ndarray:\n\"\"\"Get the probability of the mask for the probabilities.\n    Args:\n        X_pred: (nrows, n_times)\n        X_segment: (n_segments, n_times)\n    Returns:\n        Matrix of (nrows, n_segments) defining the probabilities of each segments\n    \"\"\"\nreturn _mask_probs(X_segment, X_pred).sum(axis=2).T\n</code></pre>"},{"location":"modules/segments/#latent_calendar.segments.convolution.sum_next_hours","title":"<code>sum_next_hours(df, hours)</code>","text":"<p>Sum the next hours columns.</p> <p>Useful for finding probability of having tour in the next 5 hours 00 00 column would be 06 06 23</p> <p>TODO: Consider if negative hours should be allowed</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>DataFrame of probabilities or counts in wide format</p> required <code>hours</code> <code>int</code> <p>Number of hours to sum after the current hour</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame summed over the next hours</p> Source code in <code>latent_calendar/segments/convolution.py</code> <pre><code>def sum_next_hours(df: pd.DataFrame, hours: int) -&gt; pd.DataFrame:\n\"\"\"Sum the next hours columns.\n    Useful for finding probability of having tour in the next 5 hours\n    00 00 column would be 06 06 23\n    TODO: Consider if negative hours should be allowed\n    Arguments:\n        df: DataFrame of probabilities or counts in wide format\n        hours: Number of hours to sum after the current hour\n    Returns:\n        DataFrame summed over the next hours\n    \"\"\"\nif hours &lt; 0:\nmsg = \"hours cannot be negative\"\nraise ValueError(msg)\nif hours == 0:\nreturn df\nreturn (\npd.concat([df, df.iloc[:, :hours]], axis=1)\n.pipe(_reverse_columns)\n.rolling(hours + 1, axis=1)\n.sum()\n.iloc[:, hours:]\n.pipe(_reverse_columns)\n)\n</code></pre>"},{"location":"modules/segments/#latent_calendar.segments.convolution.sum_over_segments","title":"<code>sum_over_segments(df, df_segments)</code>","text":"<p>Sum DataFrame over user defined segments.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>DataFrame of probabilities or counts in wide format</p> required <code>df_segments</code> <code>DataFrame</code> <p>DataFrame of segments in wide format</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame of probabilities or counts summed over the segments</p> Source code in <code>latent_calendar/segments/convolution.py</code> <pre><code>def sum_over_segments(df: pd.DataFrame, df_segments: pd.DataFrame) -&gt; pd.DataFrame:\n\"\"\"Sum DataFrame over user defined segments.\n    Args:\n        df: DataFrame of probabilities or counts in wide format\n        df_segments: DataFrame of segments in wide format\n    Returns:\n        DataFrame of probabilities or counts summed over the segments\n    \"\"\"\nreturn pd.DataFrame(\nsum_array_over_segments(df.to_numpy(), df_segments.to_numpy()),\nindex=df.index,\ncolumns=df_segments.index,\n)\n</code></pre>"},{"location":"modules/segments/#latent_calendar.segments.convolution.sum_over_vocab","title":"<code>sum_over_vocab(df, aggregation='dow')</code>","text":"<p>Sum the wide DataFrame columns to hours or dow.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>DataFrame in wide format with vocab column names</p> required <code>aggregation</code> <code>str</code> <p>either dow or hour</p> <code>'dow'</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame columns associated with the aggregation</p> Source code in <code>latent_calendar/segments/convolution.py</code> <pre><code>def sum_over_vocab(df: pd.DataFrame, aggregation: str = \"dow\") -&gt; pd.DataFrame:\n\"\"\"Sum the wide DataFrame columns to hours or dow.\n    Args:\n        df: DataFrame in wide format with vocab column names\n        aggregation: either dow or hour\n    Returns:\n        DataFrame columns associated with the aggregation\n    \"\"\"\nif aggregation not in {\"dow\", \"hour\"}:\nmsg = \"The aggregation must be hour or dow\"\nraise ValueError(msg)\nif aggregation == \"hour\":\nregex_func = _hour_regex\ntotal_values = HOURS_IN_DAY\ncolumn_name_func = lambda i: i\nelse:\nregex_func = _dow_regex\ntotal_values = DAYS_IN_WEEK\ncolumn_name_func = day_of_week_column_name_func\nreturn pd.concat(\n[\ndf.filter(regex=regex_func(i)).sum(axis=1).rename(column_name_func(i))\nfor i in range(total_values)\n],\naxis=1,\n)\n</code></pre>"},{"location":"modules/transformers/","title":"Transformers","text":"<p>scikit-learn transformers for the data.</p> <pre><code>from latent_calendar.datasets import load_online_transactions\ndf = load_online_transactions()\ntransformers = create_raw_to_vocab_transformer(id_col=\"Customer ID\", timestamp_col=\"InvoiceDate\")\ndf_wide = transformers.fit_transform(df)\n</code></pre>"},{"location":"modules/transformers/#latent_calendar.transformers.CalandarTimestampFeatures","title":"<code>CalandarTimestampFeatures</code>","text":"<p>             Bases: <code>BaseEstimator</code>, <code>TransformerMixin</code></p> <p>Day of week and prop into day columns creation.</p> Source code in <code>latent_calendar/transformers.py</code> <pre><code>class CalandarTimestampFeatures(BaseEstimator, TransformerMixin):\n\"\"\"Day of week and prop into day columns creation.\"\"\"\ndef __init__(\nself,\ntimestamp_col: str,\n) -&gt; None:\nself.timestamp_col = timestamp_col\ndef fit(self, X: pd.DataFrame, y=None):\nreturn self\ndef transform(self, X: pd.DataFrame, y=None) -&gt; pd.DataFrame:\n\"\"\"Create 2 new columns.\"\"\"\nif not hasattr(X[self.timestamp_col], \"dt\"):\nraise RuntimeError(\nf\"Column {self.timestamp_col!r} is not a datetime column. Use df[{self.timestamp_col!r}] = pd.to_datetime(df[{self.timestamp_col!r}]) first.\"\n)\nX = X.copy()\nX[\"prop_into_day_start\"] = prop_into_day(X[self.timestamp_col].dt)\nX[\"day_of_week\"] = X[self.timestamp_col].dt.dayofweek\nX[\"hour\"] = X[\"prop_into_day_start\"] * 24\ntmp_columns = [\"prop_into_day_start\"]\nself.created_columns = [\"day_of_week\", \"hour\"]\nX = X.drop(columns=tmp_columns)\nself.columns = list(X.columns)\nreturn X\ndef get_feature_names_out(self, input_features=None):\nreturn self.columns.extend(self.created_columns)\n</code></pre>"},{"location":"modules/transformers/#latent_calendar.transformers.CalandarTimestampFeatures.transform","title":"<code>transform(X, y=None)</code>","text":"<p>Create 2 new columns.</p> Source code in <code>latent_calendar/transformers.py</code> <pre><code>def transform(self, X: pd.DataFrame, y=None) -&gt; pd.DataFrame:\n\"\"\"Create 2 new columns.\"\"\"\nif not hasattr(X[self.timestamp_col], \"dt\"):\nraise RuntimeError(\nf\"Column {self.timestamp_col!r} is not a datetime column. Use df[{self.timestamp_col!r}] = pd.to_datetime(df[{self.timestamp_col!r}]) first.\"\n)\nX = X.copy()\nX[\"prop_into_day_start\"] = prop_into_day(X[self.timestamp_col].dt)\nX[\"day_of_week\"] = X[self.timestamp_col].dt.dayofweek\nX[\"hour\"] = X[\"prop_into_day_start\"] * 24\ntmp_columns = [\"prop_into_day_start\"]\nself.created_columns = [\"day_of_week\", \"hour\"]\nX = X.drop(columns=tmp_columns)\nself.columns = list(X.columns)\nreturn X\n</code></pre>"},{"location":"modules/transformers/#latent_calendar.transformers.HourDiscretizer","title":"<code>HourDiscretizer</code>","text":"<p>             Bases: <code>BaseEstimator</code>, <code>TransformerMixin</code></p> <p>Discretize the hour column.</p> Source code in <code>latent_calendar/transformers.py</code> <pre><code>class HourDiscretizer(BaseEstimator, TransformerMixin):\n\"\"\"Discretize the hour column.\"\"\"\ndef __init__(self, col: str = \"hour\") -&gt; None:\nself.col = col\ndef fit(self, X: pd.DataFrame, y=None):\nreturn self\ndef transform(self, X: pd.DataFrame, y=None):\nX[self.col] = (X[self.col] // 1).astype(int)\nself.columns = list(X.columns)\nreturn X\ndef get_feature_names_out(self, input_features=None):\nreturn self.columns\n</code></pre>"},{"location":"modules/transformers/#latent_calendar.transformers.LongToWide","title":"<code>LongToWide</code>","text":"<p>             Bases: <code>BaseEstimator</code>, <code>TransformerMixin</code></p> Source code in <code>latent_calendar/transformers.py</code> <pre><code>class LongToWide(BaseEstimator, TransformerMixin):\ndef __init__(self, col: str = \"num_events\", as_int: bool = True) -&gt; None:\nself.col = col\nself.as_int = as_int\ndef fit(self, X: pd.DataFrame, y=None):\nreturn self\ndef transform(self, X: pd.DataFrame, y=None) -&gt; pd.DataFrame:\n\"\"\"Unstack the assumed last index as vocab column.\"\"\"\nX_T = X.loc[:, self.col].unstack().T\nX_T.index = X_T.index.get_level_values(-1)\nX_T = X_T.reindex(FULL_VOCAB)\nX_res = X_T.T.fillna(value=0)\nif self.as_int:\nX_res = X_res.astype(int)\nreturn X_res\ndef get_feature_names_out(self, input_features=None):\nreturn FULL_VOCAB\n</code></pre>"},{"location":"modules/transformers/#latent_calendar.transformers.LongToWide.transform","title":"<code>transform(X, y=None)</code>","text":"<p>Unstack the assumed last index as vocab column.</p> Source code in <code>latent_calendar/transformers.py</code> <pre><code>def transform(self, X: pd.DataFrame, y=None) -&gt; pd.DataFrame:\n\"\"\"Unstack the assumed last index as vocab column.\"\"\"\nX_T = X.loc[:, self.col].unstack().T\nX_T.index = X_T.index.get_level_values(-1)\nX_T = X_T.reindex(FULL_VOCAB)\nX_res = X_T.T.fillna(value=0)\nif self.as_int:\nX_res = X_res.astype(int)\nreturn X_res\n</code></pre>"},{"location":"modules/transformers/#latent_calendar.transformers.RawToVocab","title":"<code>RawToVocab</code>","text":"<p>             Bases: <code>BaseEstimator</code>, <code>TransformerMixin</code></p> <p>Transformer timestamp level data into id level data with vocab columns.</p> Source code in <code>latent_calendar/transformers.py</code> <pre><code>class RawToVocab(BaseEstimator, TransformerMixin):\n\"\"\"Transformer timestamp level data into id level data with vocab columns.\"\"\"\ndef __init__(\nself,\nid_col: str,\ntimestamp_col: str,\nadditional_groups: Optional[List[str]] = None,\ncols: Optional[List[str]] = None,\n) -&gt; None:\nself.id_col = id_col\nself.timestamp_col = timestamp_col\nself.additional_groups = additional_groups\nself.cols = cols\ndef fit(self, X: pd.DataFrame, y=None):\n# New features at same index level\nself.features = create_timestamp_feature_pipeline(\nself.timestamp_col,\n)\ngroups = [self.id_col]\nif self.additional_groups is not None:\nif not isinstance(self.additional_groups, list):\nraise ValueError(\nf\"additional_groups should be list not {type(self.additional_groups)}\"\n)\ngroups.extend(self.additional_groups)\ngroups.append(\"vocab\")\n# Reaggregation\nself.aggregation = VocabAggregation(groups=groups, cols=self.cols)\n# Unstacking\nself.widden = LongToWide(col=\"num_events\")\n# Since nothing needs to be \"fit\"\nreturn self\ndef transform(self, X: pd.DataFrame, y=None) -&gt; pd.DataFrame:\nX_trans = self.features.transform(X)\nX_agg = self.aggregation.transform(X_trans)\nreturn self.widden.transform(X_agg)\n</code></pre>"},{"location":"modules/transformers/#latent_calendar.transformers.VocabAggregation","title":"<code>VocabAggregation</code>","text":"<p>             Bases: <code>BaseEstimator</code>, <code>TransformerMixin</code></p> <p>NOTE: The index of the grouping stays.</p> Source code in <code>latent_calendar/transformers.py</code> <pre><code>class VocabAggregation(BaseEstimator, TransformerMixin):\n\"\"\"NOTE: The index of the grouping stays.\"\"\"\ndef __init__(self, groups: List[str], cols: Optional[List[str]] = None) -&gt; None:\nself.groups = groups\nself.cols = cols\ndef fit(self, X: pd.DataFrame, y=None):\nreturn self\ndef transform(self, X: pd.DataFrame, y=None):\nstats = {}\nif self.cols is not None:\nstats.update({col: (col, \"sum\") for col in self.cols})\ndf_agg = (\nX.assign(num_events=1)\n.groupby(self.groups)\n.agg(num_events=(\"num_events\", \"sum\"), **stats)\n)\nself.columns = list(df_agg.columns)\nreturn df_agg\ndef get_feature_names_out(self, input_features=None):\nreturn self.columns\n</code></pre>"},{"location":"modules/transformers/#latent_calendar.transformers.VocabTransformer","title":"<code>VocabTransformer</code>","text":"<p>             Bases: <code>BaseEstimator</code>, <code>TransformerMixin</code></p> <p>Create a vocab column from the day of week and hour columns.</p> Source code in <code>latent_calendar/transformers.py</code> <pre><code>class VocabTransformer(BaseEstimator, TransformerMixin):\n\"\"\"Create a vocab column from the day of week and hour columns.\"\"\"\ndef __init__(\nself, day_of_week_col: str = \"day_of_week\", hour_col: str = \"hour\"\n) -&gt; None:\nself.day_of_week_col = day_of_week_col\nself.hour_col = hour_col\ndef fit(self, X: pd.DataFrame, y=None):\nreturn self\ndef transform(self, X: pd.DataFrame, y=None) -&gt; pd.DataFrame:\nX[\"vocab\"] = (\nX[self.day_of_week_col]\n.astype(str)\n.str.zfill(2)\n.str.cat(X[self.hour_col].astype(str).str.zfill(2), sep=\" \")\n)\nself.columns = list(X.columns)\nreturn X\ndef get_feature_names_out(self, input_features=None):\nreturn self.columns\n</code></pre>"},{"location":"modules/transformers/#latent_calendar.transformers.create_raw_to_vocab_transformer","title":"<code>create_raw_to_vocab_transformer(id_col, timestamp_col, additional_groups=None)</code>","text":"<p>Wrapper to create the transformer from the configuration options.</p> Source code in <code>latent_calendar/transformers.py</code> <pre><code>def create_raw_to_vocab_transformer(\nid_col: str,\ntimestamp_col: str,\nadditional_groups: Optional[List[str]] = None,\n) -&gt; RawToVocab:\n\"\"\"Wrapper to create the transformer from the configuration options.\"\"\"\nreturn RawToVocab(\nid_col=id_col,\ntimestamp_col=timestamp_col,\nadditional_groups=additional_groups,\n)\n</code></pre>"},{"location":"modules/transformers/#latent_calendar.transformers.create_timestamp_feature_pipeline","title":"<code>create_timestamp_feature_pipeline(timestamp_col)</code>","text":"<p>Create a pipeline that creates features from the timestamp column.</p> <p>Parameters:</p> Name Type Description Default <code>timestamp_col</code> <code>str</code> <p>The name of the timestamp column.</p> required <p>Returns:</p> Type Description <code>Pipeline</code> <p>A pipeline that creates features from the timestamp column.</p> Example <p>Create features for the online transactions dataset.</p> <pre><code>from latent_calendar.datasets import load_online_transactions\ndf = load_online_transactions()\ntransformers = create_timestamp_feature_pipeline(timestamp_col=\"InvoiceDate\")\ndf_features = transformers.fit_transform(df)\n</code></pre> Source code in <code>latent_calendar/transformers.py</code> <pre><code>def create_timestamp_feature_pipeline(\ntimestamp_col: str,\n) -&gt; Pipeline:\n\"\"\"Create a pipeline that creates features from the timestamp column.\n    Args:\n        timestamp_col: The name of the timestamp column.\n    Returns:\n        A pipeline that creates features from the timestamp column.\n    Example:\n        Create features for the online transactions dataset.\n        ```python\n        from latent_calendar.datasets import load_online_transactions\n        df = load_online_transactions()\n        transformers = create_timestamp_feature_pipeline(timestamp_col=\"InvoiceDate\")\n        df_features = transformers.fit_transform(df)\n        ```\n    \"\"\"\nvocab_col = \"hour\"\nreturn Pipeline(\n[\n(\n\"timestamp_features\",\nCalandarTimestampFeatures(timestamp_col=timestamp_col),\n),\n(\"binning\", HourDiscretizer(col=vocab_col)),\n(\"vocab_creation\", VocabTransformer(hour_col=vocab_col)),\n]\n).set_output(transform=\"pandas\")\n</code></pre>"},{"location":"modules/transformers/#latent_calendar.transformers.prop_into_day","title":"<code>prop_into_day(dt)</code>","text":"<p>Returns the proportion into the day from datetime like object.</p> <p>0.0 is midnight and 1.0 is midnight again.</p> <p>Parameters:</p> Name Type Description Default <code>dt</code> <code>Union[datetime, DatetimeProperties]</code> <p>datetime like object</p> required <p>Returns:</p> Type Description <code>Union[float, Series]</code> <p>numeric value(s) between 0.0 and 1.0</p> Source code in <code>latent_calendar/transformers.py</code> <pre><code>def prop_into_day(dt: Union[datetime, DatetimeProperties]) -&gt; Union[float, pd.Series]:\n\"\"\"Returns the proportion into the day from datetime like object.\n    0.0 is midnight and 1.0 is midnight again.\n    Args:\n        dt: datetime like object\n    Returns:\n        numeric value(s) between 0.0 and 1.0\n    \"\"\"\nprop_hour = dt.hour / HOURS_IN_DAY\nprop_minute = dt.minute / MINUTES_IN_DAY\nprop_second = dt.second / SECONDS_IN_DAY\nprop_microsecond = dt.microsecond / MICROSECONDS_IN_DAY\nreturn prop_hour + prop_minute + prop_second + prop_microsecond\n</code></pre>"},{"location":"modules/vocab/","title":"Vocab","text":"<p>Operations and relationship with the \"vocab\" of the default time slots.</p>"},{"location":"modules/vocab/#latent_calendar.vocab.DOWHour","title":"<code>DOWHour</code>  <code>dataclass</code>","text":"<p>Day of week and hour of day class.</p> Source code in <code>latent_calendar/vocab.py</code> <pre><code>@dataclass\nclass DOWHour:\n\"\"\"Day of week and hour of day class.\"\"\"\ndow: int\nhour: int\n@classmethod\ndef from_vocab(cls, vocab: str) -&gt; \"DOWHour\":\n\"\"\"Construct from a vocab string.\"\"\"\ndow, hour = get_day_hour(vocab=vocab)\nreturn cls(dow=dow, hour=hour)\ndef __post_init__(self) -&gt; None:\nmsg = \"Day of week goes from 0 to 6 and hour of day goes from 0 to 24.\"\nif not 0 &lt;= self.dow &lt;= 6:\nraise ValueError(msg)\nif not 0 &lt;= self.hour &lt;= 24:\nraise ValueError(msg)\ndef is_after(self, other: \"DOWHour\") -&gt; bool:\n\"\"\"Check if self is after other.\"\"\"\nif self.dow &gt; other.dow:\nreturn True\nif self.dow &lt; other.dow:\nreturn False\nreturn self.hour &gt; other.hour\n@property\ndef vocab(self) -&gt; str:\n\"\"\"Get the vocab string for an instance.\"\"\"\nreturn format_dow_hour(self.dow, self.hour)\ndef __add__(self, hours: int) -&gt; \"DOWHour\":\n\"\"\"Add a number of hours.\"\"\"\ndow, hour = self.dow, self.hour\nfor _ in range(hours):\nhour += 1\nif hour &gt; 23:\ndow += 1\ndow = dow % 7\nhour = hour % 24\nreturn DOWHour(dow=dow, hour=hour)\n</code></pre>"},{"location":"modules/vocab/#latent_calendar.vocab.DOWHour.vocab","title":"<code>vocab: str</code>  <code>property</code>","text":"<p>Get the vocab string for an instance.</p>"},{"location":"modules/vocab/#latent_calendar.vocab.DOWHour.__add__","title":"<code>__add__(hours)</code>","text":"<p>Add a number of hours.</p> Source code in <code>latent_calendar/vocab.py</code> <pre><code>def __add__(self, hours: int) -&gt; \"DOWHour\":\n\"\"\"Add a number of hours.\"\"\"\ndow, hour = self.dow, self.hour\nfor _ in range(hours):\nhour += 1\nif hour &gt; 23:\ndow += 1\ndow = dow % 7\nhour = hour % 24\nreturn DOWHour(dow=dow, hour=hour)\n</code></pre>"},{"location":"modules/vocab/#latent_calendar.vocab.DOWHour.from_vocab","title":"<code>from_vocab(vocab)</code>  <code>classmethod</code>","text":"<p>Construct from a vocab string.</p> Source code in <code>latent_calendar/vocab.py</code> <pre><code>@classmethod\ndef from_vocab(cls, vocab: str) -&gt; \"DOWHour\":\n\"\"\"Construct from a vocab string.\"\"\"\ndow, hour = get_day_hour(vocab=vocab)\nreturn cls(dow=dow, hour=hour)\n</code></pre>"},{"location":"modules/vocab/#latent_calendar.vocab.DOWHour.is_after","title":"<code>is_after(other)</code>","text":"<p>Check if self is after other.</p> Source code in <code>latent_calendar/vocab.py</code> <pre><code>def is_after(self, other: \"DOWHour\") -&gt; bool:\n\"\"\"Check if self is after other.\"\"\"\nif self.dow &gt; other.dow:\nreturn True\nif self.dow &lt; other.dow:\nreturn False\nreturn self.hour &gt; other.hour\n</code></pre>"},{"location":"modules/vocab/#latent_calendar.vocab.HourFormatter","title":"<code>HourFormatter</code>  <code>dataclass</code>","text":"<p>Class to format the hour that includes midnight and noon.</p> <p>Parameters:</p> Name Type Description Default <code>midnight</code> <code>Optional[str]</code> <p>string to use for midnight</p> <code>'Midnight'</code> <code>noon</code> <code>Optional[str]</code> <p>string to use for noon</p> <code>'Noon'</code> <code>format_hour</code> <code>HOUR_FORMATTER</code> <p>HOUR_FORMATTER to map hour int to string</p> <code>HOUR_FORMATTERS['12hr']</code> <p>Examples:</p> <p>Just return the number and add midnight and noon.</p> <pre><code>hour_formatter = HourFormatter(\nmidnight=\"Midnight\",\nnoon=\"Noon\",\nformat_hour=lambda hour: hour\n)\nhour_formatter(0) # \"Midnight\"\nhour_formatter(12) # \"Noon\"\nhour_formatter(1) # 1\nhour_formatter(13) # 13\nhour_formatter(24) # \"Midnight\"\n</code></pre> Source code in <code>latent_calendar/vocab.py</code> <pre><code>@dataclass\nclass HourFormatter:\n\"\"\"Class to format the hour that includes midnight and noon.\n    Args:\n        midnight: string to use for midnight\n        noon: string to use for noon\n        format_hour: HOUR_FORMATTER to map hour int to string\n    Examples:\n        Just return the number and add midnight and noon.\n        ```python\n        hour_formatter = HourFormatter(\n            midnight=\"Midnight\",\n            noon=\"Noon\",\n            format_hour=lambda hour: hour\n        )\n        hour_formatter(0) # \"Midnight\"\n        hour_formatter(12) # \"Noon\"\n        hour_formatter(1) # 1\n        hour_formatter(13) # 13\n        hour_formatter(24) # \"Midnight\"\n        ```\n    \"\"\"\nmidnight: Optional[str] = \"Midnight\"\nnoon: Optional[str] = \"Noon\"\nformat_hour: HOUR_FORMATTER = HOUR_FORMATTERS[\"12hr\"]\ndef __call__(self, hr: int) -&gt; str:\nif self.midnight is not None and hr in (0, HOURS_IN_DAY):\nreturn self.midnight\nif hr == 12:\nreturn self.noon if self.noon is not None else self.format_hour(hr)\nreturn self.format_hour(hr)\n</code></pre>"},{"location":"modules/vocab/#latent_calendar.vocab.am_pm_of_hour","title":"<code>am_pm_of_hour(hour)</code>","text":"<p>Get the am or pm of the hour.</p> <p>Parameters:</p> Name Type Description Default <code>hour</code> <code>int</code> <p>hour of the day</p> required <p>Returns:</p> Type Description <code>str</code> <p>am or pm</p> Source code in <code>latent_calendar/vocab.py</code> <pre><code>def am_pm_of_hour(hour: int) -&gt; str:\n\"\"\"Get the am or pm of the hour.\n    Args:\n        hour: hour of the day\n    Returns:\n        am or pm\n    \"\"\"\nreturn \"am\" if hour &lt; 12 else \"pm\"\n</code></pre>"},{"location":"modules/vocab/#latent_calendar.vocab.get_day_hour","title":"<code>get_day_hour(vocab)</code>","text":"<p>Get the day and hour from the vocab.</p> Source code in <code>latent_calendar/vocab.py</code> <pre><code>def get_day_hour(vocab: str) -&gt; Tuple[int, int]:\n\"\"\"Get the day and hour from the vocab.\"\"\"\nday_str, hour_str = vocab.split(\" \")\nreturn int(day_str), int(hour_str)\n</code></pre>"},{"location":"modules/vocab/#latent_calendar.vocab.make_human_readable","title":"<code>make_human_readable(vocab, hour_formatter=HOUR_FORMATTERS['12_am_pm'])</code>","text":"<p>Create a human readable string of the vocab.</p> <p>Parameters:</p> Name Type Description Default <code>vocab</code> <code>str</code> <p>string vocab. i.e. \"00 01\"</p> required <code>hour_formatter</code> <code>HOUR_FORMATTER</code> <p>HOUR_FORMATTER to map hour int to string</p> <code>HOUR_FORMATTERS['12_am_pm']</code> <p>Returns:</p> Type Description <code>str</code> <p>human readable string of the vocab</p> Source code in <code>latent_calendar/vocab.py</code> <pre><code>def make_human_readable(\nvocab: str, hour_formatter: HOUR_FORMATTER = HOUR_FORMATTERS[\"12_am_pm\"]\n) -&gt; str:\n\"\"\"Create a human readable string of the vocab.\n    Args:\n        vocab: string vocab. i.e. \"00 01\"\n        hour_formatter: HOUR_FORMATTER to map hour int to string\n    Returns:\n        human readable string of the vocab\n    \"\"\"\nday, hour = get_day_hour(vocab=vocab)\nhuman_day = calendar.day_name[day]\nhuman_hour = hour_formatter(hour)\nreturn f\"{human_day} {human_hour}\"\n</code></pre>"},{"location":"modules/vocab/#latent_calendar.vocab.map_to_12_hour","title":"<code>map_to_12_hour(hour)</code>","text":"<p>Map the hour to a 12 hour clock.</p> Source code in <code>latent_calendar/vocab.py</code> <pre><code>def map_to_12_hour(hour: int) -&gt; int:\n\"\"\"Map the hour to a 12 hour clock.\"\"\"\nif hour == 0:\nreturn 12\nif hour == 12:\nreturn hour\nreturn hour % 12\n</code></pre>"},{"location":"modules/vocab/#latent_calendar.vocab.split_vocab","title":"<code>split_vocab(ser)</code>","text":"<p>Split pandas series of vocab into day of week and hour of day DataFrame.</p> Source code in <code>latent_calendar/vocab.py</code> <pre><code>def split_vocab(ser: pd.Series) -&gt; pd.DataFrame:\n\"\"\"Split pandas series of vocab into day of week and hour of day DataFrame.\"\"\"\ndf_split = ser.str.split(\" \", expand=True).astype(int)\ndf_split.columns = [\"dow\", \"hour\"]\nreturn df_split\n</code></pre>"},{"location":"modules/plot/colors/","title":"Colors","text":"<p>Handling the colors in the calendar plots.</p> <p>This module provides some helper function and some defaults. However, they might  not be the best of all purposes.</p> <p>Color maps here take floats to a color string. Usually a hex string.</p> Example <p>Create a color map for count data. </p> <pre><code>cmap = create_default_cmap(max_value=10)\ncmap(0)  # '#ffffe5'\ncmap(5)  # '#379e54'\ncmap(10) # '#004529'\n</code></pre>"},{"location":"modules/plot/colors/#latent_calendar.plot.colors.ColorMap","title":"<code>ColorMap</code>","text":"<p>             Bases: <code>ScalarMappable</code></p> <p>This supports colorbar for a figure from matplotlib.</p> <p>Parameters:</p> Name Type Description Default <code>norm</code> <p>matplotlib.colors.Normalize</p> required <code>cmap</code> <p>matplotlib.cm.ScalarMappable</p> required <code>default_cm</code> <code>CM</code> <p>matplotlib.cm.ScalarMappable</p> required Source code in <code>latent_calendar/plot/colors.py</code> <pre><code>class ColorMap(ScalarMappable):\n\"\"\"This supports colorbar for a figure from matplotlib.\n    Args:\n        norm: matplotlib.colors.Normalize\n        cmap: matplotlib.cm.ScalarMappable\n        default_cm: matplotlib.cm.ScalarMappable\n    \"\"\"\ndef __init__(self, norm, cmap, default_cm: CM) -&gt; None:\ncmap = cmap if cmap is not None else default_cm\nsuper().__init__(norm=norm, cmap=cmap)\ndef __call__(self, x: float) -&gt; str:\nreturn rgb2hex(self.cmap(self.norm(x)))\ndef add_colorbar(self, ax=None) -&gt; None:\n\"\"\"Add the colorbar to axis or axes.\n        Args:\n            ax: single or np.ndarray of Axes\n        \"\"\"\nfig = plt.gcf()\nfig.colorbar(self, ax=ax, ticks=self.norm.ticks)\n</code></pre>"},{"location":"modules/plot/colors/#latent_calendar.plot.colors.ColorMap.add_colorbar","title":"<code>add_colorbar(ax=None)</code>","text":"<p>Add the colorbar to axis or axes.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <p>single or np.ndarray of Axes</p> <code>None</code> Source code in <code>latent_calendar/plot/colors.py</code> <pre><code>def add_colorbar(self, ax=None) -&gt; None:\n\"\"\"Add the colorbar to axis or axes.\n    Args:\n        ax: single or np.ndarray of Axes\n    \"\"\"\nfig = plt.gcf()\nfig.colorbar(self, ax=ax, ticks=self.norm.ticks)\n</code></pre>"},{"location":"modules/plot/colors/#latent_calendar.plot.colors.create_cmap","title":"<code>create_cmap(max_value, min_value=0.0, cm=None)</code>","text":"<p>Create color map function.</p> <p>Parameters:</p> Name Type Description Default <code>max_value</code> <code>float</code> <p>maximum value for the color map</p> required <code>min_value</code> <code>float</code> <p>minimum value for the color map</p> <code>0.0</code> <code>cm</code> <code>Optional[CM]</code> <p>function that takes a value and returns a color</p> <code>None</code> Source code in <code>latent_calendar/plot/colors.py</code> <pre><code>def create_cmap(\nmax_value: float, min_value: float = 0.0, cm: Optional[CM] = None\n) -&gt; CMAP:\n\"\"\"Create color map function.\n    Args:\n        max_value: maximum value for the color map\n        min_value: minimum value for the color map\n        cm: function that takes a value and returns a color\n    \"\"\"\nnorm = Normalize(vmin=min_value, vmax=max_value)\nnorm.ticks = [norm.vmin, norm.vmax]\nreturn ColorMap(norm=norm, cmap=cm, default_cm=plt.cm.YlGn)\n</code></pre>"},{"location":"modules/plot/colors/#latent_calendar.plot.colors.create_diverge_cmap","title":"<code>create_diverge_cmap(center_value, range, cm=None)</code>","text":"<p>Create color map function to emphasize a center value and deviation from that center.</p> <p>Might be good for values that are relative to some baseline</p> Source code in <code>latent_calendar/plot/colors.py</code> <pre><code>def create_diverge_cmap(\ncenter_value: float, range: float, cm: Optional[CM] = None\n) -&gt; CMAP:\n\"\"\"Create color map function to emphasize a center value and deviation from that center.\n    Might be good for values that are relative to some baseline\n    \"\"\"\nhalf_range = range / 2\nnorm = Normalize(vmin=center_value - half_range, vmax=center_value + half_range)\nnorm.ticks = [norm.vmin, 0, norm.vmax]\nreturn ColorMap(norm=norm, cmap=cm, default_cm=plt.cm.coolwarm)\n</code></pre>"},{"location":"modules/plot/colors/#latent_calendar.plot.colors.create_relative_cmap","title":"<code>create_relative_cmap(range)</code>","text":"<p>Good for relative scales.</p> Source code in <code>latent_calendar/plot/colors.py</code> <pre><code>def create_relative_cmap(range: float) -&gt; CMAP:\n\"\"\"Good for relative scales.\"\"\"\nreturn create_diverge_cmap(center_value=1.0, range=range)\n</code></pre>"},{"location":"modules/plot/colors/#latent_calendar.plot.colors.settle_data_and_cmap","title":"<code>settle_data_and_cmap(data, divergent)</code>","text":"<p>Return a tuple of transformed data and cmap for displaying that data.</p> Source code in <code>latent_calendar/plot/colors.py</code> <pre><code>def settle_data_and_cmap(data, divergent: bool) -&gt; Tuple[np.ndarray, CMAP]:\n\"\"\"Return a tuple of transformed data and cmap for displaying that data.\"\"\"\nif divergent:\n# Comparing the values to random rate\ndata = data / EVEN_PROBABILITY\nreturn data, create_default_divergent_cmap()\nreturn data, create_default_cmap(value=data.max())\n</code></pre>"},{"location":"modules/plot/config/","title":"Config","text":"<p>Configuration file for plotting.</p>"},{"location":"modules/plot/config/#latent_calendar.plot.config.Config","title":"<code>Config</code>  <code>dataclass</code>","text":"<p>Default configuration used in some of the plots.</p> <p>Parameters:</p> Name Type Description Default <code>divergent</code> <code>bool</code> <p>whether to show divergent calendar by default.</p> <code>True</code> <code>range</code> <code>float</code> <p>Where to a divergent plot</p> <code>3.0</code> <code>max_value_ratio</code> <code>float</code> <p>Where to clip the default cmap in the calendar view</p> <code>0.75</code> Source code in <code>latent_calendar/plot/config.py</code> <pre><code>@dataclass\nclass Config:\n\"\"\"Default configuration used in some of the plots.\n    Args:\n        divergent: whether to show divergent calendar by default.\n        range: Where to a divergent plot\n        max_value_ratio: Where to clip the default cmap in the calendar view\n    \"\"\"\ndivergent: bool = True\nrange: float = 3.0\nmax_value_ratio: float = 0.75\n</code></pre>"},{"location":"modules/plot/core/","title":"Core","text":"<p>Plots including a model.</p>"},{"location":"modules/plot/core/#latent_calendar.plot.core.calendar.plot_blank_calendar","title":"<code>plot_blank_calendar(day_labeler=DayLabeler(), time_labeler=TimeLabeler(), display_settings=None, ax=None, grid_lines=GridLines(), monday_start=True)</code>","text":"<p>Create a blank calendar with no data</p> <p>Parameters:</p> Name Type Description Default <code>day_labeler</code> <code>DayLabeler</code> <p>instance in order to configure the day labels</p> <code>DayLabeler()</code> <code>time_labeler</code> <code>TimeLabeler</code> <p>instance in order to configure the time labels</p> <code>TimeLabeler()</code> <code>display_settings</code> <code>Optional[DisplaySettings]</code> <p>override of the display settings in the calendar</p> <code>None</code> <code>ax</code> <code>Optional[matplotlib.Axes]</code> <p>Optional axes to plot on</p> <code>None</code> <code>grid_lines</code> <code>GridLines</code> <p>GridLines instance</p> <code>GridLines()</code> <code>monday_start</code> <code>bool</code> <p>whether to start the week on Monday or Sunday</p> <code>True</code> <p>Returns:</p> Type Description <code>Axes</code> <p>Modified matplotlib axis</p> Source code in <code>latent_calendar/plot/core/calendar.py</code> <pre><code>def plot_blank_calendar(\nday_labeler: DayLabeler = DayLabeler(),\ntime_labeler: TimeLabeler = TimeLabeler(),\ndisplay_settings: Optional[DisplaySettings] = None,\nax: Optional[plt.Axes] = None,\ngrid_lines: GridLines = GridLines(),\nmonday_start: bool = True,\n) -&gt; plt.Axes:\n\"\"\"Create a blank calendar with no data\n    Args:\n        day_labeler: instance in order to configure the day labels\n        time_labeler: instance in order to configure the time labels\n        display_settings: override of the display settings in the calendar\n        ax: Optional axes to plot on\n        grid_lines: GridLines instance\n        monday_start: whether to start the week on Monday or Sunday\n    Returns:\n        Modified matplotlib axis\n    \"\"\"\nupdate_start(day_labeler=day_labeler, monday_start=monday_start)\nif display_settings is not None:\nupdate_display_settings(\nday_labeler=day_labeler,\ntime_labeler=time_labeler,\ndisplay_settings=display_settings,\n)\nax = ax if ax is not None else plt.gca()\nconfigure_axis(ax=ax, day_labeler=day_labeler, time_labeler=time_labeler)\ngrid_lines.configure_grid(ax=ax)\nreturn ax\n</code></pre>"},{"location":"modules/plot/core/#latent_calendar.plot.core.calendar.plot_calendar","title":"<code>plot_calendar(calendar_iter, *, day_labeler=DayLabeler(), time_labeler=TimeLabeler(), display_settings=None, cmap=None, alpha=None, ax=None, grid_lines=GridLines(), monday_start=True)</code>","text":"<p>Plot a calendar from generator of values.</p> <p>This can plot both numpy matrix and DataFrame values as long as the iterable fits CALENDAR_ITERATION definition</p> <p>Parameters:</p> Name Type Description Default <code>calendar_iter</code> <code>CALENDAR_ITERATION</code> <p>CALENDAR_ITERATION</p> required <code>day_labeler</code> <code>DayLabeler</code> <p>instance in order to configure the day labels</p> <code>DayLabeler()</code> <code>time_labeler</code> <code>TimeLabeler</code> <p>instance in order to configure the time labels</p> <code>TimeLabeler()</code> <code>display_settings</code> <code>Optional[DisplaySettings]</code> <p>override of the display settings in the calendar</p> <code>None</code> <code>cmap</code> <code>Optional[CMAP]</code> <p>function that maps floats to string colors</p> <code>None</code> <code>ax</code> <code>Optional[matplotlib.Axes]</code> <p>Optional axes to plot on</p> <code>None</code> <code>grid_lines</code> <code>GridLines</code> <p>GridLines instance</p> <code>GridLines()</code> <code>monday_start</code> <code>bool</code> <p>whether to start the week on Monday or Sunday</p> <code>True</code> <p>Returns:</p> Type Description <code>Axes</code> <p>Modified matplotlib axis</p> Source code in <code>latent_calendar/plot/core/calendar.py</code> <pre><code>def plot_calendar(\ncalendar_iter: CALENDAR_ITERATION,\n*,\nday_labeler: DayLabeler = DayLabeler(),\ntime_labeler: TimeLabeler = TimeLabeler(),\ndisplay_settings: Optional[DisplaySettings] = None,\ncmap: Optional[CMAP] = None,\nalpha: Optional[float] = None,\nax: Optional[plt.Axes] = None,\ngrid_lines: GridLines = GridLines(),\nmonday_start: bool = True,\n) -&gt; plt.Axes:\n\"\"\"Plot a calendar from generator of values.\n    This can plot both numpy matrix and DataFrame values as long as the iterable fits CALENDAR_ITERATION definition\n    Args:\n        calendar_iter: CALENDAR_ITERATION\n        day_labeler: instance in order to configure the day labels\n        time_labeler: instance in order to configure the time labels\n        display_settings: override of the display settings in the calendar\n        cmap: function that maps floats to string colors\n        ax: Optional axes to plot on\n        grid_lines: GridLines instance\n        monday_start: whether to start the week on Monday or Sunday\n    Returns:\n        Modified matplotlib axis\n    \"\"\"\nax = plot_blank_calendar(\nday_labeler=day_labeler,\ntime_labeler=time_labeler,\ndisplay_settings=display_settings,\nax=ax,\ngrid_lines=grid_lines,\nmonday_start=monday_start,\n)\nif cmap is None:\ncmap = lambda x: \"lightblue\"\nfor calendar_data in calendar_iter:\nevent = CalendarEvent.from_calendar_data(calendar_data=calendar_data)\nevent.plot(\nax=ax,\nfacecolor=cmap(calendar_data.value),\nalpha=alpha,\nmonday_start=monday_start,\n)\nreturn ax\n</code></pre>"},{"location":"modules/plot/core/#latent_calendar.plot.core.calendar.plot_calendar_by_row","title":"<code>plot_calendar_by_row(df, max_cols=3, title_func=None, day_labeler=None, time_labeler=None, cmaps=None, grid_lines=GridLines(), monday_start=True)</code>","text":"<p>Iterate a DataFrame by row and plot calendar events.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>wide DataFrame where each column is the vocabulary</p> required <code>max_cols</code> <code>int</code> <p>max number of columns in the created grid.</p> <code>3</code> <code>title_func</code> <code>Optional[TITLE_FUNC]</code> <p>function to make the title from DataFrame index and DataFrame row, default like '2020-01-01 n_trip(s) = 10'</p> <code>None</code> <code>day_labeler</code> <code>Optional[DayLabeler]</code> <p>base day_labeler</p> <code>None</code> <code>time_labeler</code> <code>Optional[TimeLabeler]</code> <p>base day_labeler</p> <code>None</code> <code>cmaps</code> <code>Optional[Union[CMAP, ColorMap, CMAP_GENERATOR]]</code> <p>Colormapping function(s) to use for each row</p> <code>None</code> <code>grid_lines</code> <code>GridLines</code> <p>GridLines instance</p> <code>GridLines()</code> <code>monday_start</code> <code>bool</code> <p>whether to start the week on Monday or Sunday</p> <code>True</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>latent_calendar/plot/core/calendar.py</code> <pre><code>def plot_calendar_by_row(\ndf: pd.DataFrame,\nmax_cols: int = 3,\ntitle_func: Optional[TITLE_FUNC] = None,\nday_labeler: Optional[DayLabeler] = None,\ntime_labeler: Optional[TimeLabeler] = None,\ncmaps: Optional[Union[CMAP, ColorMap, CMAP_GENERATOR]] = None,\ngrid_lines: GridLines = GridLines(),\nmonday_start: bool = True,\n) -&gt; None:\n\"\"\"Iterate a DataFrame by row and plot calendar events.\n    Args:\n        df: wide DataFrame where each column is the vocabulary\n        max_cols: max number of columns in the created grid.\n        title_func: function to make the title from DataFrame index and DataFrame row, default like '2020-01-01 n_trip(s) = 10'\n        day_labeler: base day_labeler\n        time_labeler: base day_labeler\n        cmaps: Colormapping function(s) to use for each row\n        grid_lines: GridLines instance\n        monday_start: whether to start the week on Monday or Sunday\n    Returns:\n        None\n    \"\"\"\nn_cols = len(df.columns)\nif n_cols % 7 != 0:\nraise CalendarFormatError(\nf\"Number of columns must be a multiple of 7, got {n_cols} columns. Make sure DataFrame is in wide calendar format.\"\n)\ntitle_func = title_func if title_func is not None else default_title_func\nif isinstance(cmaps, ColorMap):\ncmaps = repeat(cmaps)\nif cmaps is None:\ncmaps = repeat(create_default_cmap(value=df.to_numpy().max()))\ntotal = len(df)\nfor (ax, plot_axes), (idx, row), cmap in zip(\ndefault_axes_and_grid_axes(\ntotal=total,\nmax_cols=max_cols,\nday_labeler=day_labeler,\ntime_labeler=time_labeler,\n),\ndf.iterrows(),\ncmaps,\n):\ncalendar_data = row.to_numpy()\nplot_calendar(\niterate_long_array(calendar_data),\nday_labeler=day_labeler,\ntime_labeler=time_labeler,\ngrid_lines=grid_lines,\nax=ax,\ncmap=cmap,\nmonday_start=monday_start,\n)\ntitle = title_func(idx, row)\nax.set_title(title)\n</code></pre>"},{"location":"modules/plot/core/#latent_calendar.plot.core.calendar.plot_dataframe_as_calendar","title":"<code>plot_dataframe_as_calendar(df, config, *, day_labeler=DayLabeler(), time_labeler=TimeLabeler(), grid_lines=GridLines(), cmap=None, alpha=None, ax=None, monday_start=True)</code>","text":"<p>Simple Wrapper about plot_calendar in order to plot DataFrame in various formats</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>DataFrame in format with columns in config instance</p> required <code>config</code> <code>DataFrameConfig</code> <p>DataFrameConfig</p> required <code>day_labeler</code> <code>DayLabeler</code> <p>instance in order to configure the day labels</p> <code>DayLabeler()</code> <code>time_labeler</code> <code>TimeLabeler</code> <p>instance in order to configure the time labels</p> <code>TimeLabeler()</code> <code>grid_lines</code> <code>GridLines</code> <p>GridLines instance</p> <code>GridLines()</code> <code>cmap</code> <code>Optional[CMAP]</code> <p>function that maps floats to string colors</p> <code>None</code> <code>alpha</code> <code>Optional[float]</code> <p>alpha level of each rectangle</p> <code>None</code> <code>ax</code> <code>Optional[matplotlib.Axes]</code> <p>optional axis to plot on</p> <code>None</code> <code>monday_start</code> <code>bool</code> <p>whether to start the week on Monday or Sunday</p> <code>True</code> <p>Returns:</p> Type Description <code>Axes</code> <p>new or modified axes</p> Source code in <code>latent_calendar/plot/core/calendar.py</code> <pre><code>def plot_dataframe_as_calendar(\ndf: pd.DataFrame,\nconfig: DataFrameConfig,\n*,\nday_labeler: DayLabeler = DayLabeler(),\ntime_labeler: TimeLabeler = TimeLabeler(),\ngrid_lines: GridLines = GridLines(),\ncmap: Optional[CMAP] = None,\nalpha: Optional[float] = None,\nax: Optional[plt.Axes] = None,\nmonday_start: bool = True,\n) -&gt; plt.Axes:\n\"\"\"Simple Wrapper about plot_calendar in order to plot DataFrame in various formats\n    Args:\n        df: DataFrame in format with columns in config instance\n        config: DataFrameConfig\n        day_labeler: instance in order to configure the day labels\n        time_labeler: instance in order to configure the time labels\n        grid_lines: GridLines instance\n        cmap: function that maps floats to string colors\n        alpha: alpha level of each rectangle\n        ax: optional axis to plot on\n        monday_start: whether to start the week on Monday or Sunday\n    Returns:\n        new or modified axes\n    \"\"\"\nreturn plot_calendar(\niterate_dataframe(df, config),\nday_labeler=day_labeler,\ntime_labeler=time_labeler,\ncmap=cmap,\nalpha=alpha,\nax=ax,\nmonday_start=monday_start,\ngrid_lines=grid_lines,\n)\n</code></pre>"},{"location":"modules/plot/core/#latent_calendar.plot.core.calendar.plot_dataframe_grid_across_column","title":"<code>plot_dataframe_grid_across_column(df, grid_col, config=None, max_cols=3, *, alpha=None, monday_start=True, day_labeler=DayLabeler(), time_labeler=TimeLabeler(), grid_lines=GridLines())</code>","text":"<p>Plot the long DataFrame in a grid by some different column.</p> <p>Continuous version of the plot_calendar_by_row</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>DataFrame to plot. Requires all the columns in config</p> required <code>grid_col</code> <code>str</code> <p>column name of DataFrame to plot across</p> required <code>config</code> <code>Optional[DataFrameConfig]</code> <p>DataFrameConfig instance of the column mapping. Default IterConfig</p> <code>None</code> <code>max_cols</code> <code>int</code> <p>max number of columns in the grid</p> <code>3</code> <code>alpha</code> <code>Optional[float]</code> <p>alpha of each calendar event</p> <code>None</code> <code>monday_start</code> <code>bool</code> <p>whether to start the week on Monday or Sunday</p> <code>True</code> Source code in <code>latent_calendar/plot/core/calendar.py</code> <pre><code>def plot_dataframe_grid_across_column(\ndf: pd.DataFrame,\ngrid_col: str,\nconfig: Optional[DataFrameConfig] = None,\nmax_cols: int = 3,\n*,\nalpha: Optional[float] = None,\nmonday_start: bool = True,\nday_labeler: DayLabeler = DayLabeler(),\ntime_labeler: TimeLabeler = TimeLabeler(),\ngrid_lines: GridLines = GridLines(),\n) -&gt; None:\n\"\"\"Plot the long DataFrame in a grid by some different column.\n    Continuous version of the plot_calendar_by_row\n    Args:\n        df: DataFrame to plot. Requires all the columns in config\n        grid_col: column name of DataFrame to plot across\n        config: DataFrameConfig instance of the column mapping. Default IterConfig\n        max_cols: max number of columns in the grid\n        alpha: alpha of each calendar event\n        monday_start: whether to start the week on Monday or Sunday\n    \"\"\"\nif grid_col not in df.columns:\nmsg = f\"{grid_col} is not in the DataFrame.\"\nraise KeyError(msg)\nvalues = df.loc[:, grid_col].dropna().unique()\nvalues.sort()\ntotal = len(values)\nfor (ax, plot_axes), value in zip(\ndefault_axes_and_grid_axes(\ntotal=total,\nmax_cols=max_cols,\nday_labeler=day_labeler,\ntime_labeler=time_labeler,\n),\nvalues,\n):\nidx = df[grid_col] == value\ndf_tmp = df.loc[idx, :]\nday_labeler, time_labeler = plot_axes\nplot_dataframe_as_calendar(\ndf=df_tmp,\nconfig=config,\nax=ax,\nday_labeler=day_labeler,\ntime_labeler=time_labeler,\nalpha=alpha,\nmonday_start=monday_start,\n)\nax.set_title(f\"{value}\")\n</code></pre>"},{"location":"modules/plot/core/#latent_calendar.plot.core.calendar.plot_series_as_calendar","title":"<code>plot_series_as_calendar(series, *, grid_lines=GridLines(), day_labeler=DayLabeler(), time_labeler=TimeLabeler(), cmap=None, alpha=None, ax=None, monday_start=True)</code>","text":"<p>Simple Wrapper about plot_calendar in order to plot Series in various formats</p> <p>Parameters:</p> Name Type Description Default <code>series</code> <code>Series</code> <p>Series in format with index as datetime and values as float</p> required <code>grid_lines</code> <code>GridLines</code> <p>GridLines instance</p> <code>GridLines()</code> <code>day_labeler</code> <code>DayLabeler</code> <p>instance in order to configure the day labels</p> <code>DayLabeler()</code> <code>time_labeler</code> <code>TimeLabeler</code> <p>instance in order to configure the time labels</p> <code>TimeLabeler()</code> <code>cmap</code> <code>Optional[CMAP]</code> <p>function that maps floats to string colors</p> <code>None</code> <code>alpha</code> <code>Optional[float]</code> <p>alpha level of each rectangle</p> <code>None</code> <code>ax</code> <code>Optional[matplotlib.Axes]</code> <p>optional axis to plot on</p> <code>None</code> <code>monday_start</code> <code>bool</code> <p>whether to start the week on Monday or Sunday</p> <code>True</code> <p>Returns:</p> Type Description <code>Axes</code> <p>new or modified axes</p> Source code in <code>latent_calendar/plot/core/calendar.py</code> <pre><code>def plot_series_as_calendar(\nseries: pd.Series,\n*,\ngrid_lines: GridLines = GridLines(),\nday_labeler: DayLabeler = DayLabeler(),\ntime_labeler: TimeLabeler = TimeLabeler(),\ncmap: Optional[CMAP] = None,\nalpha: Optional[float] = None,\nax: Optional[plt.Axes] = None,\nmonday_start: bool = True,\n) -&gt; plt.Axes:\n\"\"\"Simple Wrapper about plot_calendar in order to plot Series in various formats\n    Args:\n        series: Series in format with index as datetime and values as float\n        grid_lines: GridLines instance\n        day_labeler: instance in order to configure the day labels\n        time_labeler: instance in order to configure the time labels\n        cmap: function that maps floats to string colors\n        alpha: alpha level of each rectangle\n        ax: optional axis to plot on\n        monday_start: whether to start the week on Monday or Sunday\n    Returns:\n        new or modified axes\n    \"\"\"\nif cmap is None:\ncmap = create_default_cmap(value=series.to_numpy().max())\nreturn plot_calendar(\niterate_series(series),\nday_labeler=day_labeler,\ntime_labeler=time_labeler,\ncmap=cmap,\nalpha=alpha,\nax=ax,\nmonday_start=monday_start,\ngrid_lines=grid_lines,\n)\n</code></pre>"},{"location":"modules/plot/core/#latent_calendar.plot.core.model.plot_component_distribution","title":"<code>plot_component_distribution(X_latent, model, ax)</code>","text":"<p>Third profile plot.</p> Source code in <code>latent_calendar/plot/core/model.py</code> <pre><code>def plot_component_distribution(\nX_latent: np.ndarray, model: LatentCalendar, ax: plt.Axes\n) -&gt; plt.Axes:\n\"\"\"Third profile plot.\"\"\"\nx = range(len(X_latent))\nax.bar(x, X_latent)\nstep = 1 if model.n_components &lt; 15 else 2\nax.set_xticks(np.arange(model.n_components, step=step))\nax.set_ylabel(\"P[L=l | Data]\")\nax.set_title(\"Latent Component Distribution\")\nreturn ax\n</code></pre>"},{"location":"modules/plot/core/#latent_calendar.plot.core.model.plot_distribution","title":"<code>plot_distribution(X_probs, ax, display_y_axis=True, divergent=True, day_labeler=DayLabeler(), time_labeler=TimeLabeler())</code>","text":"<p>Second plot of the profile calendar probability distribution.</p> Source code in <code>latent_calendar/plot/core/model.py</code> <pre><code>def plot_distribution(\nX_probs: np.ndarray,\nax: plt.Axes,\ndisplay_y_axis: bool = True,\ndivergent: bool = True,\nday_labeler: DayLabeler = DayLabeler(),\ntime_labeler: TimeLabeler = TimeLabeler(),\n) -&gt; plt.Axes:\n\"\"\"Second plot of the profile calendar probability distribution.\"\"\"\ntime_labeler.display = display_y_axis\ndata, cmap = settle_data_and_cmap(data=X_probs, divergent=divergent)\niter_data = iterate_long_array(data)\nsubtext = \"Comparison to random rate\" if divergent else \"Raw Probabilities\"\nplot_calendar(\niter_data,\nax=ax,\ncmap=cmap,\nday_labeler=day_labeler,\ntime_labeler=time_labeler,\n)\ntitle = f\"Predicted Probability Distribution\\n{subtext}\"\nax.set_title(title)\nreturn ax\n</code></pre>"},{"location":"modules/plot/core/#latent_calendar.plot.core.model.plot_model_components","title":"<code>plot_model_components(model, max_cols=5, divergent=True, components=None, day_labeler=DayLabeler(), time_labeler=TimeLabeler())</code>","text":"<p>Helper function to create plot of all the components of the LatentCalendar instance.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>LatentCalendar</code> <p>LatentCalendar instance</p> required <code>max_cols</code> <code>int</code> <p>maximum number of columns in the grid of calendar components.</p> <code>5</code> <code>divergent</code> <code>bool</code> <p>what data to plot</p> <code>True</code> <code>components</code> <code>Optional[Iterable[int]]</code> <p>Specific subset of components to plot. Default is all</p> <code>None</code> <code>day_labeler</code> <code>DayLabeler</code> <p>DayLabeler instance</p> <code>DayLabeler()</code> <code>time_labeler</code> <code>TimeLabeler</code> <p>TimeLabeler instance</p> <code>TimeLabeler()</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>latent_calendar/plot/core/model.py</code> <pre><code>def plot_model_components(\nmodel: LatentCalendar,\nmax_cols: int = 5,\ndivergent: bool = True,\ncomponents: Optional[Iterable[int]] = None,\nday_labeler: DayLabeler = DayLabeler(),\ntime_labeler: TimeLabeler = TimeLabeler(),\n) -&gt; None:\n\"\"\"Helper function to create plot of all the components of the LatentCalendar instance.\n    Args:\n        model: LatentCalendar instance\n        max_cols: maximum number of columns in the grid of calendar components.\n        divergent: what data to plot\n        components: Specific subset of components to plot. Default is all\n        day_labeler: DayLabeler instance\n        time_labeler: TimeLabeler instance\n    Returns:\n        None\n    \"\"\"\nif components is None:\ncomponents = list(range(model.n_components))\nif any([component &gt; model.n_components - 1 for component in components]):\nmsg = f\"One of the listed components is greater than the total number {model.n_components}\"\nraise ValueError(msg)\ntotal = len(components)\nnormalized_components_to_plot = model.normalized_components_[components]\nget_title = lambda component_idx: f\"Component {component_idx}\"\n# TOOD: refactor to just use the plot_calendar_by_row ?\nvalues = zip(\ncomponents,\ndefault_axes_and_grid_axes(\ntotal=total,\nmax_cols=max_cols,\nday_labeler=day_labeler,\ntime_labeler=time_labeler,\n),\nnormalized_components_to_plot,\n)\nfor component_idx, (ax, plot_axes), latent in values:\ndata, cmap = settle_data_and_cmap(latent, divergent)\nday_labeler, time_labeler = plot_axes\nplot_calendar(\niterate_long_array(data),\ncmap=cmap,\nax=ax,\nday_labeler=day_labeler,\ntime_labeler=time_labeler,\n)\ntitle = get_title(component_idx=component_idx)\nax.set_title(title)\n</code></pre>"},{"location":"modules/plot/core/#latent_calendar.plot.core.model.plot_model_predictions","title":"<code>plot_model_predictions(X_to_predict, X_holdout, model, divergent=True, axes=None, day_labeler=DayLabeler(), time_labeler=TimeLabeler())</code>","text":"<p>Plot the model predictions compared to the test data.</p> <p>Parameters:</p> Name Type Description Default <code>X_to_predict</code> <code>ndarray</code> <p>Training data for the model</p> required <code>X_test</code> <p>Testing data for the model</p> required <code>model</code> <code>LatentCalendar</code> <p>LatentCalendar model instance</p> required <code>divergent</code> <code>bool</code> <p>Option to change the data displayed</p> <code>True</code> <code>axes</code> <code>Iterable[matplotlib.Axes]</code> <p>list of 3 axes to plot this data</p> <code>None</code> <p>Returns:</p> Type Description <code>Iterable[matplotlib.Axes]</code> <p>The axes used for plotting</p> Source code in <code>latent_calendar/plot/core/model.py</code> <pre><code>def plot_model_predictions(\nX_to_predict: np.ndarray,\nX_holdout: np.ndarray,\nmodel: LatentCalendar,\ndivergent: bool = True,\naxes: Iterable[plt.Axes] = None,\nday_labeler: DayLabeler = DayLabeler(),\ntime_labeler: TimeLabeler = TimeLabeler(),\n) -&gt; Iterable[plt.Axes]:\n\"\"\"Plot the model predictions compared to the test data.\n    Args:\n        X_to_predict: Training data for the model\n        X_test: Testing data for the model\n        model: LatentCalendar model instance\n        divergent: Option to change the data displayed\n        axes: list of 3 axes to plot this data\n    Returns:\n        The axes used for plotting\n    \"\"\"\nX_to_predict = X_to_predict[np.newaxis, :]\nX_holdout = X_holdout[np.newaxis, :]\nif axes is None:\n_, axes = plt.subplots(nrows=1, ncols=3)\nX_to_predict_probs = model.predict(X_to_predict)[0]\nax = axes[0]\nplot_raw_data(array=X_to_predict, ax=ax, day_labeler=day_labeler, time_labeler=time_labeler) \nax.set_title(f\"Raw Data for Prediction\")\nax = axes[1]\nplot_distribution(\nX_probs=X_to_predict_probs,\nax=ax,\ndisplay_y_axis=False,\ndivergent=divergent,\nday_labeler=day_labeler, \ntime_labeler=time_labeler\n)\nax.set_title(\"Distribution from Prediction\")\nax = axes[2]\nplot_raw_data(array=X_holdout, ax=ax, display_y_axis=False, day_labeler=day_labeler, time_labeler=time_labeler)\nax.set_title(\"Raw Data in Future\")\nreturn axes\n</code></pre>"},{"location":"modules/plot/core/#latent_calendar.plot.core.model.plot_profile","title":"<code>plot_profile(array, model, divergent=True, axes=None, include_components=True, day_labeler=DayLabeler(), time_labeler=TimeLabeler())</code>","text":"<p>Create a profile plot with 3 different plots.</p> <p>Displays the raw data, predicted probability distribution, and latent breakdown.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>long array (n_timeslots, )</p> required <code>model</code> <code>LatentCalendar</code> <p>LatentCalendar model instance</p> required <code>divergent</code> <code>bool</code> <p>Option to change the data displayed</p> <code>True</code> <code>axes</code> <code>Iterable[matplotlib.Axes]</code> <p>list of 3 axes to plot this data</p> <code>None</code> <code>include_components</code> <code>bool</code> <p>If the last component plot should be included</p> <code>True</code> <code>day_labeler</code> <code>DayLabeler</code> <p>DayLabeler instance</p> <code>DayLabeler()</code> <code>time_labeler</code> <code>TimeLabeler</code> <p>TimeLabeler instance</p> <code>TimeLabeler()</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>None</p> Source code in <code>latent_calendar/plot/core/model.py</code> <pre><code>def plot_profile(\narray: np.ndarray,\nmodel: LatentCalendar,\ndivergent: bool = True,\naxes: Iterable[plt.Axes] = None,\ninclude_components: bool = True,\nday_labeler: DayLabeler = DayLabeler(),\ntime_labeler: TimeLabeler = TimeLabeler(),\n) -&gt; np.ndarray:\n\"\"\"Create a profile plot with 3 different plots.\n    Displays the raw data, predicted probability distribution, and latent breakdown.\n    Args:\n        array: long array (n_timeslots, )\n        model: LatentCalendar model instance\n        divergent: Option to change the data displayed\n        axes: list of 3 axes to plot this data\n        include_components: If the last component plot should be included\n        day_labeler: DayLabeler instance\n        time_labeler: TimeLabeler instance\n    Returns:\n        None\n    \"\"\"\nncols = 3 if include_components else 2\nif axes is None:\n_, axes = plt.subplots(nrows=1, ncols=ncols)\nif len(axes) != ncols:\nmsg = \"The axes do not equal the number of plots required.\"\nraise ValueError(msg)\n# Data under model\nX_new = array[np.newaxis, :]\nX_probs = model.predict(X_new)[0]\n# Raw Data\nax = axes[0]\nplot_raw_data(array=array, ax=ax, day_labeler=day_labeler, time_labeler=time_labeler)\n# Under Model\nax = axes[1]\nplot_distribution(\nX_probs=X_probs,\nax=ax,\ndisplay_y_axis=False,\ndivergent=divergent,\nday_labeler=day_labeler, \ntime_labeler=time_labeler,\n)\n# Component distribution\nif include_components:\nax = axes[2]\nX_latent = model.transform(X_new)[0]\nplot_component_distribution(X_latent=X_latent, model=model, ax=ax)\nreturn axes\n</code></pre>"},{"location":"modules/plot/core/#latent_calendar.plot.core.model.plot_raw_data","title":"<code>plot_raw_data(array, ax, display_y_axis=True, day_labeler=DayLabeler(), time_labeler=TimeLabeler())</code>","text":"<p>First plot of raw data.</p> Source code in <code>latent_calendar/plot/core/model.py</code> <pre><code>def plot_raw_data(\narray: np.ndarray,\nax: plt.Axes,\ndisplay_y_axis: bool = True,\nday_labeler: DayLabeler = DayLabeler(),\ntime_labeler: TimeLabeler = TimeLabeler(),\n) -&gt; plt.Axes:\n\"\"\"First plot of raw data.\"\"\"\ntry:\nmax_value = np.quantile(array[array &gt; 0], 0.95)\nexcept IndexError:\nmax_value = 1\ntime_labeler.display = display_y_axis\ncmap = create_default_cmap(value=max_value)\nplot_calendar(\niterate_long_array(array),\nax=ax,\ncmap=cmap,\ntime_labeler=time_labeler,\nday_labeler=day_labeler,\n)\nax.set_title(f\"Raw Data\")\nreturn ax\n</code></pre>"},{"location":"modules/plot/elements/","title":"Elements","text":"<p>The specific elements on the calendar plot. </p> <p>Includes x-axis, y-axis, and their settings, as well as the calendar events.</p>"},{"location":"modules/plot/elements/#latent_calendar.plot.elements.CalendarEvent","title":"<code>CalendarEvent</code>  <code>dataclass</code>","text":"<p>Something on the calendar.</p> <p>Plots rectangles on matplotlib axis.</p> <p>Parameters:</p> Name Type Description Default <code>day</code> <code>int</code> <p>The day of the week. 0 is Monday.</p> required <code>start</code> <code>float</code> <p>The start hour of the event.</p> required <code>end</code> <code>Optional[float]</code> <p>The end hour of the event.</p> <code>None</code> <code>duration</code> <code>Optional[float]</code> <p>The duration of the event. Only used if end is None.</p> <code>None</code> <p>Examples:</p> <p>Plot event from calendar data</p> <pre><code>calendar_data = CalendarData(day=0, start=0, end=2.5)\nevent = CalendarEvent.from_calendar_data(calendar_data=calendar_data, cmap=...)\nevent.plot(ax=ax)\nPlot a single calendar event from vocab\n```python\nevent = CalendarEvent.from_vocab(\"00 01\")\nevent.plot(ax=ax)\n</code></pre> Source code in <code>latent_calendar/plot/elements.py</code> <pre><code>@dataclass\nclass CalendarEvent:\n\"\"\"Something on the calendar.\n    Plots rectangles on matplotlib axis.\n    Args:\n        day: The day of the week. 0 is Monday.\n        start: The start hour of the event.\n        end: The end hour of the event.\n        duration: The duration of the event. Only used if end is None.\n    Examples:\n        Plot event from calendar data\n        ```python\n        calendar_data = CalendarData(day=0, start=0, end=2.5)\n        event = CalendarEvent.from_calendar_data(calendar_data=calendar_data, cmap=...)\n        event.plot(ax=ax)\n        Plot a single calendar event from vocab\n        ```python\n        event = CalendarEvent.from_vocab(\"00 01\")\n        event.plot(ax=ax)\n        ```\n    \"\"\"\nday: int\nstart: float\nend: Optional[float] = None\nduration: Optional[float] = None\ndef __post_init__(self) -&gt; None:\nif self.end is None and self.duration is None:\nraise ValueError(\"Either end or duration must be provided\")\nif self.end is not None and self.duration is not None:\nraise ValueError(\"Only one of end or duration can be provided\")\nif self.end is None:\nself.end = self.start + (self.duration / 60)\nself.duration = None\n@classmethod\ndef from_calendar_data(\ncls,\ncalendar_data: CalendarData,\n) -&gt; \"CalendarEvent\":\nreturn cls(\nday=calendar_data.day,\nstart=calendar_data.start,\nend=calendar_data.end,\n)\n@classmethod\ndef from_vocab(\ncls,\nvocab: str,\nduration: float = 60.0,\n) -&gt; \"CalendarEvent\":\n\"\"\"Constructor from vocab string in order to plot on an axis.\n        Args:\n            vocab: The vocab string.\n            duration: The duration of the event.\n        Example:\n            Plot on an axis\n            ```python\n            event = CalendarEvent.from_vocab(\"00 01\")\n            event.plot(ax=ax)\n            ```\n            Plot a two and half hour window\n            ```python\n            event = CalendarEvent.from_vocab(\"00 01\", hours=2.5)\n            event.plot(ax=ax)\n            ```\n        \"\"\"\nday, hour = get_day_hour(vocab=vocab)\nreturn cls(\nday=day,\nstart=hour,\nend=hour + (duration / 60),\n)\n@property\ndef multiday_tour(self) -&gt; bool:\nif self.end == HOURS_IN_DAY:\nreturn False\nreturn self.end % HOURS_IN_DAY &lt; self.start\ndef _cap_event_at_midnight(self) -&gt; \"CalendarEvent\":\nself.end = min(HOURS_IN_DAY, self.end)\ndef _create_next_day_event(self) -&gt; \"CalendarEvent\":\n\"\"\"In the case of tour going into the next day, this is the next item.\"\"\"\nreturn CalendarEvent(\nday=(self.day + 1) % DAYS_IN_WEEK,\nstart=0,\nend=self.end % HOURS_IN_DAY,\n)\ndef separate_events(self) -&gt; List[\"CalendarEvent\"]:\n\"\"\"Return list of events that represent the one event across different days.\n        Examples:\n            A single event that goes from 23:00 to 01:00 will be split into two events.\n            ```python\n            event = CalendarEvent(day=0, start=23, duration=2 * 60)\n            events = event.separate_events()\n            ```\n        \"\"\"\nevents = [replace(self)]\nif self.multiday_tour:\nevents.append(self._create_next_day_event())\n# Cap the initial rectangle at 24 hours\nevents[0]._cap_event_at_midnight()\nreturn events\ndef _create_matplotlib_rectangle(\nself, monday_start: bool, lw, fill: bool, linestyle, fillcolor, alpha, **kwargs\n) -&gt; plt.Rectangle:\n\"\"\"Create a rectangle matplotlib instance from the event.\"\"\"\nheight = self.end - self.start\nassert (\nheight &gt; 0.0\n), f\"The rectangle doesn't have positive height. Hour start {self.start} &gt; Hour end {self.end}\"\nx = self.day if monday_start else (self.day + 1) % DAYS_IN_WEEK\nrect_kwargs = {\n\"xy\": [x, self.start],\n\"width\": 1,\n\"height\": height,\n}\nrect_kwargs[\"edgecolor\"] = \"black\"\nrect_kwargs[\"lw\"] = lw\nrect_kwargs[\"fill\"] = fill\nrect_kwargs[\"linestyle\"] = linestyle\nrect_kwargs[\"facecolor\"] = fillcolor\nrect_kwargs[\"alpha\"] = alpha\nrect_kwargs.update(kwargs)\nreturn plt.Rectangle(**rect_kwargs)\ndef plot(\nself,\nax: plt.Axes,\nmonday_start: bool = True,\nlw: float = 0.1,\nfill: bool = True,\nlinestyle=None,\nfillcolor=None,\nalpha=None,\n**kwargs,\n) -&gt; None:\n\"\"\"Put the CalendarEvent instance onto an axis.\n        Options for kwargs [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.patches.Rectangle.html).\n        Args:\n            ax: Axis to plot on\n            monday_start: Whether to start the week on Monday or Sunday.\n            lw: The line width of the event.\n            fill: Whether to fill the event.\n            linestyle: The line style of the event.\n            fillcolor: The color of the event.\n            alpha: The alpha of the event.\n            kwargs: Addtional kwargs for the Patch instances or to override.\n        \"\"\"\nseparated_events = self.separate_events()\nfor event in separated_events:\nrectangle = event._create_matplotlib_rectangle(\nmonday_start=monday_start,\nlw=lw,\nfill=fill,\nlinestyle=linestyle,\nfillcolor=fillcolor,\nalpha=alpha,\n**kwargs,\n)\nif \"label\" in kwargs:\nkwargs.pop(\"label\")\nax.add_patch(rectangle)\n</code></pre>"},{"location":"modules/plot/elements/#latent_calendar.plot.elements.CalendarEvent.from_vocab","title":"<code>from_vocab(vocab, duration=60.0)</code>  <code>classmethod</code>","text":"<p>Constructor from vocab string in order to plot on an axis.</p> <p>Parameters:</p> Name Type Description Default <code>vocab</code> <code>str</code> <p>The vocab string.</p> required <code>duration</code> <code>float</code> <p>The duration of the event.</p> <code>60.0</code> Example <p>Plot on an axis</p> <pre><code>event = CalendarEvent.from_vocab(\"00 01\")\nevent.plot(ax=ax)\n</code></pre> <p>Plot a two and half hour window</p> <pre><code>event = CalendarEvent.from_vocab(\"00 01\", hours=2.5)\nevent.plot(ax=ax)\n</code></pre> Source code in <code>latent_calendar/plot/elements.py</code> <pre><code>@classmethod\ndef from_vocab(\ncls,\nvocab: str,\nduration: float = 60.0,\n) -&gt; \"CalendarEvent\":\n\"\"\"Constructor from vocab string in order to plot on an axis.\n    Args:\n        vocab: The vocab string.\n        duration: The duration of the event.\n    Example:\n        Plot on an axis\n        ```python\n        event = CalendarEvent.from_vocab(\"00 01\")\n        event.plot(ax=ax)\n        ```\n        Plot a two and half hour window\n        ```python\n        event = CalendarEvent.from_vocab(\"00 01\", hours=2.5)\n        event.plot(ax=ax)\n        ```\n    \"\"\"\nday, hour = get_day_hour(vocab=vocab)\nreturn cls(\nday=day,\nstart=hour,\nend=hour + (duration / 60),\n)\n</code></pre>"},{"location":"modules/plot/elements/#latent_calendar.plot.elements.CalendarEvent.plot","title":"<code>plot(ax, monday_start=True, lw=0.1, fill=True, linestyle=None, fillcolor=None, alpha=None, **kwargs)</code>","text":"<p>Put the CalendarEvent instance onto an axis.</p> <p>Options for kwargs here.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>Axis to plot on</p> required <code>monday_start</code> <code>bool</code> <p>Whether to start the week on Monday or Sunday.</p> <code>True</code> <code>lw</code> <code>float</code> <p>The line width of the event.</p> <code>0.1</code> <code>fill</code> <code>bool</code> <p>Whether to fill the event.</p> <code>True</code> <code>linestyle</code> <p>The line style of the event.</p> <code>None</code> <code>fillcolor</code> <p>The color of the event.</p> <code>None</code> <code>alpha</code> <p>The alpha of the event.</p> <code>None</code> <code>kwargs</code> <p>Addtional kwargs for the Patch instances or to override.</p> <code>{}</code> Source code in <code>latent_calendar/plot/elements.py</code> <pre><code>def plot(\nself,\nax: plt.Axes,\nmonday_start: bool = True,\nlw: float = 0.1,\nfill: bool = True,\nlinestyle=None,\nfillcolor=None,\nalpha=None,\n**kwargs,\n) -&gt; None:\n\"\"\"Put the CalendarEvent instance onto an axis.\n    Options for kwargs [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.patches.Rectangle.html).\n    Args:\n        ax: Axis to plot on\n        monday_start: Whether to start the week on Monday or Sunday.\n        lw: The line width of the event.\n        fill: Whether to fill the event.\n        linestyle: The line style of the event.\n        fillcolor: The color of the event.\n        alpha: The alpha of the event.\n        kwargs: Addtional kwargs for the Patch instances or to override.\n    \"\"\"\nseparated_events = self.separate_events()\nfor event in separated_events:\nrectangle = event._create_matplotlib_rectangle(\nmonday_start=monday_start,\nlw=lw,\nfill=fill,\nlinestyle=linestyle,\nfillcolor=fillcolor,\nalpha=alpha,\n**kwargs,\n)\nif \"label\" in kwargs:\nkwargs.pop(\"label\")\nax.add_patch(rectangle)\n</code></pre>"},{"location":"modules/plot/elements/#latent_calendar.plot.elements.CalendarEvent.separate_events","title":"<code>separate_events()</code>","text":"<p>Return list of events that represent the one event across different days.</p> <p>Examples:</p> <p>A single event that goes from 23:00 to 01:00 will be split into two events.</p> <pre><code>event = CalendarEvent(day=0, start=23, duration=2 * 60)\nevents = event.separate_events()\n</code></pre> Source code in <code>latent_calendar/plot/elements.py</code> <pre><code>def separate_events(self) -&gt; List[\"CalendarEvent\"]:\n\"\"\"Return list of events that represent the one event across different days.\n    Examples:\n        A single event that goes from 23:00 to 01:00 will be split into two events.\n        ```python\n        event = CalendarEvent(day=0, start=23, duration=2 * 60)\n        events = event.separate_events()\n        ```\n    \"\"\"\nevents = [replace(self)]\nif self.multiday_tour:\nevents.append(self._create_next_day_event())\n# Cap the initial rectangle at 24 hours\nevents[0]._cap_event_at_midnight()\nreturn events\n</code></pre>"},{"location":"modules/plot/elements/#latent_calendar.plot.elements.DayLabeler","title":"<code>DayLabeler</code>  <code>dataclass</code>","text":"<p>Day of the week axis.</p> <p>This is typically the x-axis.</p> <p>Parameters:</p> Name Type Description Default <code>day_start</code> <code>int</code> <p>The day to start the plot at.</p> <code>0</code> <code>days_of_week</code> <code>List[str]</code> <p>The names of the days of the week.</p> <code>field(default_factory=create_default_days)</code> <code>rotation</code> <code>Optional[float]</code> <p>The rotation of the day labels.</p> <code>45</code> <code>display</code> <code>bool</code> <p>Whether to display the day labels.</p> <code>True</code> Source code in <code>latent_calendar/plot/elements.py</code> <pre><code>@dataclass\nclass DayLabeler:\n\"\"\"Day of the week axis.\n    This is typically the x-axis.\n    Args:\n        day_start: The day to start the plot at.\n        days_of_week: The names of the days of the week.\n        rotation: The rotation of the day labels.\n        display: Whether to display the day labels.\n    \"\"\"\nday_start: int = 0\ndays_of_week: List[str] = field(default_factory=create_default_days)\nrotation: Optional[float] = 45\ndisplay: bool = True\ndef __post_init__(self) -&gt; None:\nif self.day_start not in range(DAYS_IN_WEEK):\nmsg = f\"'day_start' value must be 0: Monday or 6: Sunday\"\nraise ValueError(msg)\n@property\ndef day_labels(self) -&gt; List[str]:\n\"\"\"What is added to the plot. If this is display, empty ticks.\"\"\"\nif not self.display:\nreturn [\"\" for _ in range(DAYS_IN_WEEK)]\nreturn self.days_of_week[self.day_start :] + self.days_of_week[: self.day_start]\ndef create_labels(self, ax: plt.Axes, axis: str = \"x\") -&gt; None:\n\"\"\"Create the labels for the plot.\"\"\"\ngetattr(ax, f\"set_{axis}lim\")(0, DAYS_IN_WEEK)\ngetattr(ax, f\"set_{axis}ticks\")(\n[i + 0.5 for i in range(DAYS_IN_WEEK)],\nself.day_labels,\nrotation=self.rotation,\n)\nif axis == \"y\":\nax.invert_yaxis()\n</code></pre>"},{"location":"modules/plot/elements/#latent_calendar.plot.elements.DayLabeler.day_labels","title":"<code>day_labels: List[str]</code>  <code>property</code>","text":"<p>What is added to the plot. If this is display, empty ticks.</p>"},{"location":"modules/plot/elements/#latent_calendar.plot.elements.DayLabeler.create_labels","title":"<code>create_labels(ax, axis='x')</code>","text":"<p>Create the labels for the plot.</p> Source code in <code>latent_calendar/plot/elements.py</code> <pre><code>def create_labels(self, ax: plt.Axes, axis: str = \"x\") -&gt; None:\n\"\"\"Create the labels for the plot.\"\"\"\ngetattr(ax, f\"set_{axis}lim\")(0, DAYS_IN_WEEK)\ngetattr(ax, f\"set_{axis}ticks\")(\n[i + 0.5 for i in range(DAYS_IN_WEEK)],\nself.day_labels,\nrotation=self.rotation,\n)\nif axis == \"y\":\nax.invert_yaxis()\n</code></pre>"},{"location":"modules/plot/elements/#latent_calendar.plot.elements.DisplaySettings","title":"<code>DisplaySettings</code>  <code>dataclass</code>","text":"<p>Small wrapper to hold the display settings in the plots.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>bool</code> <p>Whether to x axis the plot.</p> <code>True</code> <code>y</code> <code>bool</code> <p>Whether to y axis the plot.</p> <code>True</code> Source code in <code>latent_calendar/plot/elements.py</code> <pre><code>@dataclass\nclass DisplaySettings:\n\"\"\"Small wrapper to hold the display settings in the plots.\n    Args:\n        x: Whether to x axis the plot.\n        y: Whether to y axis the plot.\n    \"\"\"\nx: bool = True\ny: bool = True\n</code></pre>"},{"location":"modules/plot/elements/#latent_calendar.plot.elements.GridLines","title":"<code>GridLines</code>  <code>dataclass</code>","text":"<p>Grid lines between the calendar for the plot.</p> <p>Parameters:</p> Name Type Description Default <code>dow</code> <code>bool</code> <p>Whether to add day of week grid lines.</p> <code>False</code> <code>hour</code> <code>bool</code> <p>Whether to add hour grid lines.</p> <code>False</code> <code>color</code> <code>str</code> <p>The color of the grid lines.</p> <code>'black'</code> <code>linestyle</code> <code>str</code> <p>The style of the grid lines.</p> <code>'--'</code> <code>alpha</code> <code>float</code> <p>The alpha of the grid lines.</p> <code>0.2</code> Source code in <code>latent_calendar/plot/elements.py</code> <pre><code>@dataclass\nclass GridLines:\n\"\"\"Grid lines between the calendar for the plot.\n    Args:\n        dow: Whether to add day of week grid lines.\n        hour: Whether to add hour grid lines.\n        color: The color of the grid lines.\n        linestyle: The style of the grid lines.\n        alpha: The alpha of the grid lines.\n    \"\"\"\ndow: bool = False\nhour: bool = False\ncolor: str = \"black\"\nlinestyle: str = \"--\"\nalpha: float = 0.2\ndef configure_grid(self, ax: plt.Axes) -&gt; None:\nif self.dow:\nfor dow in range(DAYS_IN_WEEK):\nax.axvline(\nx=dow + 1,\ncolor=self.color,\nlinestyle=self.linestyle,\nalpha=self.alpha,\n)\nif self.hour:\nfor hour in range(HOURS_IN_DAY):\nax.axhline(\ny=hour + 1,\ncolor=self.color,\nlinestyle=self.linestyle,\nalpha=self.alpha,\n)\n</code></pre>"},{"location":"modules/plot/elements/#latent_calendar.plot.elements.TimeLabeler","title":"<code>TimeLabeler</code>  <code>dataclass</code>","text":"<p>This is time of day and all its settings in the plot.</p> <p>This is typically the y-axis.</p> <p>Parameters:</p> Name Type Description Default <code>hour_formatter</code> <code>HourFormatter</code> <p>The formatter for the hour labels.</p> <code>HourFormatter()</code> <code>start</code> <code>int</code> <p>The hour to start the plot at.</p> <code>0</code> <code>stride</code> <code>int</code> <p>The number of hours to skip between ticks.</p> <code>2</code> <code>display</code> <code>bool</code> <p>Whether to display the hour labels.</p> <code>True</code> <code>rotation</code> <code>Optional[float]</code> <p>The rotation of the hour labels.</p> <code>0</code> Source code in <code>latent_calendar/plot/elements.py</code> <pre><code>@dataclass\nclass TimeLabeler:\n\"\"\"This is time of day and all its settings in the plot.\n    This is typically the y-axis.\n    Args:\n        hour_formatter: The formatter for the hour labels.\n        start: The hour to start the plot at.\n        stride: The number of hours to skip between ticks.\n        display: Whether to display the hour labels.\n        rotation: The rotation of the hour labels.\n    \"\"\"\nhour_formatter: HourFormatter = HourFormatter()\nstart: int = 0\nstride: int = 2\ndisplay: bool = True\nrotation: Optional[float] = 0\ndef get_hours(self) -&gt; Tuple[List[int], List[str]]:\nreturn range(HOURS_IN_DAY + 1)[:: self.stride]\ndef create_labels(self, ax: plt.Axes, axis: str = \"y\") -&gt; None:\n\"\"\"Create the hour labels on the plot ax.\"\"\"\nif axis not in {\"x\", \"y\"}:\nraise ValueError(\"Only supported for the x and y.\")\nhours = self.get_hours()\nhour_name_func = self.label if self.display else self.empty_label\nhour_names = hour_name_func(hours)\ngetattr(ax, f\"set_{axis}ticks\")(hours, hour_names, rotation=self.rotation)\ngetattr(ax, f\"set_{axis}lim\")(0, HOURS_IN_DAY)\nif axis == \"y\":\nax.invert_yaxis()\ndef label(self, hrs: List[int]) -&gt; List[str]:\nreturn [self.hour_formatter(hr) for hr in hrs]\ndef empty_label(self, hrs: List[int]) -&gt; List[str]:\nreturn [\"\" for _ in range(len(hrs))]\n</code></pre>"},{"location":"modules/plot/elements/#latent_calendar.plot.elements.TimeLabeler.create_labels","title":"<code>create_labels(ax, axis='y')</code>","text":"<p>Create the hour labels on the plot ax.</p> Source code in <code>latent_calendar/plot/elements.py</code> <pre><code>def create_labels(self, ax: plt.Axes, axis: str = \"y\") -&gt; None:\n\"\"\"Create the hour labels on the plot ax.\"\"\"\nif axis not in {\"x\", \"y\"}:\nraise ValueError(\"Only supported for the x and y.\")\nhours = self.get_hours()\nhour_name_func = self.label if self.display else self.empty_label\nhour_names = hour_name_func(hours)\ngetattr(ax, f\"set_{axis}ticks\")(hours, hour_names, rotation=self.rotation)\ngetattr(ax, f\"set_{axis}lim\")(0, HOURS_IN_DAY)\nif axis == \"y\":\nax.invert_yaxis()\n</code></pre>"},{"location":"modules/plot/grid_settings/","title":"Grid settings","text":""},{"location":"modules/plot/grid_settings/#latent_calendar.plot.grid_settings.default_plot_axes_in_grid","title":"<code>default_plot_axes_in_grid(nrows, ncols, total=None, day_labeler=None, time_labeler=None)</code>","text":"<p>Additional layer on the display_settings_in_grid in order to modify the settings.</p> <p>Yields:</p> Type Description <code>PlotAxes</code> <p>PlotAxes instance with appropriate display settings based on the position in the grid.</p> Source code in <code>latent_calendar/plot/grid_settings.py</code> <pre><code>def default_plot_axes_in_grid(\nnrows: int,\nncols: int,\ntotal: Optional[int] = None,\nday_labeler: Optional[DayLabeler] = None,\ntime_labeler: Optional[TimeLabeler] = None,\n) -&gt; Generator[PlotAxes, None, None]:\n\"\"\"Additional layer on the display_settings_in_grid in order to modify the settings.\n    Yields:\n        PlotAxes instance with appropriate display settings based on the position in the grid.\n    \"\"\"\nday_labeler = day_labeler if day_labeler is not None else DayLabeler()\ndefault_stride = 2 if nrows &lt;= 2 else 4\ntime_labeler = (\ntime_labeler if time_labeler is not None else TimeLabeler(stride=default_stride)\n)\nfor display_settings in display_settings_in_grid(\nnrows=nrows, ncols=ncols, total=total\n):\nday_labeler.display = display_settings.x\ntime_labeler.display = display_settings.y\nyield day_labeler, time_labeler\n</code></pre>"},{"location":"modules/plot/grid_settings/#latent_calendar.plot.grid_settings.display_settings_in_grid","title":"<code>display_settings_in_grid(nrows, ncols, total=None)</code>","text":"<p>Helper for display logic in a grid.</p> <p>Can be used with zip since zip function will stop at the shorts of the iterators</p> <p>Yields:</p> Type Description <code>DisplaySettings</code> <p>DisplaySettings instance with the appropriate settings based on position in the grid.</p> Source code in <code>latent_calendar/plot/grid_settings.py</code> <pre><code>def display_settings_in_grid(\nnrows: int, ncols: int, total: Optional[int] = None\n) -&gt; Generator[DisplaySettings, None, None]:\n\"\"\"Helper for display logic in a grid.\n    Can be used with zip since zip function will stop at the shorts of the iterators\n    Yields:\n        DisplaySettings instance with the appropriate settings based on position in the grid.\n    \"\"\"\ntotal = total if total is not None else nrows * ncols\nyield from (\nDisplaySettings(\nx=last_in_column(i, nrows, ncols, total), y=is_left_edge(i, ncols)\n)\nfor i in range(total)\n)\n</code></pre>"},{"location":"modules/plot/grid_settings/#latent_calendar.plot.grid_settings.get_rows_and_cols","title":"<code>get_rows_and_cols(n, max_cols)</code>","text":"<p>Return the number of rows and cols.</p> Source code in <code>latent_calendar/plot/grid_settings.py</code> <pre><code>def get_rows_and_cols(n: int, max_cols: int) -&gt; Tuple[int, int]:\n\"\"\"Return the number of rows and cols.\"\"\"\nnrows = max((n // max_cols) + 1, 1)\nncols = min(n, max_cols)\nif n % max_cols == 0:\nnrows -= 1\nreturn nrows, ncols\n</code></pre>"},{"location":"modules/plot/grid_settings/#latent_calendar.plot.grid_settings.grid_axes","title":"<code>grid_axes(nrows, ncols, total)</code>","text":"<p>Yields a grid of size nrow, ncols with total cap.</p> <p>Using this instead of plt.subplots(ncols, nrows) and deleting</p> Source code in <code>latent_calendar/plot/grid_settings.py</code> <pre><code>def grid_axes(nrows: int, ncols: int, total: int) -&gt; Generator[plt.Axes, None, None]:\n\"\"\"Yields a grid of size nrow, ncols with total cap.\n    Using this instead of plt.subplots(ncols, nrows) and deleting\n    \"\"\"\ngs = gridspec.GridSpec(nrows, ncols)\nfig = plt.figure()\nyield from (fig.add_subplot(gs[i]) for i in range(total))\n</code></pre>"},{"location":"modules/plot/iterate/","title":"Iterate","text":"<p>Generalize the iteration to support different data formats. Namely, </p> <ul> <li>2d numpy array </li> <li>1d numpy array (long format)</li> <li>pandas Series </li> <li>pandas DataFrame with various columns </li> </ul> <p>This powers the calendar plot and is passed into the <code>plot_calendar</code> function.</p> <p>Examples:</p> <p>Plot calendar based on 1d numpy array.</p> <pre><code>import numpy as np\nfrom latent_calendar.plot import plot_calendar\nfrom latent_calendar.plot.iterate import iterate_long_array\ndata = np.ones(7 * 24)\nplot_calendar(\niterate_long_array(data),\n)\n</code></pre> <p>Plot calendar based on 2d numpy array.</p> <pre><code>from latent_calendar.plot import plot_calendar\ndata = np.ones((7, 24))\nplot_calendar(\niterate_matrix(data),\n)\n</code></pre> <p>Plot calendar for every half hour instead of every hour. NOTE: This happens automatically!</p> <pre><code>from latent_calendar.plot import plot_calendar\ndata = np.ones((7, 24 * 2))\nplot_calendar(\niterate_matrix(data), \n)\n</code></pre>"},{"location":"modules/plot/iterate/#latent_calendar.plot.iterate.CalendarData","title":"<code>CalendarData</code>  <code>dataclass</code>","text":"<p>All the data that goes into calendar plot.</p> Source code in <code>latent_calendar/plot/iterate.py</code> <pre><code>@dataclass\nclass CalendarData:\n\"\"\"All the data that goes into calendar plot.\"\"\"\nday: int\nstart: float\nend: float\nvalue: float\n</code></pre>"},{"location":"modules/plot/iterate/#latent_calendar.plot.iterate.IterConfig","title":"<code>IterConfig</code>  <code>dataclass</code>","text":"<p>             Bases: <code>DataFrameConfig</code></p> <p>Small wrapper to hold the column mapping in DataFrame.</p> Source code in <code>latent_calendar/plot/iterate.py</code> <pre><code>@dataclass\nclass IterConfig(DataFrameConfig):\n\"\"\"Small wrapper to hold the column mapping in DataFrame.\"\"\"\nday: str = \"day_of_week\"\nstart: str = \"hour_start\"\nend: str = \"hour_end\"\nvalue: str = \"value\"\n@property\ndef columns(self) -&gt; List[str]:\nreturn [self.day, self.start, self.end]\ndef extract_columns(self, df: pd.DataFrame) -&gt; FRAME_ITER:\nself._check_columns(df)\nreturn (\ndf[self.day],\ndf[self.start],\ndf[self.end],\nself._default_repeat(df, self.value, VALUE_DEFAULT),\n)\n</code></pre>"},{"location":"modules/plot/iterate/#latent_calendar.plot.iterate.VocabIterConfig","title":"<code>VocabIterConfig</code>  <code>dataclass</code>","text":"<p>             Bases: <code>DataFrameConfig</code></p> <p>Small wrapper to hold the column mapping in the DataFrame.</p> Source code in <code>latent_calendar/plot/iterate.py</code> <pre><code>@dataclass\nclass VocabIterConfig(DataFrameConfig):\n\"\"\"Small wrapper to hold the column mapping in the DataFrame.\"\"\"\nvocab: str = \"vocab\"\nvalue: str = \"value\"\n@property\ndef columns(self) -&gt; List[str]:\nreturn [self.vocab]\ndef extract_columns(self, df: pd.DataFrame) -&gt; FRAME_ITER:\nself._check_columns(df)\nday = df[self.vocab].str.split(\" \").apply(lambda x: int(x[0]))\nstart = df[self.vocab].str.split(\" \").apply(lambda x: int(x[1]))\nreturn (\nday,\nstart,\nstart + 1,\nself._default_repeat(df, self.value, VALUE_DEFAULT),\n)\n</code></pre>"},{"location":"modules/plot/iterate/#latent_calendar.plot.iterate.iterate_dataframe","title":"<code>iterate_dataframe(df, config)</code>","text":"<p>Iterate the calendar data in DataFrame form based on config.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>DataFrame with calendar data.</p> required <code>config</code> <code>DataFrameConfig</code> <p>Configuration to describe what columns to use.</p> required Source code in <code>latent_calendar/plot/iterate.py</code> <pre><code>def iterate_dataframe(\ndf: pd.DataFrame,\nconfig: DataFrameConfig,\n) -&gt; CALENDAR_ITERATION:\n\"\"\"Iterate the calendar data in DataFrame form based on config.\n    Args:\n        df: DataFrame with calendar data.\n        config: Configuration to describe what columns to use.\n    \"\"\"\nfor values in zip(*config.extract_columns(df)):\nyield CalendarData(*values)\n</code></pre>"},{"location":"modules/plot/iterate/#latent_calendar.plot.iterate.iterate_matrix","title":"<code>iterate_matrix(calendar_data)</code>","text":"<p>Iterates the calendar matrix of values.</p> Source code in <code>latent_calendar/plot/iterate.py</code> <pre><code>def iterate_matrix(calendar_data: np.ndarray) -&gt; CALENDAR_ITERATION:\n\"\"\"Iterates the calendar matrix of values.\"\"\"\nif calendar_data.ndim != 2:\nraise ValueError(f\"Data must be 2d not of shape {calendar_data.shape}\")\nn_days, n_hours = calendar_data.shape\nif n_days != DAYS_IN_WEEK:\nraise ValueError(f\"Data must have {DAYS_IN_WEEK} days not {n_days}\")\nstep_size = HOURS_IN_DAY / n_hours\nfor day, hours in enumerate(calendar_data):\nfor hour, value in enumerate(hours):\nstart = hour * step_size\nend = start + step_size\nyield CalendarData(day, start, end, value)\n</code></pre>"}]}